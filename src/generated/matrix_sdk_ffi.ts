// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import NativeModule from './matrix_sdk_ffi-ffi';
import {
  type BackupDownloadStrategy,
  type RoomMemberRole,
  type RoomPowerLevelChanges,
} from './matrix_sdk';
import { type UtdCause } from './matrix_sdk_crypto';
import {
  type EventItemOrigin,
  type LiveBackPaginationStatus,
} from './matrix_sdk_ui';
import { uniffiRustCallAsync } from 'uniffi-bindgen-react-native/async-rust-call';
import { UniffiInternalError } from 'uniffi-bindgen-react-native/errors';
import {
  type FfiConverter,
  type UniffiDuration,
  AbstractFfiConverterArrayBuffer,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterDuration,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
} from 'uniffi-bindgen-react-native/ffi-converters';
import { RustBuffer } from 'uniffi-bindgen-react-native/ffi-types';
import {
  type UniffiHandle,
  UniffiHandleMap,
} from 'uniffi-bindgen-react-native/handle-map';
import {
  type UniffiObjectInterface,
  type UnsafeMutableRawPointer,
} from 'uniffi-bindgen-react-native/objects';
import { uniffiCreateRecord } from 'uniffi-bindgen-react-native/records';
import {
  type UniffiRustCallStatus,
  initializeWithStringLifter,
  rustCall,
  rustCallWithError,
} from 'uniffi-bindgen-react-native/rust-call';

// Get converters from the other files, if any.
import uniffiMatrixSdkConverters from './matrix_sdk';
import uniffiMatrixSdkCryptoConverters from './matrix_sdk_crypto';
import uniffiMatrixSdkUiConverters from './matrix_sdk_ui';
const {
  FfiConverterTypeBackupDownloadStrategy,
  FfiConverterTypeRoomMemberRole,
  FfiConverterTypeRoomPowerLevelChanges,
} = uniffiMatrixSdkConverters;
const { FfiConverterTypeUtdCause } = uniffiMatrixSdkCryptoConverters;
const {
  FfiConverterTypeEventItemOrigin,
  FfiConverterTypeLiveBackPaginationStatus,
} = uniffiMatrixSdkUiConverters;

// Public interface members begin here.

export function genTransactionId(): string {
  return FfiConverterString.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(
        callStatus
      );
    })
  );
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
export async function generateWebviewUrl(
  widgetSettings: WidgetSettings,
  room: Room,
  props: ClientProperties
): Promise<string> /*throws*/ {
  return await uniffiRustCallAsync({
    rustFutureFunc: () => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(
        FfiConverterTypeWidgetSettings.lower(widgetSettings),
        FfiConverterTypeRoom.lower(room),
        FfiConverterTypeClientProperties.lower(props)
      );
    },
    pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
    completeFunc:
      NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
    freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
    liftFunc: FfiConverterString.lift,
    errorHandler: FfiConverterTypeParseError.lift,
  });
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
export function getElementCallRequiredPermissions(
  ownUserId: string
): WidgetCapabilities {
  return FfiConverterTypeWidgetCapabilities.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
        FfiConverterString.lower(ownUserId),
        callStatus
      );
    })
  );
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `setup_tracing`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
export function logEvent(
  file: string,
  line: /*u32*/ number | undefined,
  level: LogLevel,
  target: string,
  message: string
): void {
  rustCall((callStatus) => {
    NativeModule.uniffi_matrix_sdk_ffi_fn_func_log_event(
      FfiConverterString.lower(file),
      FfiConverterOptionalUInt32.lower(line),
      FfiConverterTypeLogLevel.lower(level),
      FfiConverterString.lower(target),
      FfiConverterString.lower(message),
      callStatus
    );
  });
}
export function makeWidgetDriver(
  settings: WidgetSettings
): WidgetDriverAndHandle /*throws*/ {
  return FfiConverterTypeWidgetDriverAndHandle.lift(
    rustCallWithError(FfiConverterTypeParseError.lift, (callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
        FfiConverterTypeWidgetSettings.lower(settings),
        callStatus
      );
    })
  );
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
export function matrixToRoomAliasPermalink(
  roomAlias: string
): string /*throws*/ {
  return FfiConverterString.lift(
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
        FfiConverterString.lower(roomAlias),
        callStatus
      );
    })
  );
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
export function matrixToUserPermalink(userId: string): string /*throws*/ {
  return FfiConverterString.lift(
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
        FfiConverterString.lower(userId),
        callStatus
      );
    })
  );
}
export function mediaSourceFromUrl(url: string): MediaSource {
  return FfiConverterTypeMediaSource.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_media_source_from_url(
        FfiConverterString.lower(url),
        callStatus
      );
    })
  );
}
export function messageEventContentFromHtml(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelation {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),
        callStatus
      );
    })
  );
}
export function messageEventContentFromHtmlAsEmote(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelation {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),
        callStatus
      );
    })
  );
}
export function messageEventContentFromMarkdown(
  md: string
): RoomMessageEventContentWithoutRelation {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(md),
        callStatus
      );
    })
  );
}
export function messageEventContentFromMarkdownAsEmote(
  md: string
): RoomMessageEventContentWithoutRelation {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
        FfiConverterString.lower(md),
        callStatus
      );
    })
  );
}
export function messageEventContentNew(
  msgtype: MessageType
): RoomMessageEventContentWithoutRelation /*throws*/ {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        FfiConverterTypeMessageType.lower(msgtype),
        callStatus
      );
    })
  );
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 * # Arguments
 * * - `props` A struct containing the configuration parameters for a element
 * call widget.
 */
export function newVirtualElementCallWidget(
  props: VirtualElementCallWidgetOptions
): WidgetSettings /*throws*/ {
  return FfiConverterTypeWidgetSettings.lift(
    rustCallWithError(FfiConverterTypeParseError.lift, (callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
        FfiConverterTypeVirtualElementCallWidgetOptions.lower(props),
        callStatus
      );
    })
  );
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
export function parseMatrixEntityFrom(uri: string): MatrixEntity | undefined {
  return FfiConverterOptionalTypeMatrixEntity.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
        FfiConverterString.lower(uri),
        callStatus
      );
    })
  );
}
export function sdkGitSha(): string {
  return FfiConverterString.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(callStatus);
    })
  );
}
export function setupTracing(config: TracingConfiguration): void {
  rustCall((callStatus) => {
    NativeModule.uniffi_matrix_sdk_ffi_fn_func_setup_tracing(
      FfiConverterTypeTracingConfiguration.lower(config),
      callStatus
    );
  });
}
export function suggestedPowerLevelForRole(
  role: RoomMemberRole
): /*i64*/ bigint {
  return FfiConverterInt64.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
        FfiConverterTypeRoomMemberRole.lower(role),
        callStatus
      );
    })
  );
}
export function suggestedRoleForPowerLevel(
  powerLevel: /*i64*/ bigint
): RoomMemberRole {
  return FfiConverterTypeRoomMemberRole.lift(
    rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
        FfiConverterInt64.lower(powerLevel),
        callStatus
      );
    })
  );
}

export type AudioInfo = {
  duration: UniffiDuration | undefined;
  size: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
};

/**
 * Generated factory for {@link AudioInfo} record objects.
 */
export const AudioInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<AudioInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioInfo>,
  });
})();

const FfiConverterTypeAudioInfo = (() => {
  type TypeName = AudioInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalString.write(value.mimetype, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalString.allocationSize(value.mimetype)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomInfo = {
  id: string;
  /**
   * The room's name from the room state event if received from sync, or one
   * that's been computed otherwise.
   */
  displayName: string | undefined;
  /**
   * Room name as defined by the room state event only.
   */
  rawName: string | undefined;
  topic: string | undefined;
  avatarUrl: string | undefined;
  isDirect: boolean;
  isPublic: boolean;
  isSpace: boolean;
  isTombstoned: boolean;
  isFavourite: boolean;
  canonicalAlias: string | undefined;
  alternativeAliases: string[];
  membership: Membership;
  latestEvent: EventTimelineItem | undefined;
  /**
   * Member who invited the current user to a room that's in the invited
   * state.
   *
   * Can be missing if the room membership invite event is missing from the
   * store.
   */
  inviter: RoomMember | undefined;
  activeMembersCount: /*u64*/ bigint;
  invitedMembersCount: /*u64*/ bigint;
  joinedMembersCount: /*u64*/ bigint;
  userPowerLevels: Map<string, /*i64*/ bigint>;
  highlightCount: /*u64*/ bigint;
  notificationCount: /*u64*/ bigint;
  userDefinedNotificationMode: RoomNotificationMode | undefined;
  hasRoomCall: boolean;
  activeRoomCallParticipants: string[];
  /**
   * Whether this room has been explicitly marked as unread
   */
  isMarkedUnread: boolean;
  /**
   * "Interesting" messages received in that room, independently of the
   * notification settings.
   */
  numUnreadMessages: /*u64*/ bigint;
  /**
   * Events that will notify the user, according to their
   * notification settings.
   */
  numUnreadNotifications: /*u64*/ bigint;
  /**
   * Events causing mentions/highlights for the user, according to their
   * notification settings.
   */
  numUnreadMentions: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RoomInfo} record objects.
 */
export const RoomInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomInfo>,
  });
})();

const FfiConverterTypeRoomInfo = (() => {
  type TypeName = RoomInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        rawName: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isDirect: FfiConverterBool.read(from),
        isPublic: FfiConverterBool.read(from),
        isSpace: FfiConverterBool.read(from),
        isTombstoned: FfiConverterBool.read(from),
        isFavourite: FfiConverterBool.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        alternativeAliases: FfiConverterArrayString.read(from),
        membership: FfiConverterTypeMembership.read(from),
        latestEvent: FfiConverterOptionalTypeEventTimelineItem.read(from),
        inviter: FfiConverterOptionalTypeRoomMember.read(from),
        activeMembersCount: FfiConverterUInt64.read(from),
        invitedMembersCount: FfiConverterUInt64.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        userPowerLevels: FfiConverterMapStringInt64.read(from),
        highlightCount: FfiConverterUInt64.read(from),
        notificationCount: FfiConverterUInt64.read(from),
        userDefinedNotificationMode:
          FfiConverterOptionalTypeRoomNotificationMode.read(from),
        hasRoomCall: FfiConverterBool.read(from),
        activeRoomCallParticipants: FfiConverterArrayString.read(from),
        isMarkedUnread: FfiConverterBool.read(from),
        numUnreadMessages: FfiConverterUInt64.read(from),
        numUnreadNotifications: FfiConverterUInt64.read(from),
        numUnreadMentions: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.rawName, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterBool.write(value.isPublic, into);
      FfiConverterBool.write(value.isSpace, into);
      FfiConverterBool.write(value.isTombstoned, into);
      FfiConverterBool.write(value.isFavourite, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterArrayString.write(value.alternativeAliases, into);
      FfiConverterTypeMembership.write(value.membership, into);
      FfiConverterOptionalTypeEventTimelineItem.write(value.latestEvent, into);
      FfiConverterOptionalTypeRoomMember.write(value.inviter, into);
      FfiConverterUInt64.write(value.activeMembersCount, into);
      FfiConverterUInt64.write(value.invitedMembersCount, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterMapStringInt64.write(value.userPowerLevels, into);
      FfiConverterUInt64.write(value.highlightCount, into);
      FfiConverterUInt64.write(value.notificationCount, into);
      FfiConverterOptionalTypeRoomNotificationMode.write(
        value.userDefinedNotificationMode,
        into
      );
      FfiConverterBool.write(value.hasRoomCall, into);
      FfiConverterArrayString.write(value.activeRoomCallParticipants, into);
      FfiConverterBool.write(value.isMarkedUnread, into);
      FfiConverterUInt64.write(value.numUnreadMessages, into);
      FfiConverterUInt64.write(value.numUnreadNotifications, into);
      FfiConverterUInt64.write(value.numUnreadMentions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.rawName) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterBool.allocationSize(value.isPublic) +
        FfiConverterBool.allocationSize(value.isSpace) +
        FfiConverterBool.allocationSize(value.isTombstoned) +
        FfiConverterBool.allocationSize(value.isFavourite) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterArrayString.allocationSize(value.alternativeAliases) +
        FfiConverterTypeMembership.allocationSize(value.membership) +
        FfiConverterOptionalTypeEventTimelineItem.allocationSize(
          value.latestEvent
        ) +
        FfiConverterOptionalTypeRoomMember.allocationSize(value.inviter) +
        FfiConverterUInt64.allocationSize(value.activeMembersCount) +
        FfiConverterUInt64.allocationSize(value.invitedMembersCount) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterMapStringInt64.allocationSize(value.userPowerLevels) +
        FfiConverterUInt64.allocationSize(value.highlightCount) +
        FfiConverterUInt64.allocationSize(value.notificationCount) +
        FfiConverterOptionalTypeRoomNotificationMode.allocationSize(
          value.userDefinedNotificationMode
        ) +
        FfiConverterBool.allocationSize(value.hasRoomCall) +
        FfiConverterArrayString.allocationSize(
          value.activeRoomCallParticipants
        ) +
        FfiConverterBool.allocationSize(value.isMarkedUnread) +
        FfiConverterUInt64.allocationSize(value.numUnreadMessages) +
        FfiConverterUInt64.allocationSize(value.numUnreadNotifications) +
        FfiConverterUInt64.allocationSize(value.numUnreadMentions)
      );
    }
  }
  return new FFIConverter();
})();

export type EventTimelineItemDebugInfo = {
  model: string;
  originalJson: string | undefined;
  latestEditJson: string | undefined;
};

/**
 * Generated factory for {@link EventTimelineItemDebugInfo} record objects.
 */
export const EventTimelineItemDebugInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        EventTimelineItemDebugInfo,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<EventTimelineItemDebugInfo>,
  });
})();

const FfiConverterTypeEventTimelineItemDebugInfo = (() => {
  type TypeName = EventTimelineItemDebugInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        model: FfiConverterString.read(from),
        originalJson: FfiConverterOptionalString.read(from),
        latestEditJson: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.model, into);
      FfiConverterOptionalString.write(value.originalJson, into);
      FfiConverterOptionalString.write(value.latestEditJson, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.model) +
        FfiConverterOptionalString.allocationSize(value.originalJson) +
        FfiConverterOptionalString.allocationSize(value.latestEditJson)
      );
    }
  }
  return new FFIConverter();
})();

export interface RoomDirectorySearchEntriesListener {
  onUpdate(roomEntriesUpdate: RoomDirectorySearchEntryUpdate[]): void;
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
const IDX_CALLBACK_FREE = 0;
// Callback return codes
const UNIFFI_CALLBACK_SUCCESS = 0;
const UNIFFI_CALLBACK_ERROR = 1;
const UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2;

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomDirectorySearchEntriesListener = (() => {
  type TypeName = RoomDirectorySearchEntriesListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type Reaction = {
  key: string;
  count: /*u64*/ bigint;
  senders: ReactionSenderData[];
};

/**
 * Generated factory for {@link Reaction} record objects.
 */
export const ReactionFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Reaction}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<Reaction, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Reaction>,
  });
})();

const FfiConverterTypeReaction = (() => {
  type TypeName = Reaction;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        count: FfiConverterUInt64.read(from),
        senders: FfiConverterArrayTypeReactionSenderData.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterUInt64.write(value.count, into);
      FfiConverterArrayTypeReactionSenderData.write(value.senders, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterUInt64.allocationSize(value.count) +
        FfiConverterArrayTypeReactionSenderData.allocationSize(value.senders)
      );
    }
  }
  return new FFIConverter();
})();

export interface BackupStateListener {
  onUpdate(status: BackupState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupStateListener = (() => {
  type TypeName = BackupStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export interface WidgetCapabilitiesProvider {
  acquireCapabilities(capabilities: WidgetCapabilities): WidgetCapabilities;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeWidgetCapabilitiesProvider = (() => {
  type TypeName = WidgetCapabilitiesProvider;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/* EXTERNAL TYPE RoomPowerLevelChanges module_path = matrix_sdk namespace = matrix_sdk */

export type PusherIdentifiers = {
  pushkey: string;
  appId: string;
};

/**
 * Generated factory for {@link PusherIdentifiers} record objects.
 */
export const PusherIdentifiersFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<PusherIdentifiers, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PusherIdentifiers>,
  });
})();

const FfiConverterTypePusherIdentifiers = (() => {
  type TypeName = PusherIdentifiers;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        pushkey: FfiConverterString.read(from),
        appId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.pushkey, into);
      FfiConverterString.write(value.appId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.pushkey) +
        FfiConverterString.allocationSize(value.appId)
      );
    }
  }
  return new FFIConverter();
})();

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      return from.read(length, arrayBufferToString);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.write(numBytes, () => stringToArrayBuffer(value));
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();
initializeWithStringLifter(FfiConverterString.lift);

export interface VerificationStateListener {
  onUpdate(status: VerificationState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeVerificationStateListener = (() => {
  type TypeName = VerificationStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/**
 * The configuration to use when authenticating with OIDC.
 */
export type OidcConfiguration = {
  /**
   * The name of the client that will be shown during OIDC authentication.
   */
  clientName: string | undefined;
  /**
   * The redirect URI that will be used when OIDC authentication is
   * successful.
   */
  redirectUri: string;
  /**
   * A URI that contains information about the client.
   */
  clientUri: string | undefined;
  /**
   * A URI that contains the client's logo.
   */
  logoUri: string | undefined;
  /**
   * A URI that contains the client's terms of service.
   */
  tosUri: string | undefined;
  /**
   * A URI that contains the client's privacy policy.
   */
  policyUri: string | undefined;
  /**
   * An array of e-mail addresses of people responsible for this client.
   */
  contacts: string[] | undefined;
  /**
   * Pre-configured registrations for use with issuers that don't support
   * dynamic client registration.
   */
  staticRegistrations: Map<string, string>;
};

/**
 * Generated factory for {@link OidcConfiguration} record objects.
 */
export const OidcConfigurationFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<OidcConfiguration, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<OidcConfiguration>,
  });
})();

const FfiConverterTypeOidcConfiguration = (() => {
  type TypeName = OidcConfiguration;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientName: FfiConverterOptionalString.read(from),
        redirectUri: FfiConverterString.read(from),
        clientUri: FfiConverterOptionalString.read(from),
        logoUri: FfiConverterOptionalString.read(from),
        tosUri: FfiConverterOptionalString.read(from),
        policyUri: FfiConverterOptionalString.read(from),
        contacts: FfiConverterOptionalArrayString.read(from),
        staticRegistrations: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.clientName, into);
      FfiConverterString.write(value.redirectUri, into);
      FfiConverterOptionalString.write(value.clientUri, into);
      FfiConverterOptionalString.write(value.logoUri, into);
      FfiConverterOptionalString.write(value.tosUri, into);
      FfiConverterOptionalString.write(value.policyUri, into);
      FfiConverterOptionalArrayString.write(value.contacts, into);
      FfiConverterMapStringString.write(value.staticRegistrations, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.clientName) +
        FfiConverterString.allocationSize(value.redirectUri) +
        FfiConverterOptionalString.allocationSize(value.clientUri) +
        FfiConverterOptionalString.allocationSize(value.logoUri) +
        FfiConverterOptionalString.allocationSize(value.tosUri) +
        FfiConverterOptionalString.allocationSize(value.policyUri) +
        FfiConverterOptionalArrayString.allocationSize(value.contacts) +
        FfiConverterMapStringString.allocationSize(value.staticRegistrations)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDescription = {
  roomId: string;
  name: string | undefined;
  topic: string | undefined;
  alias: string | undefined;
  avatarUrl: string | undefined;
  joinRule: PublicRoomJoinRule | undefined;
  isWorldReadable: boolean;
  joinedMembers: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RoomDescription} record objects.
 */
export const RoomDescriptionFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDescription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomDescription, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomDescription>,
  });
})();

const FfiConverterTypeRoomDescription = (() => {
  type TypeName = RoomDescription;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        alias: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        joinRule: FfiConverterOptionalTypePublicRoomJoinRule.read(from),
        isWorldReadable: FfiConverterBool.read(from),
        joinedMembers: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.alias, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalTypePublicRoomJoinRule.write(value.joinRule, into);
      FfiConverterBool.write(value.isWorldReadable, into);
      FfiConverterUInt64.write(value.joinedMembers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.alias) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalTypePublicRoomJoinRule.allocationSize(
          value.joinRule
        ) +
        FfiConverterBool.allocationSize(value.isWorldReadable) +
        FfiConverterUInt64.allocationSize(value.joinedMembers)
      );
    }
  }
  return new FFIConverter();
})();

export type UnstableAudioDetailsContent = {
  duration: UniffiDuration;
  waveform: /*u16*/ number[];
};

/**
 * Generated factory for {@link UnstableAudioDetailsContent} record objects.
 */
export const UnstableAudioDetailsContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        UnstableAudioDetailsContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<UnstableAudioDetailsContent>,
  });
})();

const FfiConverterTypeUnstableAudioDetailsContent = (() => {
  type TypeName = UnstableAudioDetailsContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterDuration.read(from),
        waveform: FfiConverterArrayUInt16.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterDuration.write(value.duration, into);
      FfiConverterArrayUInt16.write(value.waveform, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterDuration.allocationSize(value.duration) +
        FfiConverterArrayUInt16.allocationSize(value.waveform)
      );
    }
  }
  return new FFIConverter();
})();

export interface PaginationStatusListener {
  onUpdate(status: LiveBackPaginationStatus): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypePaginationStatusListener = (() => {
  type TypeName = PaginationStatusListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
export type RoomNotificationSettings = {
  /**
   * The room notification mode
   */
  mode: RoomNotificationMode;
  /**
   * Whether the mode is the default one
   */
  isDefault: boolean;
};

/**
 * Generated factory for {@link RoomNotificationSettings} record objects.
 */
export const RoomNotificationSettingsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomNotificationSettings,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomNotificationSettings>,
  });
})();

const FfiConverterTypeRoomNotificationSettings = (() => {
  type TypeName = RoomNotificationSettings;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mode: FfiConverterTypeRoomNotificationMode.read(from),
        isDefault: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomNotificationMode.write(value.mode, into);
      FfiConverterBool.write(value.isDefault, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomNotificationMode.allocationSize(value.mode) +
        FfiConverterBool.allocationSize(value.isDefault)
      );
    }
  }
  return new FFIConverter();
})();

/* EXTERNAL TYPE LiveBackPaginationStatus module_path = matrix_sdk_ui namespace = matrix_sdk_ui */

export type FileMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
  filename: string | undefined;
  source: MediaSource;
  info: FileInfo | undefined;
};

/**
 * Generated factory for {@link FileMessageContent} record objects.
 */
export const FileMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        FileMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileMessageContent>,
  });
})();

const FfiConverterTypeFileMessageContent = (() => {
  type TypeName = FileMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
        filename: FfiConverterOptionalString.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeFileInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
      FfiConverterOptionalString.write(value.filename, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeFileInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted) +
        FfiConverterOptionalString.allocationSize(value.filename) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeFileInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a widget.
 */
export type WidgetSettings = {
  /**
   * Widget's unique identifier.
   */
  widgetId: string;
  /**
   * Whether or not the widget should be initialized on load message
   * (`ContentLoad` message), or upon creation/attaching of the widget to
   * the SDK's state machine that drives the API.
   */
  initAfterContentLoad: boolean;
  /**
   * This contains the url from the widget state event.
   * In this url placeholders can be used to pass information from the client
   * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
   * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
   *
   * # Examples
   *
   * e.g `http://widget.domain?username=$userId`
   * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
   */
  rawUrl: string;
};

/**
 * Generated factory for {@link WidgetSettings} record objects.
 */
export const WidgetSettingsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<WidgetSettings, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetSettings>,
  });
})();

const FfiConverterTypeWidgetSettings = (() => {
  type TypeName = WidgetSettings;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        widgetId: FfiConverterString.read(from),
        initAfterContentLoad: FfiConverterBool.read(from),
        rawUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.widgetId, into);
      FfiConverterBool.write(value.initAfterContentLoad, into);
      FfiConverterString.write(value.rawUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterBool.allocationSize(value.initAfterContentLoad) +
        FfiConverterString.allocationSize(value.rawUrl)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a room, that was resolved from a room alias.
 */
export type ResolvedRoomAlias = {
  /**
   * The room ID that the alias resolved to.
   */
  roomId: string;
  /**
   * A list of servers that can be used to find the room by its room ID.
   */
  servers: string[];
};

/**
 * Generated factory for {@link ResolvedRoomAlias} record objects.
 */
export const ResolvedRoomAliasFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<ResolvedRoomAlias, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ResolvedRoomAlias>,
  });
})();

const FfiConverterTypeResolvedRoomAlias = (() => {
  type TypeName = ResolvedRoomAlias;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        servers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterArrayString.write(value.servers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterArrayString.allocationSize(value.servers)
      );
    }
  }
  return new FFIConverter();
})();

export type TracingFileConfiguration = {
  path: string;
  filePrefix: string;
  fileSuffix: string | undefined;
  maxFiles: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TracingFileConfiguration} record objects.
 */
export const TracingFileConfigurationFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        TracingFileConfiguration,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<TracingFileConfiguration>,
  });
})();

const FfiConverterTypeTracingFileConfiguration = (() => {
  type TypeName = TracingFileConfiguration;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        path: FfiConverterString.read(from),
        filePrefix: FfiConverterString.read(from),
        fileSuffix: FfiConverterOptionalString.read(from),
        maxFiles: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.path, into);
      FfiConverterString.write(value.filePrefix, into);
      FfiConverterOptionalString.write(value.fileSuffix, into);
      FfiConverterOptionalUInt64.write(value.maxFiles, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.path) +
        FfiConverterString.allocationSize(value.filePrefix) +
        FfiConverterOptionalString.allocationSize(value.fileSuffix) +
        FfiConverterOptionalUInt64.allocationSize(value.maxFiles)
      );
    }
  }
  return new FFIConverter();
})();

export type ThumbnailInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link ThumbnailInfo} record objects.
 */
export const ThumbnailInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<ThumbnailInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ThumbnailInfo>,
  });
})();

const FfiConverterTypeThumbnailInfo = (() => {
  type TypeName = ThumbnailInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The preview of a room, be it invited/joined/left, or not.
 */
export type RoomPreview = {
  /**
   * The room id for this room.
   */
  roomId: string;
  /**
   * The canonical alias for the room.
   */
  canonicalAlias: string | undefined;
  /**
   * The room's name, if set.
   */
  name: string | undefined;
  /**
   * The room's topic, if set.
   */
  topic: string | undefined;
  /**
   * The MXC URI to the room's avatar, if set.
   */
  avatarUrl: string | undefined;
  /**
   * The number of joined members.
   */
  numJoinedMembers: /*u64*/ bigint;
  /**
   * The room type (space, custom) or nothing, if it's a regular room.
   */
  roomType: string | undefined;
  /**
   * Is the history world-readable for this room?
   */
  isHistoryWorldReadable: boolean;
  /**
   * Is the room joined by the current user?
   */
  isJoined: boolean;
  /**
   * Is the current user invited to this room?
   */
  isInvited: boolean;
  /**
   * is the join rule public for this room?
   */
  isPublic: boolean;
  /**
   * Can we knock (or restricted-knock) to this room?
   */
  canKnock: boolean;
};

/**
 * Generated factory for {@link RoomPreview} record objects.
 */
export const RoomPreviewFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPreview}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomPreview, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPreview>,
  });
})();

const FfiConverterTypeRoomPreview = (() => {
  type TypeName = RoomPreview;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        numJoinedMembers: FfiConverterUInt64.read(from),
        roomType: FfiConverterOptionalString.read(from),
        isHistoryWorldReadable: FfiConverterBool.read(from),
        isJoined: FfiConverterBool.read(from),
        isInvited: FfiConverterBool.read(from),
        isPublic: FfiConverterBool.read(from),
        canKnock: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterUInt64.write(value.numJoinedMembers, into);
      FfiConverterOptionalString.write(value.roomType, into);
      FfiConverterBool.write(value.isHistoryWorldReadable, into);
      FfiConverterBool.write(value.isJoined, into);
      FfiConverterBool.write(value.isInvited, into);
      FfiConverterBool.write(value.isPublic, into);
      FfiConverterBool.write(value.canKnock, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterUInt64.allocationSize(value.numJoinedMembers) +
        FfiConverterOptionalString.allocationSize(value.roomType) +
        FfiConverterBool.allocationSize(value.isHistoryWorldReadable) +
        FfiConverterBool.allocationSize(value.isJoined) +
        FfiConverterBool.allocationSize(value.isInvited) +
        FfiConverterBool.allocationSize(value.isPublic) +
        FfiConverterBool.allocationSize(value.canKnock)
      );
    }
  }
  return new FFIConverter();
})();

export type TextMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link TextMessageContent} record objects.
 */
export const TextMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TextMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        TextMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TextMessageContent>,
  });
})();

const FfiConverterTypeTextMessageContent = (() => {
  type TypeName = TextMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomListEntriesResult = {
  entries: RoomListEntry[];
  entriesStream: TaskHandle;
};

/**
 * Generated factory for {@link RoomListEntriesResult} record objects.
 */
export const RoomListEntriesResultFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomListEntriesResult,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomListEntriesResult>,
  });
})();

const FfiConverterTypeRoomListEntriesResult = (() => {
  type TypeName = RoomListEntriesResult;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        entries: FfiConverterArrayTypeRoomListEntry.read(from),
        entriesStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeRoomListEntry.write(value.entries, into);
      FfiConverterTypeTaskHandle.write(value.entriesStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeRoomListEntry.allocationSize(value.entries) +
        FfiConverterTypeTaskHandle.allocationSize(value.entriesStream)
      );
    }
  }
  return new FFIConverter();
})();

export type SearchUsersResults = {
  results: UserProfile[];
  limited: boolean;
};

/**
 * Generated factory for {@link SearchUsersResults} record objects.
 */
export const SearchUsersResultsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        SearchUsersResults,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SearchUsersResults>,
  });
})();

const FfiConverterTypeSearchUsersResults = (() => {
  type TypeName = SearchUsersResults;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        results: FfiConverterArrayTypeUserProfile.read(from),
        limited: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeUserProfile.write(value.results, into);
      FfiConverterBool.write(value.limited, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeUserProfile.allocationSize(value.results) +
        FfiConverterBool.allocationSize(value.limited)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomListEntriesWithDynamicAdaptersResult = {
  controller: RoomListDynamicEntriesController;
  entriesStream: TaskHandle;
};

/**
 * Generated factory for {@link RoomListEntriesWithDynamicAdaptersResult} record objects.
 */
export const RoomListEntriesWithDynamicAdaptersResultFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListEntriesWithDynamicAdaptersResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomListEntriesWithDynamicAdaptersResult,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(
        defaults()
      ) as Partial<RoomListEntriesWithDynamicAdaptersResult>,
  });
})();

const FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult = (() => {
  type TypeName = RoomListEntriesWithDynamicAdaptersResult;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        controller: FfiConverterTypeRoomListDynamicEntriesController.read(from),
        entriesStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomListDynamicEntriesController.write(
        value.controller,
        into
      );
      FfiConverterTypeTaskHandle.write(value.entriesStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomListDynamicEntriesController.allocationSize(
          value.controller
        ) + FfiConverterTypeTaskHandle.allocationSize(value.entriesStream)
      );
    }
  }
  return new FFIConverter();
})();

export type PollAnswer = {
  id: string;
  text: string;
};

/**
 * Generated factory for {@link PollAnswer} record objects.
 */
export const PollAnswerFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PollAnswer}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<PollAnswer, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PollAnswer>,
  });
})();

const FfiConverterTypePollAnswer = (() => {
  type TypeName = PollAnswer;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        text: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.text, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.text)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSource | undefined;
  blurhash: string | undefined;
};

/**
 * Generated factory for {@link ImageInfo} record objects.
 */
export const ImageInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<ImageInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageInfo>,
  });
})();

const FfiConverterTypeImageInfo = (() => {
  type TypeName = ImageInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash)
      );
    }
  }
  return new FFIConverter();
})();

export type VideoMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
  filename: string | undefined;
  source: MediaSource;
  info: VideoInfo | undefined;
};

/**
 * Generated factory for {@link VideoMessageContent} record objects.
 */
export const VideoMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        VideoMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoMessageContent>,
  });
})();

const FfiConverterTypeVideoMessageContent = (() => {
  type TypeName = VideoMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
        filename: FfiConverterOptionalString.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeVideoInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
      FfiConverterOptionalString.write(value.filename, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeVideoInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted) +
        FfiConverterOptionalString.allocationSize(value.filename) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeVideoInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type CreateRoomParameters = {
  name: string | undefined;
  topic: string | undefined;
  isEncrypted: boolean;
  isDirect: boolean;
  visibility: RoomVisibility;
  preset: RoomPreset;
  invite: string[] | undefined;
  avatar: string | undefined;
  powerLevelContentOverride: PowerLevels | undefined;
};

/**
 * Generated factory for {@link CreateRoomParameters} record objects.
 */
export const CreateRoomParametersFactory = (() => {
  const defaults = () => ({
    topic: undefined,
    isDirect: false,
    invite: undefined,
    avatar: undefined,
    powerLevelContentOverride: undefined,
  });
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        CreateRoomParameters,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CreateRoomParameters>,
  });
})();

const FfiConverterTypeCreateRoomParameters = (() => {
  type TypeName = CreateRoomParameters;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        isEncrypted: FfiConverterBool.read(from),
        isDirect: FfiConverterBool.read(from),
        visibility: FfiConverterTypeRoomVisibility.read(from),
        preset: FfiConverterTypeRoomPreset.read(from),
        invite: FfiConverterOptionalArrayString.read(from),
        avatar: FfiConverterOptionalString.read(from),
        powerLevelContentOverride:
          FfiConverterOptionalTypePowerLevels.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterTypeRoomVisibility.write(value.visibility, into);
      FfiConverterTypeRoomPreset.write(value.preset, into);
      FfiConverterOptionalArrayString.write(value.invite, into);
      FfiConverterOptionalString.write(value.avatar, into);
      FfiConverterOptionalTypePowerLevels.write(
        value.powerLevelContentOverride,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterTypeRoomVisibility.allocationSize(value.visibility) +
        FfiConverterTypeRoomPreset.allocationSize(value.preset) +
        FfiConverterOptionalArrayString.allocationSize(value.invite) +
        FfiConverterOptionalString.allocationSize(value.avatar) +
        FfiConverterOptionalTypePowerLevels.allocationSize(
          value.powerLevelContentOverride
        )
      );
    }
  }
  return new FFIConverter();
})();

export interface RoomListServiceStateListener {
  onUpdate(state: RoomListServiceState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceStateListener = (() => {
  type TypeName = RoomListServiceStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export interface UnableToDecryptDelegate {
  onUtd(info: UnableToDecryptInfo): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeUnableToDecryptDelegate = (() => {
  type TypeName = UnableToDecryptDelegate;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export interface RoomInfoListener {
  call(roomInfo: RoomInfo): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomInfoListener = (() => {
  type TypeName = RoomInfoListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type InReplyToDetails = {
  eventId: string;
  event: RepliedToEventDetails;
};

/**
 * Generated factory for {@link InReplyToDetails} record objects.
 */
export const InReplyToDetailsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link InReplyToDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<InReplyToDetails, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<InReplyToDetails>,
  });
})();

const FfiConverterTypeInReplyToDetails = (() => {
  type TypeName = InReplyToDetails;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        event: FfiConverterTypeRepliedToEventDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterTypeRepliedToEventDetails.write(value.event, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterTypeRepliedToEventDetails.allocationSize(value.event)
      );
    }
  }
  return new FFIConverter();
})();

export type ReactionSenderData = {
  senderId: string;
  timestamp: /*u64*/ bigint;
};

/**
 * Generated factory for {@link ReactionSenderData} record objects.
 */
export const ReactionSenderDataFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        ReactionSenderData,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReactionSenderData>,
  });
})();

const FfiConverterTypeReactionSenderData = (() => {
  type TypeName = ReactionSenderData;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderId: FfiConverterString.read(from),
        timestamp: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.senderId, into);
      FfiConverterUInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.senderId) +
        FfiConverterUInt64.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type UnableToDecryptInfo = {
  /**
   * The identifier of the event that couldn't get decrypted.
   */
  eventId: string;
  /**
   * If the event could be decrypted late (that is, the event was encrypted
   * at first, but could be decrypted later on), then this indicates the
   * time it took to decrypt the event. If it is not set, this is
   * considered a definite UTD.
   *
   * If set, this is in milliseconds.
   */
  timeToDecryptMs: /*u64*/ bigint | undefined;
  /**
   * What we know about what caused this UTD. E.g. was this event sent when
   * we were not a member of this room?
   */
  cause: UtdCause;
};

/**
 * Generated factory for {@link UnableToDecryptInfo} record objects.
 */
export const UnableToDecryptInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        UnableToDecryptInfo,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnableToDecryptInfo>,
  });
})();

const FfiConverterTypeUnableToDecryptInfo = (() => {
  type TypeName = UnableToDecryptInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        timeToDecryptMs: FfiConverterOptionalUInt64.read(from),
        cause: FfiConverterTypeUtdCause.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterOptionalUInt64.write(value.timeToDecryptMs, into);
      FfiConverterTypeUtdCause.write(value.cause, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterOptionalUInt64.allocationSize(value.timeToDecryptMs) +
        FfiConverterTypeUtdCause.allocationSize(value.cause)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomListLoadingStateResult = {
  state: RoomListLoadingState;
  stateStream: TaskHandle;
};

/**
 * Generated factory for {@link RoomListLoadingStateResult} record objects.
 */
export const RoomListLoadingStateResultFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomListLoadingStateResult,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomListLoadingStateResult>,
  });
})();

const FfiConverterTypeRoomListLoadingStateResult = (() => {
  type TypeName = RoomListLoadingStateResult;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        state: FfiConverterTypeRoomListLoadingState.read(from),
        stateStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomListLoadingState.write(value.state, into);
      FfiConverterTypeTaskHandle.write(value.stateStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomListLoadingState.allocationSize(value.state) +
        FfiConverterTypeTaskHandle.allocationSize(value.stateStream)
      );
    }
  }
  return new FFIConverter();
})();

export interface ProgressWatcher {
  transmissionProgress(progress: TransmissionProgress): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeProgressWatcher = (() => {
  type TypeName = ProgressWatcher;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type InsertData = {
  index: /*u32*/ number;
  item: TimelineItem;
};

/**
 * Generated factory for {@link InsertData} record objects.
 */
export const InsertDataFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link InsertData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<InsertData, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<InsertData>,
  });
})();

const FfiConverterTypeInsertData = (() => {
  type TypeName = InsertData;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDirectorySearchEntriesResult = {
  entriesStream: TaskHandle;
};

/**
 * Generated factory for {@link RoomDirectorySearchEntriesResult} record objects.
 */
export const RoomDirectorySearchEntriesResultFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDirectorySearchEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomDirectorySearchEntriesResult,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomDirectorySearchEntriesResult>,
  });
})();

const FfiConverterTypeRoomDirectorySearchEntriesResult = (() => {
  type TypeName = RoomDirectorySearchEntriesResult;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        entriesStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTaskHandle.write(value.entriesStream, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeTaskHandle.allocationSize(value.entriesStream);
    }
  }
  return new FFIConverter();
})();

export type FormattedBody = {
  format: MessageFormat;
  body: string;
};

/**
 * Generated factory for {@link FormattedBody} record objects.
 */
export const FormattedBodyFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FormattedBody}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<FormattedBody, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FormattedBody>,
  });
})();

const FfiConverterTypeFormattedBody = (() => {
  type TypeName = FormattedBody;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        format: FfiConverterTypeMessageFormat.read(from),
        body: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMessageFormat.write(value.format, into);
      FfiConverterString.write(value.body, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMessageFormat.allocationSize(value.format) +
        FfiConverterString.allocationSize(value.body)
      );
    }
  }
  return new FFIConverter();
})();

export type NoticeMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link NoticeMessageContent} record objects.
 */
export const NoticeMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        NoticeMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NoticeMessageContent>,
  });
})();

const FfiConverterTypeNoticeMessageContent = (() => {
  type TypeName = NoticeMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export interface ClientSessionDelegate {
  retrieveSessionFromKeychain(userId: string) /*throws*/ : Session;
  saveSessionInKeychain(session: Session): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientSessionDelegate = (() => {
  type TypeName = ClientSessionDelegate;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type VideoInfo = {
  duration: UniffiDuration | undefined;
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSource | undefined;
  blurhash: string | undefined;
};

/**
 * Generated factory for {@link VideoInfo} record objects.
 */
export const VideoInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<VideoInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoInfo>,
  });
})();

const FfiConverterTypeVideoInfo = (() => {
  type TypeName = VideoInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash)
      );
    }
  }
  return new FFIConverter();
})();

export type RequiredState = {
  key: string;
  value: string;
};

/**
 * Generated factory for {@link RequiredState} record objects.
 */
export const RequiredStateFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RequiredState}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RequiredState, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RequiredState>,
  });
})();

const FfiConverterTypeRequiredState = (() => {
  type TypeName = RequiredState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
  filename: string | undefined;
  source: MediaSource;
  info: ImageInfo | undefined;
};

/**
 * Generated factory for {@link ImageMessageContent} record objects.
 */
export const ImageMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        ImageMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageMessageContent>,
  });
})();

const FfiConverterTypeImageMessageContent = (() => {
  type TypeName = ImageMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
        filename: FfiConverterOptionalString.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeImageInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
      FfiConverterOptionalString.write(value.filename, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeImageInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted) +
        FfiConverterOptionalString.allocationSize(value.filename) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeImageInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationSenderInfo = {
  displayName: string | undefined;
  avatarUrl: string | undefined;
  isNameAmbiguous: boolean;
};

/**
 * Generated factory for {@link NotificationSenderInfo} record objects.
 */
export const NotificationSenderInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        NotificationSenderInfo,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationSenderInfo>,
  });
})();

const FfiConverterTypeNotificationSenderInfo = (() => {
  type TypeName = NotificationSenderInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous)
      );
    }
  }
  return new FFIConverter();
})();

export type PowerLevels = {
  usersDefault: /*i32*/ number | undefined;
  eventsDefault: /*i32*/ number | undefined;
  stateDefault: /*i32*/ number | undefined;
  ban: /*i32*/ number | undefined;
  kick: /*i32*/ number | undefined;
  redact: /*i32*/ number | undefined;
  invite: /*i32*/ number | undefined;
  notifications: NotificationPowerLevels | undefined;
  users: Map<string, /*i32*/ number>;
  events: Map<string, /*i32*/ number>;
};

/**
 * Generated factory for {@link PowerLevels} record objects.
 */
export const PowerLevelsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<PowerLevels, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PowerLevels>,
  });
})();

const FfiConverterTypePowerLevels = (() => {
  type TypeName = PowerLevels;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        usersDefault: FfiConverterOptionalInt32.read(from),
        eventsDefault: FfiConverterOptionalInt32.read(from),
        stateDefault: FfiConverterOptionalInt32.read(from),
        ban: FfiConverterOptionalInt32.read(from),
        kick: FfiConverterOptionalInt32.read(from),
        redact: FfiConverterOptionalInt32.read(from),
        invite: FfiConverterOptionalInt32.read(from),
        notifications:
          FfiConverterOptionalTypeNotificationPowerLevels.read(from),
        users: FfiConverterMapStringInt32.read(from),
        events: FfiConverterMapStringInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt32.write(value.usersDefault, into);
      FfiConverterOptionalInt32.write(value.eventsDefault, into);
      FfiConverterOptionalInt32.write(value.stateDefault, into);
      FfiConverterOptionalInt32.write(value.ban, into);
      FfiConverterOptionalInt32.write(value.kick, into);
      FfiConverterOptionalInt32.write(value.redact, into);
      FfiConverterOptionalInt32.write(value.invite, into);
      FfiConverterOptionalTypeNotificationPowerLevels.write(
        value.notifications,
        into
      );
      FfiConverterMapStringInt32.write(value.users, into);
      FfiConverterMapStringInt32.write(value.events, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt32.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt32.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt32.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt32.allocationSize(value.ban) +
        FfiConverterOptionalInt32.allocationSize(value.kick) +
        FfiConverterOptionalInt32.allocationSize(value.redact) +
        FfiConverterOptionalInt32.allocationSize(value.invite) +
        FfiConverterOptionalTypeNotificationPowerLevels.allocationSize(
          value.notifications
        ) +
        FfiConverterMapStringInt32.allocationSize(value.users) +
        FfiConverterMapStringInt32.allocationSize(value.events)
      );
    }
  }
  return new FFIConverter();
})();

export interface TimelineListener {
  onUpdate(diff: TimelineDiff[]): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTimelineListener = (() => {
  type TypeName = TimelineListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type UserProfile = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
};

/**
 * Generated factory for {@link UserProfile} record objects.
 */
export const UserProfileFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserProfile}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<UserProfile, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserProfile>,
  });
})();

const FfiConverterTypeUserProfile = (() => {
  type TypeName = UserProfile;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type FileInfo = {
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSource | undefined;
};

/**
 * Generated factory for {@link FileInfo} record objects.
 */
export const FileInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<FileInfo, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileInfo>,
  });
})();

const FfiConverterTypeFileInfo = (() => {
  type TypeName = FileInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        )
      );
    }
  }
  return new FFIConverter();
})();

export interface RecoveryStateListener {
  onUpdate(status: RecoveryState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRecoveryStateListener = (() => {
  type TypeName = RecoveryStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type NotificationItem = {
  event: NotificationEvent;
  senderInfo: NotificationSenderInfo;
  roomInfo: NotificationRoomInfo;
  /**
   * Is the notification supposed to be at the "noisy" level?
   * Can be `None` if we couldn't determine this, because we lacked
   * information to create a push context.
   */
  isNoisy: boolean | undefined;
  hasMention: boolean | undefined;
};

/**
 * Generated factory for {@link NotificationItem} record objects.
 */
export const NotificationItemFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<NotificationItem, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationItem>,
  });
})();

const FfiConverterTypeNotificationItem = (() => {
  type TypeName = NotificationItem;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        event: FfiConverterTypeNotificationEvent.read(from),
        senderInfo: FfiConverterTypeNotificationSenderInfo.read(from),
        roomInfo: FfiConverterTypeNotificationRoomInfo.read(from),
        isNoisy: FfiConverterOptionalBool.read(from),
        hasMention: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeNotificationEvent.write(value.event, into);
      FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into);
      FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into);
      FfiConverterOptionalBool.write(value.isNoisy, into);
      FfiConverterOptionalBool.write(value.hasMention, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeNotificationEvent.allocationSize(value.event) +
        FfiConverterTypeNotificationSenderInfo.allocationSize(
          value.senderInfo
        ) +
        FfiConverterTypeNotificationRoomInfo.allocationSize(value.roomInfo) +
        FfiConverterOptionalBool.allocationSize(value.isNoisy) +
        FfiConverterOptionalBool.allocationSize(value.hasMention)
      );
    }
  }
  return new FFIConverter();
})();

/* EXTERNAL TYPE RoomMemberRole module_path = matrix_sdk namespace = matrix_sdk */

export type HttpPusherData = {
  url: string;
  format: PushFormat | undefined;
  defaultPayload: string | undefined;
};

/**
 * Generated factory for {@link HttpPusherData} record objects.
 */
export const HttpPusherDataFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HttpPusherData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<HttpPusherData, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HttpPusherData>,
  });
})();

const FfiConverterTypeHttpPusherData = (() => {
  type TypeName = HttpPusherData;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        format: FfiConverterOptionalTypePushFormat.read(from),
        defaultPayload: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalTypePushFormat.write(value.format, into);
      FfiConverterOptionalString.write(value.defaultPayload, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalTypePushFormat.allocationSize(value.format) +
        FfiConverterOptionalString.allocationSize(value.defaultPayload)
      );
    }
  }
  return new FFIConverter();
})();

export interface ClientDelegate {
  didReceiveAuthError(isSoftLogout: boolean): void;
  didRefreshTokens(): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientDelegate = (() => {
  type TypeName = ClientDelegate;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export interface RoomListEntriesListener {
  onUpdate(roomEntriesUpdate: RoomListEntriesUpdate[]): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListEntriesListener = (() => {
  type TypeName = RoomListEntriesListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type NotificationPowerLevels = {
  room: /*i32*/ number;
};

/**
 * Generated factory for {@link NotificationPowerLevels} record objects.
 */
export const NotificationPowerLevelsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        NotificationPowerLevels,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationPowerLevels>,
  });
})();

const FfiConverterTypeNotificationPowerLevels = (() => {
  type TypeName = NotificationPowerLevels;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        room: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterInt32.allocationSize(value.room);
    }
  }
  return new FFIConverter();
})();

export type WidgetDriverAndHandle = {
  driver: WidgetDriver;
  handle: WidgetDriverHandle;
};

/**
 * Generated factory for {@link WidgetDriverAndHandle} record objects.
 */
export const WidgetDriverAndHandleFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        WidgetDriverAndHandle,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetDriverAndHandle>,
  });
})();

const FfiConverterTypeWidgetDriverAndHandle = (() => {
  type TypeName = WidgetDriverAndHandle;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        driver: FfiConverterTypeWidgetDriver.read(from),
        handle: FfiConverterTypeWidgetDriverHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWidgetDriver.write(value.driver, into);
      FfiConverterTypeWidgetDriverHandle.write(value.handle, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeWidgetDriver.allocationSize(value.driver) +
        FfiConverterTypeWidgetDriverHandle.allocationSize(value.handle)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Properties to create a new virtual Element Call widget.
 */
export type VirtualElementCallWidgetOptions = {
  /**
   * The url to the app.
   *
   * E.g. <https://call.element.io>, <https://call.element.dev>
   */
  elementCallUrl: string;
  /**
   * The widget id.
   */
  widgetId: string;
  /**
   * The url that is used as the target for the PostMessages sent
   * by the widget (to the client).
   *
   * For a web app client this is the client url. In case of using other
   * platforms the client most likely is setup up to listen to
   * postmessages in the same webview the widget is hosted. In this case
   * the `parent_url` is set to the url of the webview with the widget. Be
   * aware that this means that the widget will receive its own postmessage
   * messages. The `matrix-widget-api` (js) ignores those so this works but
   * it might break custom implementations.
   *
   * Defaults to `element_call_url` for the non-iframe (dedicated webview)
   * usecase.
   */
  parentUrl: string | undefined;
  /**
   * Whether the branding header of Element call should be hidden.
   *
   * Default: `true`
   */
  hideHeader: boolean | undefined;
  /**
   * If set, the lobby will be skipped and the widget will join the
   * call on the `io.element.join` action.
   *
   * Default: `false`
   */
  preload: boolean | undefined;
  /**
   * The font scale which will be used inside element call.
   *
   * Default: `1`
   */
  fontScale: /*f64*/ number | undefined;
  /**
   * Whether element call should prompt the user to open in the browser or
   * the app.
   *
   * Default: `false`
   */
  appPrompt: boolean | undefined;
  /**
   * Don't show the lobby and join the call immediately.
   *
   * Default: `false`
   */
  skipLobby: boolean | undefined;
  /**
   * Make it not possible to get to the calls list in the webview.
   *
   * Default: `true`
   */
  confineToRoom: boolean | undefined;
  /**
   * The font to use, to adapt to the system font.
   */
  font: string | undefined;
  /**
   * Can be used to pass a PostHog id to element call.
   */
  analyticsId: string | undefined;
  /**
   * The encryption system to use.
   *
   * Use `EncryptionSystem::Unencrypted` to disable encryption.
   */
  encryption: EncryptionSystem;
};

/**
 * Generated factory for {@link VirtualElementCallWidgetOptions} record objects.
 */
export const VirtualElementCallWidgetOptionsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        VirtualElementCallWidgetOptions,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VirtualElementCallWidgetOptions>,
  });
})();

const FfiConverterTypeVirtualElementCallWidgetOptions = (() => {
  type TypeName = VirtualElementCallWidgetOptions;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        elementCallUrl: FfiConverterString.read(from),
        widgetId: FfiConverterString.read(from),
        parentUrl: FfiConverterOptionalString.read(from),
        hideHeader: FfiConverterOptionalBool.read(from),
        preload: FfiConverterOptionalBool.read(from),
        fontScale: FfiConverterOptionalFloat64.read(from),
        appPrompt: FfiConverterOptionalBool.read(from),
        skipLobby: FfiConverterOptionalBool.read(from),
        confineToRoom: FfiConverterOptionalBool.read(from),
        font: FfiConverterOptionalString.read(from),
        analyticsId: FfiConverterOptionalString.read(from),
        encryption: FfiConverterTypeEncryptionSystem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.elementCallUrl, into);
      FfiConverterString.write(value.widgetId, into);
      FfiConverterOptionalString.write(value.parentUrl, into);
      FfiConverterOptionalBool.write(value.hideHeader, into);
      FfiConverterOptionalBool.write(value.preload, into);
      FfiConverterOptionalFloat64.write(value.fontScale, into);
      FfiConverterOptionalBool.write(value.appPrompt, into);
      FfiConverterOptionalBool.write(value.skipLobby, into);
      FfiConverterOptionalBool.write(value.confineToRoom, into);
      FfiConverterOptionalString.write(value.font, into);
      FfiConverterOptionalString.write(value.analyticsId, into);
      FfiConverterTypeEncryptionSystem.write(value.encryption, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.elementCallUrl) +
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterOptionalString.allocationSize(value.parentUrl) +
        FfiConverterOptionalBool.allocationSize(value.hideHeader) +
        FfiConverterOptionalBool.allocationSize(value.preload) +
        FfiConverterOptionalFloat64.allocationSize(value.fontScale) +
        FfiConverterOptionalBool.allocationSize(value.appPrompt) +
        FfiConverterOptionalBool.allocationSize(value.skipLobby) +
        FfiConverterOptionalBool.allocationSize(value.confineToRoom) +
        FfiConverterOptionalString.allocationSize(value.font) +
        FfiConverterOptionalString.allocationSize(value.analyticsId) +
        FfiConverterTypeEncryptionSystem.allocationSize(value.encryption)
      );
    }
  }
  return new FFIConverter();
})();

export type Receipt = {
  timestamp: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link Receipt} record objects.
 */
export const ReceiptFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Receipt}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<Receipt, ReturnType<typeof defaults>>(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Receipt>,
  });
})();

const FfiConverterTypeReceipt = (() => {
  type TypeName = Receipt;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        timestamp: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalUInt64.allocationSize(value.timestamp);
    }
  }
  return new FFIConverter();
})();

export type RoomListRange = {
  start: /*u32*/ number;
  endInclusive: /*u32*/ number;
};

/**
 * Generated factory for {@link RoomListRange} record objects.
 */
export const RoomListRangeFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListRange}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomListRange, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomListRange>,
  });
})();

const FfiConverterTypeRoomListRange = (() => {
  type TypeName = RoomListRange;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        start: FfiConverterUInt32.read(from),
        endInclusive: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.start, into);
      FfiConverterUInt32.write(value.endInclusive, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.start) +
        FfiConverterUInt32.allocationSize(value.endInclusive)
      );
    }
  }
  return new FFIConverter();
})();

export type Mentions = {
  userIds: string[];
  room: boolean;
};

/**
 * Generated factory for {@link Mentions} record objects.
 */
export const MentionsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Mentions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<Mentions, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Mentions>,
  });
})();

const FfiConverterTypeMentions = (() => {
  type TypeName = Mentions;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userIds: FfiConverterArrayString.read(from),
        room: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.userIds, into);
      FfiConverterBool.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.userIds) +
        FfiConverterBool.allocationSize(value.room)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Capabilities that a widget can request from a client.
 */
export type WidgetCapabilities = {
  /**
   * Types of the messages that a widget wants to be able to fetch.
   */
  read: WidgetEventFilter[];
  /**
   * Types of the messages that a widget wants to be able to send.
   */
  send: WidgetEventFilter[];
  /**
   * If this capability is requested by the widget, it can not operate
   * separately from the matrix client.
   *
   * This means clients should not offer to open the widget in a separate
   * browser/tab/webview that is not connected to the postmessage widget-api.
   */
  requiresClient: boolean;
};

/**
 * Generated factory for {@link WidgetCapabilities} record objects.
 */
export const WidgetCapabilitiesFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        WidgetCapabilities,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetCapabilities>,
  });
})();

const FfiConverterTypeWidgetCapabilities = (() => {
  type TypeName = WidgetCapabilities;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        read: FfiConverterArrayTypeWidgetEventFilter.read(from),
        send: FfiConverterArrayTypeWidgetEventFilter.read(from),
        requiresClient: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeWidgetEventFilter.write(value.read, into);
      FfiConverterArrayTypeWidgetEventFilter.write(value.send, into);
      FfiConverterBool.write(value.requiresClient, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.read) +
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.send) +
        FfiConverterBool.allocationSize(value.requiresClient)
      );
    }
  }
  return new FFIConverter();
})();

/* EXTERNAL TYPE BackupDownloadStrategy module_path = matrix_sdk namespace = matrix_sdk */

export type EmoteMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link EmoteMessageContent} record objects.
 */
export const EmoteMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        EmoteMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmoteMessageContent>,
  });
})();

const FfiConverterTypeEmoteMessageContent = (() => {
  type TypeName = EmoteMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export interface IgnoredUsersListener {
  call(ignoredUserIds: string[]): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeIgnoredUsersListener = (() => {
  type TypeName = IgnoredUsersListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type UnstableVoiceContent = {};

/**
 * Generated factory for {@link UnstableVoiceContent} record objects.
 */
export const UnstableVoiceContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        UnstableVoiceContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnstableVoiceContent>,
  });
})();

const FfiConverterTypeUnstableVoiceContent = (() => {
  type TypeName = UnstableVoiceContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export interface SessionVerificationControllerDelegate {
  didAcceptVerificationRequest(): void;
  didStartSasVerification(): void;
  didReceiveVerificationData(data: SessionVerificationData): void;
  didFail(): void;
  didCancel(): void;
  didFinish(): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSessionVerificationControllerDelegate = (() => {
  type TypeName = SessionVerificationControllerDelegate;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type NotificationRoomInfo = {
  displayName: string;
  avatarUrl: string | undefined;
  canonicalAlias: string | undefined;
  joinedMembersCount: /*u64*/ bigint;
  isEncrypted: boolean | undefined;
  isDirect: boolean;
};

/**
 * Generated factory for {@link NotificationRoomInfo} record objects.
 */
export const NotificationRoomInfoFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        NotificationRoomInfo,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationRoomInfo>,
  });
})();

const FfiConverterTypeNotificationRoomInfo = (() => {
  type TypeName = NotificationRoomInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        isEncrypted: FfiConverterOptionalBool.read(from),
        isDirect: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterOptionalBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterOptionalBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect)
      );
    }
  }
  return new FFIConverter();
})();

export interface BackupSteadyStateListener {
  onUpdate(status: BackupUploadState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupSteadyStateListener = (() => {
  type TypeName = BackupSteadyStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/**
 * Delegate to notify of changes in push rules
 */
export interface NotificationSettingsDelegate {
  settingsDidChange(): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeNotificationSettingsDelegate = (() => {
  type TypeName = NotificationSettingsDelegate;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type LocationContent = {
  body: string;
  geoUri: string;
  description: string | undefined;
  zoomLevel: /*u8*/ number | undefined;
  asset: AssetType | undefined;
};

/**
 * Generated factory for {@link LocationContent} record objects.
 */
export const LocationContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocationContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<LocationContent, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocationContent>,
  });
})();

const FfiConverterTypeLocationContent = (() => {
  type TypeName = LocationContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        geoUri: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        zoomLevel: FfiConverterOptionalUInt8.read(from),
        asset: FfiConverterOptionalTypeAssetType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterString.write(value.geoUri, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalUInt8.write(value.zoomLevel, into);
      FfiConverterOptionalTypeAssetType.write(value.asset, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterString.allocationSize(value.geoUri) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalUInt8.allocationSize(value.zoomLevel) +
        FfiConverterOptionalTypeAssetType.allocationSize(value.asset)
      );
    }
  }
  return new FFIConverter();
})();

export type SetData = {
  index: /*u32*/ number;
  item: TimelineItem;
};

/**
 * Generated factory for {@link SetData} record objects.
 */
export const SetDataFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SetData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<SetData, ReturnType<typeof defaults>>(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SetData>,
  });
})();

const FfiConverterTypeSetData = (() => {
  type TypeName = SetData;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

export interface SyncServiceStateObserver {
  onUpdate(state: SyncServiceState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSyncServiceStateObserver = (() => {
  type TypeName = SyncServiceStateObserver;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type RoomSubscription = {
  requiredState: RequiredState[] | undefined;
  timelineLimit: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link RoomSubscription} record objects.
 */
export const RoomSubscriptionFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomSubscription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomSubscription, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomSubscription>,
  });
})();

const FfiConverterTypeRoomSubscription = (() => {
  type TypeName = RoomSubscription;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        requiredState: FfiConverterOptionalArrayTypeRequiredState.read(from),
        timelineLimit: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypeRequiredState.write(
        value.requiredState,
        into
      );
      FfiConverterOptionalUInt32.write(value.timelineLimit, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypeRequiredState.allocationSize(
          value.requiredState
        ) + FfiConverterOptionalUInt32.allocationSize(value.timelineLimit)
      );
    }
  }
  return new FFIConverter();
})();

export interface RoomListServiceSyncIndicatorListener {
  onUpdate(syncIndicator: RoomListServiceSyncIndicator): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceSyncIndicatorListener = (() => {
  type TypeName = RoomListServiceSyncIndicatorListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export interface RoomListLoadingStateListener {
  onUpdate(state: RoomListLoadingState): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListLoadingStateListener = (() => {
  type TypeName = RoomListLoadingStateListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

export type Session = {
  /**
   * The access token used for this session.
   */
  accessToken: string;
  /**
   * The token used for [refreshing the access token], if any.
   *
   * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
   */
  refreshToken: string | undefined;
  /**
   * The user the access token was issued for.
   */
  userId: string;
  /**
   * The ID of the client device.
   */
  deviceId: string;
  /**
   * The URL for the homeserver used for this session.
   */
  homeserverUrl: string;
  /**
   * Additional data for this session if OpenID Connect was used for
   * authentication.
   */
  oidcData: string | undefined;
  /**
   * The URL for the sliding sync proxy used for this session.
   */
  slidingSyncProxy: string | undefined;
};

/**
 * Generated factory for {@link Session} record objects.
 */
export const SessionFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Session}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<Session, ReturnType<typeof defaults>>(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Session>,
  });
})();

const FfiConverterTypeSession = (() => {
  type TypeName = Session;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        accessToken: FfiConverterString.read(from),
        refreshToken: FfiConverterOptionalString.read(from),
        userId: FfiConverterString.read(from),
        deviceId: FfiConverterString.read(from),
        homeserverUrl: FfiConverterString.read(from),
        oidcData: FfiConverterOptionalString.read(from),
        slidingSyncProxy: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.accessToken, into);
      FfiConverterOptionalString.write(value.refreshToken, into);
      FfiConverterString.write(value.userId, into);
      FfiConverterString.write(value.deviceId, into);
      FfiConverterString.write(value.homeserverUrl, into);
      FfiConverterOptionalString.write(value.oidcData, into);
      FfiConverterOptionalString.write(value.slidingSyncProxy, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.accessToken) +
        FfiConverterOptionalString.allocationSize(value.refreshToken) +
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterString.allocationSize(value.deviceId) +
        FfiConverterString.allocationSize(value.homeserverUrl) +
        FfiConverterOptionalString.allocationSize(value.oidcData) +
        FfiConverterOptionalString.allocationSize(value.slidingSyncProxy)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomPowerLevels = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint;
};

/**
 * Generated factory for {@link RoomPowerLevels} record objects.
 */
export const RoomPowerLevelsFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomPowerLevels, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevels>,
  });
})();

const FfiConverterTypeRoomPowerLevels = (() => {
  type TypeName = RoomPowerLevels;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterInt64.read(from),
        invite: FfiConverterInt64.read(from),
        kick: FfiConverterInt64.read(from),
        redact: FfiConverterInt64.read(from),
        eventsDefault: FfiConverterInt64.read(from),
        stateDefault: FfiConverterInt64.read(from),
        usersDefault: FfiConverterInt64.read(from),
        roomName: FfiConverterInt64.read(from),
        roomAvatar: FfiConverterInt64.read(from),
        roomTopic: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt64.write(value.ban, into);
      FfiConverterInt64.write(value.invite, into);
      FfiConverterInt64.write(value.kick, into);
      FfiConverterInt64.write(value.redact, into);
      FfiConverterInt64.write(value.eventsDefault, into);
      FfiConverterInt64.write(value.stateDefault, into);
      FfiConverterInt64.write(value.usersDefault, into);
      FfiConverterInt64.write(value.roomName, into);
      FfiConverterInt64.write(value.roomAvatar, into);
      FfiConverterInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt64.allocationSize(value.ban) +
        FfiConverterInt64.allocationSize(value.invite) +
        FfiConverterInt64.allocationSize(value.kick) +
        FfiConverterInt64.allocationSize(value.redact) +
        FfiConverterInt64.allocationSize(value.eventsDefault) +
        FfiConverterInt64.allocationSize(value.stateDefault) +
        FfiConverterInt64.allocationSize(value.usersDefault) +
        FfiConverterInt64.allocationSize(value.roomName) +
        FfiConverterInt64.allocationSize(value.roomAvatar) +
        FfiConverterInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

export type TracingConfiguration = {
  filter: string;
  /**
   * Controls whether to print to stdout or, equivalent, the system logs on
   * Android.
   */
  writeToStdoutOrSystem: boolean;
  writeToFiles: TracingFileConfiguration | undefined;
};

/**
 * Generated factory for {@link TracingConfiguration} record objects.
 */
export const TracingConfigurationFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        TracingConfiguration,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TracingConfiguration>,
  });
})();

const FfiConverterTypeTracingConfiguration = (() => {
  type TypeName = TracingConfiguration;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filter: FfiConverterString.read(from),
        writeToStdoutOrSystem: FfiConverterBool.read(from),
        writeToFiles:
          FfiConverterOptionalTypeTracingFileConfiguration.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filter, into);
      FfiConverterBool.write(value.writeToStdoutOrSystem, into);
      FfiConverterOptionalTypeTracingFileConfiguration.write(
        value.writeToFiles,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filter) +
        FfiConverterBool.allocationSize(value.writeToStdoutOrSystem) +
        FfiConverterOptionalTypeTracingFileConfiguration.allocationSize(
          value.writeToFiles
        )
      );
    }
  }
  return new FFIConverter();
})();

export type TransmissionProgress = {
  current: /*u64*/ bigint;
  total: /*u64*/ bigint;
};

/**
 * Generated factory for {@link TransmissionProgress} record objects.
 */
export const TransmissionProgressFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        TransmissionProgress,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TransmissionProgress>,
  });
})();

const FfiConverterTypeTransmissionProgress = (() => {
  type TypeName = TransmissionProgress;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        current: FfiConverterUInt64.read(from),
        total: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.current, into);
      FfiConverterUInt64.write(value.total, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.current) +
        FfiConverterUInt64.allocationSize(value.total)
      );
    }
  }
  return new FFIConverter();
})();

export interface TypingNotificationsListener {
  call(typingUserIds: string[]): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTypingNotificationsListener = (() => {
  type TypeName = TypingNotificationsListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/* EXTERNAL TYPE EventItemOrigin module_path = matrix_sdk_ui namespace = matrix_sdk_ui */

/* EXTERNAL TYPE UtdCause module_path = matrix_sdk_crypto namespace = matrix_sdk_crypto */

export type RoomMember = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
  membership: MembershipState;
  isNameAmbiguous: boolean;
  powerLevel: /*i64*/ bigint;
  normalizedPowerLevel: /*i64*/ bigint;
  isIgnored: boolean;
  suggestedRoleForPowerLevel: RoomMemberRole;
};

/**
 * Generated factory for {@link RoomMember} record objects.
 */
export const RoomMemberFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomMember}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<RoomMember, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomMember>,
  });
})();

const FfiConverterTypeRoomMember = (() => {
  type TypeName = RoomMember;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        membership: FfiConverterTypeMembershipState.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
        powerLevel: FfiConverterInt64.read(from),
        normalizedPowerLevel: FfiConverterInt64.read(from),
        isIgnored: FfiConverterBool.read(from),
        suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterTypeMembershipState.write(value.membership, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
      FfiConverterInt64.write(value.powerLevel, into);
      FfiConverterInt64.write(value.normalizedPowerLevel, into);
      FfiConverterBool.write(value.isIgnored, into);
      FfiConverterTypeRoomMemberRole.write(
        value.suggestedRoleForPowerLevel,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterTypeMembershipState.allocationSize(value.membership) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous) +
        FfiConverterInt64.allocationSize(value.powerLevel) +
        FfiConverterInt64.allocationSize(value.normalizedPowerLevel) +
        FfiConverterBool.allocationSize(value.isIgnored) +
        FfiConverterTypeRoomMemberRole.allocationSize(
          value.suggestedRoleForPowerLevel
        )
      );
    }
  }
  return new FFIConverter();
})();

export interface EnableRecoveryProgressListener {
  onUpdate(status: EnableRecoveryProgress): void;
}

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEnableRecoveryProgressListener = (() => {
  type TypeName = EnableRecoveryProgressListener;
  const handleConverter = FfiConverterUInt64;
  const handleMap = new UniffiHandleMap<TypeName>();
  class FFIConverter implements FfiConverter<UniffiHandle, TypeName> {
    lift(value: UniffiHandle): TypeName {
      return handleMap.get(value);
    }
    lower(value: TypeName): UniffiHandle {
      return handleMap.insert(value);
    }
    read(from: RustBuffer): TypeName {
      return this.lift(handleConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      handleConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return handleConverter.allocationSize(BigInt('0'));
    }
  }
  return new FFIConverter();
})();

/**
 * An update for a particular user's power level within the room.
 */
export type UserPowerLevelUpdate = {
  /**
   * The user ID of the user to update.
   */
  userId: string;
  /**
   * The power level to assign to the user.
   */
  powerLevel: /*i64*/ bigint;
};

/**
 * Generated factory for {@link UserPowerLevelUpdate} record objects.
 */
export const UserPowerLevelUpdateFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        UserPowerLevelUpdate,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserPowerLevelUpdate>,
  });
})();

const FfiConverterTypeUserPowerLevelUpdate = (() => {
  type TypeName = UserPowerLevelUpdate;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        powerLevel: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterInt64.write(value.powerLevel, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterInt64.allocationSize(value.powerLevel)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomTimelineListenerResult = {
  items: TimelineItem[];
  itemsStream: TaskHandle;
};

/**
 * Generated factory for {@link RoomTimelineListenerResult} record objects.
 */
export const RoomTimelineListenerResultFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomTimelineListenerResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomTimelineListenerResult,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomTimelineListenerResult>,
  });
})();

const FfiConverterTypeRoomTimelineListenerResult = (() => {
  type TypeName = RoomTimelineListenerResult;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        items: FfiConverterArrayTypeTimelineItem.read(from),
        itemsStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeTimelineItem.write(value.items, into);
      FfiConverterTypeTaskHandle.write(value.itemsStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeTimelineItem.allocationSize(value.items) +
        FfiConverterTypeTaskHandle.allocationSize(value.itemsStream)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
export type MatrixEntity = {
  id: MatrixId;
  via: string[];
};

/**
 * Generated factory for {@link MatrixEntity} record objects.
 */
export const MatrixEntityFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MatrixEntity}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<MatrixEntity, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MatrixEntity>,
  });
})();

const FfiConverterTypeMatrixEntity = (() => {
  type TypeName = MatrixEntity;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeMatrixId.read(from),
        via: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMatrixId.write(value.id, into);
      FfiConverterArrayString.write(value.via, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMatrixId.allocationSize(value.id) +
        FfiConverterArrayString.allocationSize(value.via)
      );
    }
  }
  return new FFIConverter();
})();

export type AudioMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
  filename: string | undefined;
  source: MediaSource;
  info: AudioInfo | undefined;
  audio: UnstableAudioDetailsContent | undefined;
  voice: UnstableVoiceContent | undefined;
};

/**
 * Generated factory for {@link AudioMessageContent} record objects.
 */
export const AudioMessageContentFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        AudioMessageContent,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioMessageContent>,
  });
})();

const FfiConverterTypeAudioMessageContent = (() => {
  type TypeName = AudioMessageContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
        filename: FfiConverterOptionalString.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeAudioInfo.read(from),
        audio: FfiConverterOptionalTypeUnstableAudioDetailsContent.read(from),
        voice: FfiConverterOptionalTypeUnstableVoiceContent.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
      FfiConverterOptionalString.write(value.filename, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeAudioInfo.write(value.info, into);
      FfiConverterOptionalTypeUnstableAudioDetailsContent.write(
        value.audio,
        into
      );
      FfiConverterOptionalTypeUnstableVoiceContent.write(value.voice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted) +
        FfiConverterOptionalString.allocationSize(value.filename) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeAudioInfo.allocationSize(value.info) +
        FfiConverterOptionalTypeUnstableAudioDetailsContent.allocationSize(
          value.audio
        ) +
        FfiConverterOptionalTypeUnstableVoiceContent.allocationSize(value.voice)
      );
    }
  }
  return new FFIConverter();
})();

export type ClientProperties = {
  /**
   * The client_id provides the widget with the option to behave differently
   * for different clients. e.g org.example.ios.
   */
  clientId: string;
  /**
   * The language tag the client is set to e.g. en-us. (Undefined and invalid
   * becomes: `en-US`)
   */
  languageTag: string | undefined;
  /**
   * A string describing the theme (dark, light) or org.example.dark.
   * (default: `light`)
   */
  theme: string | undefined;
};

/**
 * Generated factory for {@link ClientProperties} record objects.
 */
export const ClientPropertiesFactory = (() => {
  const defaults = () => ({});
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClientProperties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create: (() => {
      return uniffiCreateRecord<ClientProperties, ReturnType<typeof defaults>>(
        defaults
      );
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClientProperties>,
  });
})();

const FfiConverterTypeClientProperties = (() => {
  type TypeName = ClientProperties;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientId: FfiConverterString.read(from),
        languageTag: FfiConverterOptionalString.read(from),
        theme: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.clientId, into);
      FfiConverterOptionalString.write(value.languageTag, into);
      FfiConverterOptionalString.write(value.theme, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.clientId) +
        FfiConverterOptionalString.allocationSize(value.languageTag) +
        FfiConverterOptionalString.allocationSize(value.theme)
      );
    }
  }
  return new FFIConverter();
})();

// FfiConverter for NotificationPowerLevels | undefined
const FfiConverterOptionalTypeNotificationPowerLevels =
  new FfiConverterOptional(FfiConverterTypeNotificationPowerLevels);

export enum Membership {
  INVITED,
  JOINED,
  LEFT,
}

const FfiConverterTypeMembership = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Membership;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Membership.INVITED;
        case 2:
          return Membership.JOINED;
        case 3:
          return Membership.LEFT;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Membership.INVITED:
          return ordinalConverter.write(1, into);
        case Membership.JOINED:
          return ordinalConverter.write(2, into);
        case Membership.LEFT:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for EventItemOrigin | undefined
const FfiConverterOptionalTypeEventItemOrigin = new FfiConverterOptional(
  FfiConverterTypeEventItemOrigin
);

// FfiConverter for BackupSteadyStateListener | undefined
const FfiConverterOptionalTypeBackupSteadyStateListener =
  new FfiConverterOptional(FfiConverterTypeBackupSteadyStateListener);

export interface RoomInterface {
  activeMembersCount(): /*u64*/ bigint;
  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * matrix_rtc memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  activeRoomCallParticipants(): string[];
  alternativeAliases(): string[];
  applyPowerLevelChanges(
    changes: RoomPowerLevelChanges
  ) /*throws*/ : Promise<void>;
  avatarUrl(): string | undefined;
  banUser(
    userId: string,
    reason: string | undefined
  ) /*throws*/ : Promise<void>;
  canUserBan(userId: string) /*throws*/ : Promise<boolean>;
  canUserInvite(userId: string) /*throws*/ : Promise<boolean>;
  canUserKick(userId: string) /*throws*/ : Promise<boolean>;
  canUserRedactOther(userId: string) /*throws*/ : Promise<boolean>;
  canUserRedactOwn(userId: string) /*throws*/ : Promise<boolean>;
  canUserSendMessage(
    userId: string,
    message: MessageLikeEventType
  ) /*throws*/ : Promise<boolean>;
  canUserSendState(
    userId: string,
    stateEvent: StateEventType
  ) /*throws*/ : Promise<boolean>;
  canUserTriggerRoomNotification(userId: string) /*throws*/ : Promise<boolean>;
  canonicalAlias(): string | undefined;
  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  discardRoomKey() /*throws*/ : Promise<void>;
  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  displayName() /*throws*/ : string;
  getPowerLevels() /*throws*/ : Promise<RoomPowerLevels>;
  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  hasActiveRoomCall(): boolean;
  id(): string;
  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  ignoreUser(userId: string) /*throws*/ : Promise<void>;
  inviteUserById(userId: string) /*throws*/ : Promise<void>;
  invitedMembersCount(): /*u64*/ bigint;
  /**
   * For rooms one is invited to, retrieves the room member information for
   * the user who invited the logged-in user to a room.
   */
  inviter(): Promise<RoomMember | undefined>;
  isDirect(): boolean;
  isEncrypted() /*throws*/ : boolean;
  isPublic(): boolean;
  isSpace(): boolean;
  isTombstoned(): boolean;
  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  join() /*throws*/ : Promise<void>;
  joinedMembersCount(): /*u64*/ bigint;
  kickUser(
    userId: string,
    reason: string | undefined
  ) /*throws*/ : Promise<void>;
  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  leave() /*throws*/ : Promise<void>;
  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if needs be.
   */
  markAsRead(receiptType: ReceiptType) /*throws*/ : Promise<void>;
  matrixToEventPermalink(eventId: string) /*throws*/ : Promise<string>;
  matrixToPermalink() /*throws*/ : Promise<string>;
  member(userId: string) /*throws*/ : Promise<RoomMember>;
  memberAvatarUrl(userId: string) /*throws*/ : Promise<string | undefined>;
  memberDisplayName(userId: string) /*throws*/ : Promise<string | undefined>;
  members() /*throws*/ : Promise<RoomMembersIterator>;
  membersNoSync() /*throws*/ : Promise<RoomMembersIterator>;
  membership(): Membership;
  ownUserId(): string;
  /**
   * The raw name as present in the room state event.
   */
  rawName(): string | undefined;
  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional).
   * its transaction ID (optional). If not given one is created.
   */
  redact(
    eventId: string,
    reason: string | undefined
  ) /*throws*/ : Promise<void>;
  /**
   * Removes the current room avatar
   */
  removeAvatar() /*throws*/ : Promise<void>;
  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined
  ) /*throws*/ : Promise<void>;
  resetPowerLevels() /*throws*/ : Promise<RoomPowerLevels>;
  roomInfo() /*throws*/ : Promise<RoomInfo>;
  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions
  ) /*throws*/ : Promise<void>;
  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   */
  sendCallNotificationIfNeeded() /*throws*/ : Promise<void>;
  setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined
  ) /*throws*/ : Promise<void>;
  setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a new name to the room.
   */
  setName(name: string) /*throws*/ : Promise<void>;
  /**
   * Sets a new topic in the room.
   */
  setTopic(topic: string) /*throws*/ : Promise<void>;
  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  setUnreadFlag(newValue: boolean) /*throws*/ : Promise<void>;
  subscribeToRoomInfoUpdates(listener: RoomInfoListener): TaskHandle;
  subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandle;
  suggestedRoleForUser(userId: string) /*throws*/ : Promise<RoomMemberRole>;
  timeline() /*throws*/ : Promise<Timeline>;
  /**
   * Returns a timeline focused on the given event.
   *
   * Note: this timeline is independent from that returned with
   * [`Self::timeline`], and as such it is not cached.
   */
  timelineFocusedOnEvent(
    eventId: string,
    numContextEvents: /*u16*/ number,
    internalIdPrefix: string | undefined
  ) /*throws*/ : Promise<Timeline>;
  topic(): string | undefined;
  typingNotice(isTyping: boolean) /*throws*/ : Promise<void>;
  unbanUser(
    userId: string,
    reason: string | undefined
  ) /*throws*/ : Promise<void>;
  updatePowerLevelsForUsers(
    updates: UserPowerLevelUpdate[]
  ) /*throws*/ : Promise<void>;
  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined
  ) /*throws*/ : Promise<void>;
}

export class Room implements RoomInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public activeMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * matrix_rtc memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  public activeRoomCallParticipants(): string[] {
    return FfiConverterArrayString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public alternativeAliases(): string[] {
    return FfiConverterArrayString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async applyPowerLevelChanges(
    changes: RoomPowerLevelChanges
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomPowerLevelChanges.lower(changes)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public avatarUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async banUser(
    userId: string,
    reason: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          FfiConverterOptionalString.lower(reason)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserBan(userId: string): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserInvite(userId: string): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserKick(userId: string): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserRedactOther(userId: string): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserRedactOwn(userId: string): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserSendMessage(
    userId: string,
    message: MessageLikeEventType
  ): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          FfiConverterTypeMessageLikeEventType.lower(message)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserSendState(
    userId: string,
    stateEvent: StateEventType
  ): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          FfiConverterTypeStateEventType.lower(stateEvent)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async canUserTriggerRoomNotification(
    userId: string
  ): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public canonicalAlias(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  public async discardRoomKey(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  public displayName(): string /*throws*/ {
    return FfiConverterString.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_display_name(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async getPowerLevels(): Promise<RoomPowerLevels> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomPowerLevels.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  public hasActiveRoomCall(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public id(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  public async ignoreUser(userId: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async inviteUserById(userId: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public invitedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * For rooms one is invited to, retrieves the room member information for
   * the user who invited the logged-in user to a room.
   */
  public async inviter(): Promise<RoomMember | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_inviter(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalTypeRoomMember.lift,
      errorHandler: undefined,
    });
  }

  public isDirect(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isEncrypted(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isPublic(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_is_public(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isSpace(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_is_space(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isTombstoned(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  public async join(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_join(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public joinedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async kickUser(
    userId: string,
    reason: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          FfiConverterOptionalString.lower(reason)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  public async leave(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_leave(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if needs be.
   */
  public async markAsRead(receiptType: ReceiptType): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
          this.uniffiClonePointer(),
          FfiConverterTypeReceiptType.lower(receiptType)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async matrixToEventPermalink(
    eventId: string
  ): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async matrixToPermalink(): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async member(userId: string): Promise<RoomMember> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_member(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomMember.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async memberAvatarUrl(
    userId: string
  ): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async memberDisplayName(
    userId: string
  ): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async members(): Promise<RoomMembersIterator> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_members(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomMembersIterator.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async membersNoSync(): Promise<RoomMembersIterator> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomMembersIterator.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public membership(): Membership {
    return FfiConverterTypeMembership.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_membership(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public ownUserId(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * The raw name as present in the room state event.
   */
  public rawName(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional).
   * its transaction ID (optional). If not given one is created.
   */
  public async redact(
    eventId: string,
    reason: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_redact(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId),
          FfiConverterOptionalString.lower(reason)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Removes the current room avatar
   */
  public async removeAvatar(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  public async reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_report_content(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId),
          FfiConverterOptionalInt32.lower(score),
          FfiConverterOptionalString.lower(reason)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async resetPowerLevels(): Promise<RoomPowerLevels> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomPowerLevels.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async roomInfo(): Promise<RoomInfo> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_room_info(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomInfo.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  public async sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
          this.uniffiClonePointer(),
          FfiConverterString.lower(callId),
          FfiConverterTypeRtcApplicationType.lower(application),
          FfiConverterTypeNotifyType.lower(notifyType),
          FfiConverterTypeMentions.lower(mentions)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   */
  public async sendCallNotificationIfNeeded(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(isFavourite),
          FfiConverterOptionalFloat64.lower(tagOrder)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(isLowPriority),
          FfiConverterOptionalFloat64.lower(tagOrder)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Sets a new name to the room.
   */
  public async setName(name: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_set_name(
          this.uniffiClonePointer(),
          FfiConverterString.lower(name)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Sets a new topic in the room.
   */
  public async setTopic(topic: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
          this.uniffiClonePointer(),
          FfiConverterString.lower(topic)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  public async setUnreadFlag(newValue: boolean): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(newValue)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public subscribeToRoomInfoUpdates(listener: RoomInfoListener): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomInfoListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
          this.uniffiClonePointer(),
          FfiConverterTypeTypingNotificationsListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public async suggestedRoleForUser(
    userId: string
  ): Promise<RoomMemberRole> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomMemberRole.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async timeline(): Promise<Timeline> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_timeline(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeTimeline.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Returns a timeline focused on the given event.
   *
   * Note: this timeline is independent from that returned with
   * [`Self::timeline`], and as such it is not cached.
   */
  public async timelineFocusedOnEvent(
    eventId: string,
    numContextEvents: /*u16*/ number,
    internalIdPrefix: string | undefined
  ): Promise<Timeline> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_timeline_focused_on_event(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId),
          FfiConverterUInt16.lower(numContextEvents),
          FfiConverterOptionalString.lower(internalIdPrefix)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeTimeline.lift,
      errorHandler: FfiConverterTypeFocusEventError.lift,
    });
  }

  public topic(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_topic(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async typingNotice(isTyping: boolean): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(isTyping)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async unbanUser(
    userId: string,
    reason: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          FfiConverterOptionalString.lower(reason)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async updatePowerLevelsForUsers(
    updates: UserPowerLevelUpdate[]
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
          this.uniffiClonePointer(),
          FfiConverterArrayTypeUserPowerLevelUpdate.lower(updates)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
          this.uniffiClonePointer(),
          FfiConverterString.lower(mimeType),
          FfiConverterArrayBuffer.lower(data),
          FfiConverterOptionalTypeImageInfo.lower(mediaInfo)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_room(this.pointer, callStatus);
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_room(this.pointer, callStatus)
    );
  }
}

function createRoom(pointer: UnsafeMutableRawPointer): Room {
  const instance = Object.create(Room.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoom = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Room;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoom(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum NotifyType {
  RING,
  NOTIFY,
}

const FfiConverterTypeNotifyType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotifyType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return NotifyType.RING;
        case 2:
          return NotifyType.NOTIFY;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case NotifyType.RING:
          return ordinalConverter.write(1, into);
        case NotifyType.NOTIFY:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MatrixId
export enum MatrixIdKind {
  ROOM = 'Room',
  ROOM_ALIAS = 'RoomAlias',
  USER = 'User',
  EVENT_ON_ROOM_ID = 'EventOnRoomId',
  EVENT_ON_ROOM_ALIAS = 'EventOnRoomAlias',
}
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */
export type MatrixId =
  | { kind: MatrixIdKind.ROOM; value: { id: string } }
  | { kind: MatrixIdKind.ROOM_ALIAS; value: { alias: string } }
  | { kind: MatrixIdKind.USER; value: { id: string } }
  | {
      kind: MatrixIdKind.EVENT_ON_ROOM_ID;
      value: { roomId: string; eventId: string };
    }
  | {
      kind: MatrixIdKind.EVENT_ON_ROOM_ALIAS;
      value: { alias: string; eventId: string };
    };

// FfiConverter for enum MatrixId
const FfiConverterTypeMatrixId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MatrixId;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: MatrixIdKind.ROOM,
            value: {
              id: FfiConverterString.read(from),
            },
          };
        case 2:
          return {
            kind: MatrixIdKind.ROOM_ALIAS,
            value: {
              alias: FfiConverterString.read(from),
            },
          };
        case 3:
          return {
            kind: MatrixIdKind.USER,
            value: {
              id: FfiConverterString.read(from),
            },
          };
        case 4:
          return {
            kind: MatrixIdKind.EVENT_ON_ROOM_ID,
            value: {
              roomId: FfiConverterString.read(from),
              eventId: FfiConverterString.read(from),
            },
          };
        case 5:
          return {
            kind: MatrixIdKind.EVENT_ON_ROOM_ALIAS,
            value: {
              alias: FfiConverterString.read(from),
              eventId: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case MatrixIdKind.ROOM: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixIdKind.ROOM_ALIAS: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.alias, into);
          return;
        }
        case MatrixIdKind.USER: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixIdKind.EVENT_ON_ROOM_ID: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.roomId, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case MatrixIdKind.EVENT_ON_ROOM_ALIAS: {
          ordinalConverter.write(5, into);
          const inner = value.value;
          FfiConverterString.write(inner.alias, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that MatrixIdKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case MatrixIdKind.ROOM: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixIdKind.ROOM_ALIAS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.alias);
          return size;
        }
        case MatrixIdKind.USER: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixIdKind.EVENT_ON_ROOM_ID: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.roomId);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case MatrixIdKind.EVENT_ON_ROOM_ALIAS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.alias);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for UnstableVoiceContent | undefined
const FfiConverterOptionalTypeUnstableVoiceContent = new FfiConverterOptional(
  FfiConverterTypeUnstableVoiceContent
);

// FfiConverter for /*u16*/number[]
const FfiConverterArrayUInt16 = new FfiConverterArray(FfiConverterUInt16);

export interface EncryptionInterface {
  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  backupExistsOnServer() /*throws*/ : Promise<boolean>;
  backupState(): BackupState;
  backupStateListener(listener: BackupStateListener): TaskHandle;
  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  curve25519Key(): Promise<string | undefined>;
  disableRecovery() /*throws*/ : Promise<void>;
  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  ed25519Key(): Promise<string | undefined>;
  enableBackups() /*throws*/ : Promise<void>;
  enableRecovery(
    waitForBackupsToUpload: boolean,
    progressListener: EnableRecoveryProgressListener
  ) /*throws*/ : Promise<string>;
  isLastDevice() /*throws*/ : Promise<boolean>;
  recover(recoveryKey: string) /*throws*/ : Promise<void>;
  recoverAndReset(oldRecoveryKey: string) /*throws*/ : Promise<string>;
  recoveryState(): RecoveryState;
  recoveryStateListener(listener: RecoveryStateListener): TaskHandle;
  resetRecoveryKey() /*throws*/ : Promise<string>;
  verificationState(): VerificationState;
  verificationStateListener(listener: VerificationStateListener): TaskHandle;
  waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined
  ) /*throws*/ : Promise<void>;
  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  waitForE2eeInitializationTasks(): Promise<void>;
}

export class Encryption implements EncryptionInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  public async backupExistsOnServer(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public backupState(): BackupState {
    return FfiConverterTypeBackupState.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public backupStateListener(listener: BackupStateListener): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
          this.uniffiClonePointer(),
          FfiConverterTypeBackupStateListener.lower(listener),
          callStatus
        );
      })
    );
  }

  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  public async curve25519Key(): Promise<string | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: undefined,
    });
  }

  public async disableRecovery(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  public async ed25519Key(): Promise<string | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: undefined,
    });
  }

  public async enableBackups(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public async enableRecovery(
    waitForBackupsToUpload: boolean,
    progressListener: EnableRecoveryProgressListener
  ): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(waitForBackupsToUpload),
          FfiConverterTypeEnableRecoveryProgressListener.lower(progressListener)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public async isLastDevice(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public async recover(recoveryKey: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
          this.uniffiClonePointer(),
          FfiConverterString.lower(recoveryKey)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public async recoverAndReset(
    oldRecoveryKey: string
  ): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
          this.uniffiClonePointer(),
          FfiConverterString.lower(oldRecoveryKey)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public recoveryState(): RecoveryState {
    return FfiConverterTypeRecoveryState.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public recoveryStateListener(listener: RecoveryStateListener): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
          this.uniffiClonePointer(),
          FfiConverterTypeRecoveryStateListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public async resetRecoveryKey(): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeRecoveryError.lift,
    });
  }

  public verificationState(): VerificationState {
    return FfiConverterTypeVerificationState.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public verificationStateListener(
    listener: VerificationStateListener
  ): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
          this.uniffiClonePointer(),
          FfiConverterTypeVerificationStateListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public async waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
          this.uniffiClonePointer(),
          FfiConverterOptionalTypeBackupSteadyStateListener.lower(
            progressListener
          )
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeSteadyStateError.lift,
    });
  }

  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  public async waitForE2eeInitializationTasks(): Promise<void> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: undefined,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_encryption(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_encryption(
        this.pointer,
        callStatus
      )
    );
  }
}

function createEncryption(pointer: UnsafeMutableRawPointer): Encryption {
  const instance = Object.create(Encryption.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeEncryption = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Encryption;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createEncryption(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface HomeserverLoginDetailsInterface {
  /**
   * The URL of the discovered or manually set sliding sync proxy,
   * if any.
   */
  slidingSyncProxy(): string | undefined;
  /**
   * Whether the current homeserver supports login using OIDC.
   */
  supportsOidcLogin(): boolean;
  /**
   * Whether the current homeserver supports the password login flow.
   */
  supportsPasswordLogin(): boolean;
  /**
   * The URL of the currently configured homeserver.
   */
  url(): string;
}

export class HomeserverLoginDetails
  implements HomeserverLoginDetailsInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * The URL of the discovered or manually set sliding sync proxy,
   * if any.
   */
  public slidingSyncProxy(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_proxy(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Whether the current homeserver supports login using OIDC.
   */
  public supportsOidcLogin(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Whether the current homeserver supports the password login flow.
   */
  public supportsPasswordLogin(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * The URL of the currently configured homeserver.
   */
  public url(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(
        this.pointer,
        callStatus
      )
    );
  }
}

function createHomeserverLoginDetails(
  pointer: UnsafeMutableRawPointer
): HomeserverLoginDetails {
  const instance = Object.create(HomeserverLoginDetails.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeHomeserverLoginDetails = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = HomeserverLoginDetails;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createHomeserverLoginDetails(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for ImageInfo | undefined
const FfiConverterOptionalTypeImageInfo = new FfiConverterOptional(
  FfiConverterTypeImageInfo
);

// Enum: WidgetEventFilter
export enum WidgetEventFilterKind {
  MESSAGE_LIKE_WITH_TYPE = 'MessageLikeWithType',
  ROOM_MESSAGE_WITH_MSGTYPE = 'RoomMessageWithMsgtype',
  STATE_WITH_TYPE = 'StateWithType',
  STATE_WITH_TYPE_AND_STATE_KEY = 'StateWithTypeAndStateKey',
}
/**
 * Different kinds of filters that could be applied to the timeline events.
 */
export type WidgetEventFilter =
  /**
   * Matches message-like events with the given `type`.
   */
  | {
      kind: WidgetEventFilterKind.MESSAGE_LIKE_WITH_TYPE;
      value: { eventType: string };
    }
  /**
   * Matches `m.room.message` events with the given `msgtype`.
   */
  | {
      kind: WidgetEventFilterKind.ROOM_MESSAGE_WITH_MSGTYPE;
      value: { msgtype: string };
    }
  /**
   * Matches state events with the given `type`, regardless of `state_key`.
   */
  | {
      kind: WidgetEventFilterKind.STATE_WITH_TYPE;
      value: { eventType: string };
    }
  /**
   * Matches state events with the given `type` and `state_key`.
   */
  | {
      kind: WidgetEventFilterKind.STATE_WITH_TYPE_AND_STATE_KEY;
      value: { eventType: string; stateKey: string };
    };

// FfiConverter for enum WidgetEventFilter
const FfiConverterTypeWidgetEventFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WidgetEventFilter;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: WidgetEventFilterKind.MESSAGE_LIKE_WITH_TYPE,
            value: {
              eventType: FfiConverterString.read(from),
            },
          };
        case 2:
          return {
            kind: WidgetEventFilterKind.ROOM_MESSAGE_WITH_MSGTYPE,
            value: {
              msgtype: FfiConverterString.read(from),
            },
          };
        case 3:
          return {
            kind: WidgetEventFilterKind.STATE_WITH_TYPE,
            value: {
              eventType: FfiConverterString.read(from),
            },
          };
        case 4:
          return {
            kind: WidgetEventFilterKind.STATE_WITH_TYPE_AND_STATE_KEY,
            value: {
              eventType: FfiConverterString.read(from),
              stateKey: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case WidgetEventFilterKind.MESSAGE_LIKE_WITH_TYPE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilterKind.ROOM_MESSAGE_WITH_MSGTYPE: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.msgtype, into);
          return;
        }
        case WidgetEventFilterKind.STATE_WITH_TYPE: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilterKind.STATE_WITH_TYPE_AND_STATE_KEY: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          return;
        }
        default:
          // Throwing from here means that WidgetEventFilterKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case WidgetEventFilterKind.MESSAGE_LIKE_WITH_TYPE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilterKind.ROOM_MESSAGE_WITH_MSGTYPE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.msgtype);
          return size;
        }
        case WidgetEventFilterKind.STATE_WITH_TYPE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilterKind.STATE_WITH_TYPE_AND_STATE_KEY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationEvent
export enum NotificationEventKind {
  TIMELINE = 'Timeline',
  INVITE = 'Invite',
}
export type NotificationEvent =
  | { kind: NotificationEventKind.TIMELINE; value: { event: TimelineEvent } }
  | { kind: NotificationEventKind.INVITE; value: { sender: string } };

// FfiConverter for enum NotificationEvent
const FfiConverterTypeNotificationEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationEvent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: NotificationEventKind.TIMELINE,
            value: {
              event: FfiConverterTypeTimelineEvent.read(from),
            },
          };
        case 2:
          return {
            kind: NotificationEventKind.INVITE,
            value: {
              sender: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case NotificationEventKind.TIMELINE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterTypeTimelineEvent.write(inner.event, into);
          return;
        }
        case NotificationEventKind.INVITE: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.sender, into);
          return;
        }
        default:
          // Throwing from here means that NotificationEventKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case NotificationEventKind.TIMELINE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTimelineEvent.allocationSize(inner.event);
          return size;
        }
        case NotificationEventKind.INVITE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sender);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for ThumbnailInfo | undefined
const FfiConverterOptionalTypeThumbnailInfo = new FfiConverterOptional(
  FfiConverterTypeThumbnailInfo
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface EventTimelineItemInterface {
  canBeRepliedTo(): boolean;
  content(): TimelineItemContent;
  debugInfo(): EventTimelineItemDebugInfo;
  eventId(): string | undefined;
  isEditable(): boolean;
  isLocal(): boolean;
  isOwn(): boolean;
  isRemote(): boolean;
  localSendState(): EventSendState | undefined;
  origin(): EventItemOrigin | undefined;
  reactions(): Reaction[];
  readReceipts(): Map<string, Receipt>;
  sender(): string;
  senderProfile(): ProfileDetails;
  timestamp(): /*u64*/ bigint;
  transactionId(): string | undefined;
}

export class EventTimelineItem
  implements EventTimelineItemInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public canBeRepliedTo(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_can_be_replied_to(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public content(): TimelineItemContent {
    return FfiConverterTypeTimelineItemContent.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_content(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public debugInfo(): EventTimelineItemDebugInfo {
    return FfiConverterTypeEventTimelineItemDebugInfo.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_debug_info(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public eventId(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_event_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isEditable(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_editable(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isLocal(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_local(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isOwn(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_own(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isRemote(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_remote(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public localSendState(): EventSendState | undefined {
    return FfiConverterOptionalTypeEventSendState.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_local_send_state(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public origin(): EventItemOrigin | undefined {
    return FfiConverterOptionalTypeEventItemOrigin.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_origin(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public reactions(): Reaction[] {
    return FfiConverterArrayTypeReaction.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_reactions(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public readReceipts(): Map<string, Receipt> {
    return FfiConverterMapStringTypeReceipt.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_read_receipts(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public sender(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public senderProfile(): ProfileDetails {
    return FfiConverterTypeProfileDetails.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender_profile(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public timestamp(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_timestamp(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public transactionId(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_transaction_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_eventtimelineitem(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_eventtimelineitem(
        this.pointer,
        callStatus
      )
    );
  }
}

function createEventTimelineItem(
  pointer: UnsafeMutableRawPointer
): EventTimelineItem {
  const instance = Object.create(EventTimelineItem.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeEventTimelineItem = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = EventTimelineItem;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createEventTimelineItem(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum LogLevel {
  ERROR,
  WARN,
  INFO,
  DEBUG,
  TRACE,
}

const FfiConverterTypeLogLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogLevel;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogLevel.ERROR;
        case 2:
          return LogLevel.WARN;
        case 3:
          return LogLevel.INFO;
        case 4:
          return LogLevel.DEBUG;
        case 5:
          return LogLevel.TRACE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogLevel.ERROR:
          return ordinalConverter.write(1, into);
        case LogLevel.WARN:
          return ordinalConverter.write(2, into);
        case LogLevel.INFO:
          return ordinalConverter.write(3, into);
        case LogLevel.DEBUG:
          return ordinalConverter.write(4, into);
        case LogLevel.TRACE:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum MembershipChange {
  NONE,
  ERROR,
  JOINED,
  LEFT,
  BANNED,
  UNBANNED,
  KICKED,
  INVITED,
  KICKED_AND_BANNED,
  INVITATION_ACCEPTED,
  INVITATION_REJECTED,
  INVITATION_REVOKED,
  KNOCKED,
  KNOCK_ACCEPTED,
  KNOCK_RETRACTED,
  KNOCK_DENIED,
  NOT_IMPLEMENTED,
}

const FfiConverterTypeMembershipChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipChange;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MembershipChange.NONE;
        case 2:
          return MembershipChange.ERROR;
        case 3:
          return MembershipChange.JOINED;
        case 4:
          return MembershipChange.LEFT;
        case 5:
          return MembershipChange.BANNED;
        case 6:
          return MembershipChange.UNBANNED;
        case 7:
          return MembershipChange.KICKED;
        case 8:
          return MembershipChange.INVITED;
        case 9:
          return MembershipChange.KICKED_AND_BANNED;
        case 10:
          return MembershipChange.INVITATION_ACCEPTED;
        case 11:
          return MembershipChange.INVITATION_REJECTED;
        case 12:
          return MembershipChange.INVITATION_REVOKED;
        case 13:
          return MembershipChange.KNOCKED;
        case 14:
          return MembershipChange.KNOCK_ACCEPTED;
        case 15:
          return MembershipChange.KNOCK_RETRACTED;
        case 16:
          return MembershipChange.KNOCK_DENIED;
        case 17:
          return MembershipChange.NOT_IMPLEMENTED;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MembershipChange.NONE:
          return ordinalConverter.write(1, into);
        case MembershipChange.ERROR:
          return ordinalConverter.write(2, into);
        case MembershipChange.JOINED:
          return ordinalConverter.write(3, into);
        case MembershipChange.LEFT:
          return ordinalConverter.write(4, into);
        case MembershipChange.BANNED:
          return ordinalConverter.write(5, into);
        case MembershipChange.UNBANNED:
          return ordinalConverter.write(6, into);
        case MembershipChange.KICKED:
          return ordinalConverter.write(7, into);
        case MembershipChange.INVITED:
          return ordinalConverter.write(8, into);
        case MembershipChange.KICKED_AND_BANNED:
          return ordinalConverter.write(9, into);
        case MembershipChange.INVITATION_ACCEPTED:
          return ordinalConverter.write(10, into);
        case MembershipChange.INVITATION_REJECTED:
          return ordinalConverter.write(11, into);
        case MembershipChange.INVITATION_REVOKED:
          return ordinalConverter.write(12, into);
        case MembershipChange.KNOCKED:
          return ordinalConverter.write(13, into);
        case MembershipChange.KNOCK_ACCEPTED:
          return ordinalConverter.write(14, into);
        case MembershipChange.KNOCK_RETRACTED:
          return ordinalConverter.write(15, into);
        case MembershipChange.KNOCK_DENIED:
          return ordinalConverter.write(16, into);
        case MembershipChange.NOT_IMPLEMENTED:
          return ordinalConverter.write(17, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export interface RoomListServiceInterface {
  allRooms() /*throws*/ : Promise<RoomList>;
  applyInput(input: RoomListInput) /*throws*/ : Promise<void>;
  room(roomId: string) /*throws*/ : Promise<RoomListItem>;
  state(listener: RoomListServiceStateListener): TaskHandle;
  syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandle;
}

export class RoomListService
  implements RoomListServiceInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async allRooms(): Promise<RoomList> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomList.lift,
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  public async applyInput(input: RoomListInput): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_apply_input(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomListInput.lower(input)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  public async room(roomId: string): Promise<RoomListItem> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomListItem.lift,
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  public state(listener: RoomListServiceStateListener): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomListServiceStateListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
          this.uniffiClonePointer(),
          FfiConverterUInt32.lower(delayBeforeShowingInMs),
          FfiConverterUInt32.lower(delayBeforeHidingInMs),
          FfiConverterTypeRoomListServiceSyncIndicatorListener.lower(listener),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roomlistservice(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomListService(
  pointer: UnsafeMutableRawPointer
): RoomListService {
  const instance = Object.create(RoomListService.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomListService = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomListService;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomListService(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum PublicRoomJoinRule {
  PUBLIC,
  KNOCK,
}

const FfiConverterTypePublicRoomJoinRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PublicRoomJoinRule;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PublicRoomJoinRule.PUBLIC;
        case 2:
          return PublicRoomJoinRule.KNOCK;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PublicRoomJoinRule.PUBLIC:
          return ordinalConverter.write(1, into);
        case PublicRoomJoinRule.KNOCK:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for AudioInfo | undefined
const FfiConverterOptionalTypeAudioInfo = new FfiConverterOptional(
  FfiConverterTypeAudioInfo
);

export interface NotificationSettingsInterface {
  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canHomeserverPushEncryptedEventToDevice(): Promise<boolean>;
  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canPushEncryptedEventToDevice(): Promise<boolean>;
  /**
   * Get whether some enabled keyword rules exist.
   */
  containsKeywordsRules(): Promise<boolean>;
  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean
  ): Promise<RoomNotificationMode>;
  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean
  ) /*throws*/ : Promise<RoomNotificationSettings>;
  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  getRoomsWithUserDefinedRules(enabled: boolean | undefined): Promise<string[]>;
  /**
   * Get the user defined room notification mode
   */
  getUserDefinedRoomNotificationMode(
    roomId: string
  ) /*throws*/ : Promise<RoomNotificationMode | undefined>;
  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  isCallEnabled() /*throws*/ : Promise<boolean>;
  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  isInviteForMeEnabled() /*throws*/ : Promise<boolean>;
  /**
   * Get whether room mentions are enabled.
   */
  isRoomMentionEnabled() /*throws*/ : Promise<boolean>;
  /**
   * Get whether user mentions are enabled.
   */
  isUserMentionEnabled() /*throws*/ : Promise<boolean>;
  /**
   * Restore the default notification mode for a room
   */
  restoreDefaultRoomNotificationMode(roomId: string) /*throws*/ : Promise<void>;
  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  setCallEnabled(enabled: boolean) /*throws*/ : Promise<void>;
  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode
  ) /*throws*/ : Promise<void>;
  setDelegate(delegate: NotificationSettingsDelegate | undefined): void;
  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  setInviteForMeEnabled(enabled: boolean) /*throws*/ : Promise<void>;
  /**
   * Set whether room mentions are enabled.
   */
  setRoomMentionEnabled(enabled: boolean) /*throws*/ : Promise<void>;
  /**
   * Set the notification mode for a room.
   */
  setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether user mentions are enabled.
   */
  setUserMentionEnabled(enabled: boolean) /*throws*/ : Promise<void>;
  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean
  ) /*throws*/ : Promise<void>;
}

export class NotificationSettings
  implements NotificationSettingsInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canHomeserverPushEncryptedEventToDevice(): Promise<boolean> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canPushEncryptedEventToDevice(): Promise<boolean> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Get whether some enabled keyword rules exist.
   */
  public async containsKeywordsRules(): Promise<boolean> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  public async getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean
  ): Promise<RoomNotificationMode> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(isEncrypted),
          FfiConverterBool.lower(isOneToOne)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomNotificationMode.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean
  ): Promise<RoomNotificationSettings> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId),
          FfiConverterBool.lower(isEncrypted),
          FfiConverterBool.lower(isOneToOne)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomNotificationSettings.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  public async getRoomsWithUserDefinedRules(
    enabled: boolean | undefined
  ): Promise<string[]> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
          this.uniffiClonePointer(),
          FfiConverterOptionalBool.lower(enabled)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterArrayString.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Get the user defined room notification mode
   */
  public async getUserDefinedRoomNotificationMode(
    roomId: string
  ): Promise<RoomNotificationMode | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalTypeRoomNotificationMode.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  public async isCallEnabled(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async isInviteForMeEnabled(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Get whether room mentions are enabled.
   */
  public async isRoomMentionEnabled(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Get whether user mentions are enabled.
   */
  public async isUserMentionEnabled(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Restore the default notification mode for a room
   */
  public async restoreDefaultRoomNotificationMode(
    roomId: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  public async setCallEnabled(enabled: boolean): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(enabled)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  public async setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(isEncrypted),
          FfiConverterBool.lower(isOneToOne),
          FfiConverterTypeRoomNotificationMode.lower(mode)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  public setDelegate(delegate: NotificationSettingsDelegate | undefined): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
        this.uniffiClonePointer(),
        FfiConverterOptionalTypeNotificationSettingsDelegate.lower(delegate),
        callStatus
      );
    });
  }

  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async setInviteForMeEnabled(
    enabled: boolean
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(enabled)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Set whether room mentions are enabled.
   */
  public async setRoomMentionEnabled(
    enabled: boolean
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(enabled)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Set the notification mode for a room.
   */
  public async setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId),
          FfiConverterTypeRoomNotificationMode.lower(mode)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Set whether user mentions are enabled.
   */
  public async setUserMentionEnabled(
    enabled: boolean
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(enabled)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId),
          FfiConverterBool.lower(isEncrypted),
          FfiConverterBool.lower(isOneToOne)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeNotificationSettingsError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_notificationsettings(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(
        this.pointer,
        callStatus
      )
    );
  }
}

function createNotificationSettings(
  pointer: UnsafeMutableRawPointer
): NotificationSettings {
  const instance = Object.create(NotificationSettings.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeNotificationSettings = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = NotificationSettings;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createNotificationSettings(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum TimelineChange {
  APPEND,
  CLEAR,
  INSERT,
  SET,
  REMOVE,
  PUSH_BACK,
  PUSH_FRONT,
  POP_BACK,
  POP_FRONT,
  TRUNCATE,
  RESET,
}

const FfiConverterTypeTimelineChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineChange;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TimelineChange.APPEND;
        case 2:
          return TimelineChange.CLEAR;
        case 3:
          return TimelineChange.INSERT;
        case 4:
          return TimelineChange.SET;
        case 5:
          return TimelineChange.REMOVE;
        case 6:
          return TimelineChange.PUSH_BACK;
        case 7:
          return TimelineChange.PUSH_FRONT;
        case 8:
          return TimelineChange.POP_BACK;
        case 9:
          return TimelineChange.POP_FRONT;
        case 10:
          return TimelineChange.TRUNCATE;
        case 11:
          return TimelineChange.RESET;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TimelineChange.APPEND:
          return ordinalConverter.write(1, into);
        case TimelineChange.CLEAR:
          return ordinalConverter.write(2, into);
        case TimelineChange.INSERT:
          return ordinalConverter.write(3, into);
        case TimelineChange.SET:
          return ordinalConverter.write(4, into);
        case TimelineChange.REMOVE:
          return ordinalConverter.write(5, into);
        case TimelineChange.PUSH_BACK:
          return ordinalConverter.write(6, into);
        case TimelineChange.PUSH_FRONT:
          return ordinalConverter.write(7, into);
        case TimelineChange.POP_BACK:
          return ordinalConverter.write(8, into);
        case TimelineChange.POP_FRONT:
          return ordinalConverter.write(9, into);
        case TimelineChange.TRUNCATE:
          return ordinalConverter.write(10, into);
        case TimelineChange.RESET:
          return ordinalConverter.write(11, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export interface TimelineItemContentInterface {
  asMessage(): Message | undefined;
  kind(): TimelineItemContentKind;
}

export class TimelineItemContent
  implements TimelineItemContentInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public asMessage(): Message | undefined {
    return FfiConverterOptionalTypeMessage.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_as_message(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public kind(): TimelineItemContentKind {
    return FfiConverterTypeTimelineItemContentKind.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_kind(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timelineitemcontent(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timelineitemcontent(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimelineItemContent(
  pointer: UnsafeMutableRawPointer
): TimelineItemContent {
  const instance = Object.create(TimelineItemContent.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimelineItemContent = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TimelineItemContent;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimelineItemContent(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for SetData | undefined
const FfiConverterOptionalTypeSetData = new FfiConverterOptional(
  FfiConverterTypeSetData
);

// FfiConverter for string[]
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// Enum: MessageType
export enum MessageTypeKind {
  EMOTE = 'Emote',
  IMAGE = 'Image',
  AUDIO = 'Audio',
  VIDEO = 'Video',
  FILE = 'File',
  NOTICE = 'Notice',
  TEXT = 'Text',
  LOCATION = 'Location',
  OTHER = 'Other',
}
export type MessageType =
  | { kind: MessageTypeKind.EMOTE; value: { content: EmoteMessageContent } }
  | { kind: MessageTypeKind.IMAGE; value: { content: ImageMessageContent } }
  | { kind: MessageTypeKind.AUDIO; value: { content: AudioMessageContent } }
  | { kind: MessageTypeKind.VIDEO; value: { content: VideoMessageContent } }
  | { kind: MessageTypeKind.FILE; value: { content: FileMessageContent } }
  | { kind: MessageTypeKind.NOTICE; value: { content: NoticeMessageContent } }
  | { kind: MessageTypeKind.TEXT; value: { content: TextMessageContent } }
  | { kind: MessageTypeKind.LOCATION; value: { content: LocationContent } }
  | { kind: MessageTypeKind.OTHER; value: { msgtype: string; body: string } };

// FfiConverter for enum MessageType
const FfiConverterTypeMessageType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: MessageTypeKind.EMOTE,
            value: {
              content: FfiConverterTypeEmoteMessageContent.read(from),
            },
          };
        case 2:
          return {
            kind: MessageTypeKind.IMAGE,
            value: {
              content: FfiConverterTypeImageMessageContent.read(from),
            },
          };
        case 3:
          return {
            kind: MessageTypeKind.AUDIO,
            value: {
              content: FfiConverterTypeAudioMessageContent.read(from),
            },
          };
        case 4:
          return {
            kind: MessageTypeKind.VIDEO,
            value: {
              content: FfiConverterTypeVideoMessageContent.read(from),
            },
          };
        case 5:
          return {
            kind: MessageTypeKind.FILE,
            value: {
              content: FfiConverterTypeFileMessageContent.read(from),
            },
          };
        case 6:
          return {
            kind: MessageTypeKind.NOTICE,
            value: {
              content: FfiConverterTypeNoticeMessageContent.read(from),
            },
          };
        case 7:
          return {
            kind: MessageTypeKind.TEXT,
            value: {
              content: FfiConverterTypeTextMessageContent.read(from),
            },
          };
        case 8:
          return {
            kind: MessageTypeKind.LOCATION,
            value: {
              content: FfiConverterTypeLocationContent.read(from),
            },
          };
        case 9:
          return {
            kind: MessageTypeKind.OTHER,
            value: {
              msgtype: FfiConverterString.read(from),
              body: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case MessageTypeKind.EMOTE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterTypeEmoteMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.IMAGE: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterTypeImageMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.AUDIO: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterTypeAudioMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.VIDEO: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterTypeVideoMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.FILE: {
          ordinalConverter.write(5, into);
          const inner = value.value;
          FfiConverterTypeFileMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.NOTICE: {
          ordinalConverter.write(6, into);
          const inner = value.value;
          FfiConverterTypeNoticeMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.TEXT: {
          ordinalConverter.write(7, into);
          const inner = value.value;
          FfiConverterTypeTextMessageContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.LOCATION: {
          ordinalConverter.write(8, into);
          const inner = value.value;
          FfiConverterTypeLocationContent.write(inner.content, into);
          return;
        }
        case MessageTypeKind.OTHER: {
          ordinalConverter.write(9, into);
          const inner = value.value;
          FfiConverterString.write(inner.msgtype, into);
          FfiConverterString.write(inner.body, into);
          return;
        }
        default:
          // Throwing from here means that MessageTypeKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case MessageTypeKind.EMOTE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEmoteMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.IMAGE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeImageMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.AUDIO: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeAudioMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.VIDEO: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeVideoMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.FILE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeFileMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.NOTICE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeNoticeMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.TEXT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeTextMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageTypeKind.LOCATION: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeLocationContent.allocationSize(inner.content);
          return size;
        }
        case MessageTypeKind.OTHER: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.msgtype);
          size += FfiConverterString.allocationSize(inner.body);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for FormattedBody | undefined
const FfiConverterOptionalTypeFormattedBody = new FfiConverterOptional(
  FfiConverterTypeFormattedBody
);

// Enum: FilterTimelineEventType
export enum FilterTimelineEventTypeKind {
  MESSAGE_LIKE = 'MessageLike',
  STATE = 'State',
}
export type FilterTimelineEventType =
  | {
      kind: FilterTimelineEventTypeKind.MESSAGE_LIKE;
      value: { eventType: MessageLikeEventType };
    }
  | {
      kind: FilterTimelineEventTypeKind.STATE;
      value: { eventType: StateEventType };
    };

// FfiConverter for enum FilterTimelineEventType
const FfiConverterTypeFilterTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FilterTimelineEventType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: FilterTimelineEventTypeKind.MESSAGE_LIKE,
            value: {
              eventType: FfiConverterTypeMessageLikeEventType.read(from),
            },
          };
        case 2:
          return {
            kind: FilterTimelineEventTypeKind.STATE,
            value: {
              eventType: FfiConverterTypeStateEventType.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case FilterTimelineEventTypeKind.MESSAGE_LIKE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterTypeMessageLikeEventType.write(inner.eventType, into);
          return;
        }
        case FilterTimelineEventTypeKind.STATE: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterTypeStateEventType.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that FilterTimelineEventTypeKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case FilterTimelineEventTypeKind.MESSAGE_LIKE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        case FilterTimelineEventTypeKind.STATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export class FocusEventException extends Error {
  private constructor(message: string) {
    super(message);
  }
  // non-flat errors aren't implemented yet.
}

const FfiConverterTypeFocusEventError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = FocusEventException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        // non-flat errors aren't implement yet.

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      throw new Error('Method not implemented.');
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export class RoomException extends Error {
  private constructor(message: string) {
    super(message);
  }
  static InvalidAttachmentData = class InvalidAttachmentData extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidAttachmentMimeType = class InvalidAttachmentMimeType extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidMediaInfo = class InvalidMediaInfo extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };

  static TimelineUnavailable = class TimelineUnavailable extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidThumbnailData = class InvalidThumbnailData extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };

  static FailedSendingAttachment = class FailedSendingAttachment extends RoomException {
    constructor(message: string) {
      super(message);
    }
  };
}

const FfiConverterTypeRoomError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = RoomException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new RoomException.InvalidAttachmentData(
            stringConverter.read(from)
          );

        case 2:
          return new RoomException.InvalidAttachmentMimeType(
            stringConverter.read(from)
          );

        case 3:
          return new RoomException.InvalidMediaInfo(stringConverter.read(from));

        case 4:
          return new RoomException.TimelineUnavailable(
            stringConverter.read(from)
          );

        case 5:
          return new RoomException.InvalidThumbnailData(
            stringConverter.read(from)
          );

        case 6:
          return new RoomException.FailedSendingAttachment(
            stringConverter.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      if (value instanceof RoomException.InvalidAttachmentData) {
        intConverter.write(0, into);
      } else if (value instanceof RoomException.InvalidAttachmentMimeType) {
        intConverter.write(1, into);
      } else if (value instanceof RoomException.InvalidMediaInfo) {
        intConverter.write(2, into);
      } else if (value instanceof RoomException.TimelineUnavailable) {
        intConverter.write(3, into);
      } else if (value instanceof RoomException.InvalidThumbnailData) {
        intConverter.write(4, into);
      } else if (value instanceof RoomException.FailedSendingAttachment) {
        intConverter.write(5, into);
      } else {
        throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

// Enum: OtherState
export enum OtherStateKind {
  POLICY_RULE_ROOM = 'PolicyRuleRoom',
  POLICY_RULE_SERVER = 'PolicyRuleServer',
  POLICY_RULE_USER = 'PolicyRuleUser',
  ROOM_ALIASES = 'RoomAliases',
  ROOM_AVATAR = 'RoomAvatar',
  ROOM_CANONICAL_ALIAS = 'RoomCanonicalAlias',
  ROOM_CREATE = 'RoomCreate',
  ROOM_ENCRYPTION = 'RoomEncryption',
  ROOM_GUEST_ACCESS = 'RoomGuestAccess',
  ROOM_HISTORY_VISIBILITY = 'RoomHistoryVisibility',
  ROOM_JOIN_RULES = 'RoomJoinRules',
  ROOM_NAME = 'RoomName',
  ROOM_PINNED_EVENTS = 'RoomPinnedEvents',
  ROOM_POWER_LEVELS = 'RoomPowerLevels',
  ROOM_SERVER_ACL = 'RoomServerAcl',
  ROOM_THIRD_PARTY_INVITE = 'RoomThirdPartyInvite',
  ROOM_TOMBSTONE = 'RoomTombstone',
  ROOM_TOPIC = 'RoomTopic',
  SPACE_CHILD = 'SpaceChild',
  SPACE_PARENT = 'SpaceParent',
  CUSTOM = 'Custom',
}
export type OtherState =
  | { kind: OtherStateKind.POLICY_RULE_ROOM }
  | { kind: OtherStateKind.POLICY_RULE_SERVER }
  | { kind: OtherStateKind.POLICY_RULE_USER }
  | { kind: OtherStateKind.ROOM_ALIASES }
  | { kind: OtherStateKind.ROOM_AVATAR; value: { url: string | undefined } }
  | { kind: OtherStateKind.ROOM_CANONICAL_ALIAS }
  | { kind: OtherStateKind.ROOM_CREATE }
  | { kind: OtherStateKind.ROOM_ENCRYPTION }
  | { kind: OtherStateKind.ROOM_GUEST_ACCESS }
  | { kind: OtherStateKind.ROOM_HISTORY_VISIBILITY }
  | { kind: OtherStateKind.ROOM_JOIN_RULES }
  | { kind: OtherStateKind.ROOM_NAME; value: { name: string | undefined } }
  | { kind: OtherStateKind.ROOM_PINNED_EVENTS }
  | {
      kind: OtherStateKind.ROOM_POWER_LEVELS;
      value: {
        users: Map<string, /*i64*/ bigint>;
        previous: Map<string, /*i64*/ bigint> | undefined;
      };
    }
  | { kind: OtherStateKind.ROOM_SERVER_ACL }
  | {
      kind: OtherStateKind.ROOM_THIRD_PARTY_INVITE;
      value: { displayName: string | undefined };
    }
  | { kind: OtherStateKind.ROOM_TOMBSTONE }
  | { kind: OtherStateKind.ROOM_TOPIC; value: { topic: string | undefined } }
  | { kind: OtherStateKind.SPACE_CHILD }
  | { kind: OtherStateKind.SPACE_PARENT }
  | { kind: OtherStateKind.CUSTOM; value: { eventType: string } };

// FfiConverter for enum OtherState
const FfiConverterTypeOtherState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OtherState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: OtherStateKind.POLICY_RULE_ROOM };
        case 2:
          return { kind: OtherStateKind.POLICY_RULE_SERVER };
        case 3:
          return { kind: OtherStateKind.POLICY_RULE_USER };
        case 4:
          return { kind: OtherStateKind.ROOM_ALIASES };
        case 5:
          return {
            kind: OtherStateKind.ROOM_AVATAR,
            value: {
              url: FfiConverterOptionalString.read(from),
            },
          };
        case 6:
          return { kind: OtherStateKind.ROOM_CANONICAL_ALIAS };
        case 7:
          return { kind: OtherStateKind.ROOM_CREATE };
        case 8:
          return { kind: OtherStateKind.ROOM_ENCRYPTION };
        case 9:
          return { kind: OtherStateKind.ROOM_GUEST_ACCESS };
        case 10:
          return { kind: OtherStateKind.ROOM_HISTORY_VISIBILITY };
        case 11:
          return { kind: OtherStateKind.ROOM_JOIN_RULES };
        case 12:
          return {
            kind: OtherStateKind.ROOM_NAME,
            value: {
              name: FfiConverterOptionalString.read(from),
            },
          };
        case 13:
          return { kind: OtherStateKind.ROOM_PINNED_EVENTS };
        case 14:
          return {
            kind: OtherStateKind.ROOM_POWER_LEVELS,
            value: {
              users: FfiConverterMapStringInt64.read(from),
              previous: FfiConverterOptionalMapStringInt64.read(from),
            },
          };
        case 15:
          return { kind: OtherStateKind.ROOM_SERVER_ACL };
        case 16:
          return {
            kind: OtherStateKind.ROOM_THIRD_PARTY_INVITE,
            value: {
              displayName: FfiConverterOptionalString.read(from),
            },
          };
        case 17:
          return { kind: OtherStateKind.ROOM_TOMBSTONE };
        case 18:
          return {
            kind: OtherStateKind.ROOM_TOPIC,
            value: {
              topic: FfiConverterOptionalString.read(from),
            },
          };
        case 19:
          return { kind: OtherStateKind.SPACE_CHILD };
        case 20:
          return { kind: OtherStateKind.SPACE_PARENT };
        case 21:
          return {
            kind: OtherStateKind.CUSTOM,
            value: {
              eventType: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case OtherStateKind.POLICY_RULE_ROOM: {
          ordinalConverter.write(1, into);
          return;
        }
        case OtherStateKind.POLICY_RULE_SERVER: {
          ordinalConverter.write(2, into);
          return;
        }
        case OtherStateKind.POLICY_RULE_USER: {
          ordinalConverter.write(3, into);
          return;
        }
        case OtherStateKind.ROOM_ALIASES: {
          ordinalConverter.write(4, into);
          return;
        }
        case OtherStateKind.ROOM_AVATAR: {
          ordinalConverter.write(5, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.url, into);
          return;
        }
        case OtherStateKind.ROOM_CANONICAL_ALIAS: {
          ordinalConverter.write(6, into);
          return;
        }
        case OtherStateKind.ROOM_CREATE: {
          ordinalConverter.write(7, into);
          return;
        }
        case OtherStateKind.ROOM_ENCRYPTION: {
          ordinalConverter.write(8, into);
          return;
        }
        case OtherStateKind.ROOM_GUEST_ACCESS: {
          ordinalConverter.write(9, into);
          return;
        }
        case OtherStateKind.ROOM_HISTORY_VISIBILITY: {
          ordinalConverter.write(10, into);
          return;
        }
        case OtherStateKind.ROOM_JOIN_RULES: {
          ordinalConverter.write(11, into);
          return;
        }
        case OtherStateKind.ROOM_NAME: {
          ordinalConverter.write(12, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.name, into);
          return;
        }
        case OtherStateKind.ROOM_PINNED_EVENTS: {
          ordinalConverter.write(13, into);
          return;
        }
        case OtherStateKind.ROOM_POWER_LEVELS: {
          ordinalConverter.write(14, into);
          const inner = value.value;
          FfiConverterMapStringInt64.write(inner.users, into);
          FfiConverterOptionalMapStringInt64.write(inner.previous, into);
          return;
        }
        case OtherStateKind.ROOM_SERVER_ACL: {
          ordinalConverter.write(15, into);
          return;
        }
        case OtherStateKind.ROOM_THIRD_PARTY_INVITE: {
          ordinalConverter.write(16, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.displayName, into);
          return;
        }
        case OtherStateKind.ROOM_TOMBSTONE: {
          ordinalConverter.write(17, into);
          return;
        }
        case OtherStateKind.ROOM_TOPIC: {
          ordinalConverter.write(18, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.topic, into);
          return;
        }
        case OtherStateKind.SPACE_CHILD: {
          ordinalConverter.write(19, into);
          return;
        }
        case OtherStateKind.SPACE_PARENT: {
          ordinalConverter.write(20, into);
          return;
        }
        case OtherStateKind.CUSTOM: {
          ordinalConverter.write(21, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that OtherStateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case OtherStateKind.POLICY_RULE_ROOM: {
          return ordinalConverter.allocationSize(1);
        }
        case OtherStateKind.POLICY_RULE_SERVER: {
          return ordinalConverter.allocationSize(2);
        }
        case OtherStateKind.POLICY_RULE_USER: {
          return ordinalConverter.allocationSize(3);
        }
        case OtherStateKind.ROOM_ALIASES: {
          return ordinalConverter.allocationSize(4);
        }
        case OtherStateKind.ROOM_AVATAR: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterOptionalString.allocationSize(inner.url);
          return size;
        }
        case OtherStateKind.ROOM_CANONICAL_ALIAS: {
          return ordinalConverter.allocationSize(6);
        }
        case OtherStateKind.ROOM_CREATE: {
          return ordinalConverter.allocationSize(7);
        }
        case OtherStateKind.ROOM_ENCRYPTION: {
          return ordinalConverter.allocationSize(8);
        }
        case OtherStateKind.ROOM_GUEST_ACCESS: {
          return ordinalConverter.allocationSize(9);
        }
        case OtherStateKind.ROOM_HISTORY_VISIBILITY: {
          return ordinalConverter.allocationSize(10);
        }
        case OtherStateKind.ROOM_JOIN_RULES: {
          return ordinalConverter.allocationSize(11);
        }
        case OtherStateKind.ROOM_NAME: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterOptionalString.allocationSize(inner.name);
          return size;
        }
        case OtherStateKind.ROOM_PINNED_EVENTS: {
          return ordinalConverter.allocationSize(13);
        }
        case OtherStateKind.ROOM_POWER_LEVELS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterMapStringInt64.allocationSize(inner.users);
          size += FfiConverterOptionalMapStringInt64.allocationSize(
            inner.previous
          );
          return size;
        }
        case OtherStateKind.ROOM_SERVER_ACL: {
          return ordinalConverter.allocationSize(15);
        }
        case OtherStateKind.ROOM_THIRD_PARTY_INVITE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          return size;
        }
        case OtherStateKind.ROOM_TOMBSTONE: {
          return ordinalConverter.allocationSize(17);
        }
        case OtherStateKind.ROOM_TOPIC: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(18);
          size += FfiConverterOptionalString.allocationSize(inner.topic);
          return size;
        }
        case OtherStateKind.SPACE_CHILD: {
          return ordinalConverter.allocationSize(19);
        }
        case OtherStateKind.SPACE_PARENT: {
          return ordinalConverter.allocationSize(20);
        }
        case OtherStateKind.CUSTOM: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(21);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface ClientBuilderInterface {
  addRootCertificates(certificates: ArrayBuffer[]): ClientBuilder;
  /**
   * Automatically create a backup version if no backup exists.
   */
  autoEnableBackups(autoEnableBackups: boolean): ClientBuilder;
  autoEnableCrossSigning(autoEnableCrossSigning: boolean): ClientBuilder;
  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilder;
  basePath(path: string): ClientBuilder;
  build() /*throws*/ : Promise<Client>;
  disableAutomaticTokenRefresh(): ClientBuilder;
  disableSslVerification(): ClientBuilder;
  enableCrossProcessRefreshLock(
    processId: string,
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilder;
  homeserverUrl(url: string): ClientBuilder;
  passphrase(passphrase: string | undefined): ClientBuilder;
  proxy(url: string): ClientBuilder;
  serverName(serverName: string): ClientBuilder;
  serverNameOrHomeserverUrl(serverNameOrUrl: string): ClientBuilder;
  serverVersions(versions: string[]): ClientBuilder;
  setSessionDelegate(sessionDelegate: ClientSessionDelegate): ClientBuilder;
  slidingSyncProxy(slidingSyncProxy: string | undefined): ClientBuilder;
  userAgent(userAgent: string): ClientBuilder;
  username(username: string): ClientBuilder;
}

export class ClientBuilder
  implements ClientBuilderInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  constructor() {
    this.pointer = rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(
        callStatus
      );
    });
  }

  public addRootCertificates(certificates: ArrayBuffer[]): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
          this.uniffiClonePointer(),
          FfiConverterArrayArrayBuffer.lower(certificates),
          callStatus
        );
      })
    );
  }

  /**
   * Automatically create a backup version if no backup exists.
   */
  public autoEnableBackups(autoEnableBackups: boolean): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(autoEnableBackups),
          callStatus
        );
      })
    );
  }

  public autoEnableCrossSigning(
    autoEnableCrossSigning: boolean
  ): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
          this.uniffiClonePointer(),
          FfiConverterBool.lower(autoEnableCrossSigning),
          callStatus
        );
      })
    );
  }

  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  public backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
          this.uniffiClonePointer(),
          FfiConverterTypeBackupDownloadStrategy.lower(backupDownloadStrategy),
          callStatus
        );
      })
    );
  }

  public basePath(path: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_base_path(
          this.uniffiClonePointer(),
          FfiConverterString.lower(path),
          callStatus
        );
      })
    );
  }

  public async build(): Promise<Client> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeClient.lift,
      errorHandler: FfiConverterTypeClientBuildError.lift,
    });
  }

  public disableAutomaticTokenRefresh(): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public disableSslVerification(): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public enableCrossProcessRefreshLock(
    processId: string,
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_cross_process_refresh_lock(
          this.uniffiClonePointer(),
          FfiConverterString.lower(processId),
          FfiConverterTypeClientSessionDelegate.lower(sessionDelegate),
          callStatus
        );
      })
    );
  }

  public homeserverUrl(url: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          callStatus
        );
      })
    );
  }

  public passphrase(passphrase: string | undefined): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_passphrase(
          this.uniffiClonePointer(),
          FfiConverterOptionalString.lower(passphrase),
          callStatus
        );
      })
    );
  }

  public proxy(url: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          callStatus
        );
      })
    );
  }

  public serverName(serverName: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
          this.uniffiClonePointer(),
          FfiConverterString.lower(serverName),
          callStatus
        );
      })
    );
  }

  public serverNameOrHomeserverUrl(serverNameOrUrl: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
          this.uniffiClonePointer(),
          FfiConverterString.lower(serverNameOrUrl),
          callStatus
        );
      })
    );
  }

  public serverVersions(versions: string[]): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_versions(
          this.uniffiClonePointer(),
          FfiConverterArrayString.lower(versions),
          callStatus
        );
      })
    );
  }

  public setSessionDelegate(
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
          this.uniffiClonePointer(),
          FfiConverterTypeClientSessionDelegate.lower(sessionDelegate),
          callStatus
        );
      })
    );
  }

  public slidingSyncProxy(slidingSyncProxy: string | undefined): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_proxy(
          this.uniffiClonePointer(),
          FfiConverterOptionalString.lower(slidingSyncProxy),
          callStatus
        );
      })
    );
  }

  public userAgent(userAgent: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userAgent),
          callStatus
        );
      })
    );
  }

  public username(username: string): ClientBuilder {
    return FfiConverterTypeClientBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
          this.uniffiClonePointer(),
          FfiConverterString.lower(username),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_clientbuilder(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(
        this.pointer,
        callStatus
      )
    );
  }
}

function createClientBuilder(pointer: UnsafeMutableRawPointer): ClientBuilder {
  const instance = Object.create(ClientBuilder.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeClientBuilder = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = ClientBuilder;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createClientBuilder(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for NotificationSettingsDelegate | undefined
const FfiConverterOptionalTypeNotificationSettingsDelegate =
  new FfiConverterOptional(FfiConverterTypeNotificationSettingsDelegate);

// FfiConverter for RoomMember[]
const FfiConverterArrayTypeRoomMember = new FfiConverterArray(
  FfiConverterTypeRoomMember
);

// Enum: PusherKind
export enum PusherKindKind {
  HTTP = 'Http',
  EMAIL = 'Email',
}
export type PusherKind =
  | { kind: PusherKindKind.HTTP; value: { data: HttpPusherData } }
  | { kind: PusherKindKind.EMAIL };

// FfiConverter for enum PusherKind
const FfiConverterTypePusherKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PusherKind;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: PusherKindKind.HTTP,
            value: {
              data: FfiConverterTypeHttpPusherData.read(from),
            },
          };
        case 2:
          return { kind: PusherKindKind.EMAIL };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case PusherKindKind.HTTP: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterTypeHttpPusherData.write(inner.data, into);
          return;
        }
        case PusherKindKind.EMAIL: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that PusherKindKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case PusherKindKind.HTTP: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeHttpPusherData.allocationSize(inner.data);
          return size;
        }
        case PusherKindKind.EMAIL: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The data required to authenticate against an OIDC server.
 */
export interface OidcAuthenticationDataInterface {
  /**
   * The login URL to use for authentication.
   */
  loginUrl(): string;
}

/**
 * The data required to authenticate against an OIDC server.
 */
export class OidcAuthenticationData
  implements OidcAuthenticationDataInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * The login URL to use for authentication.
   */
  public loginUrl(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_oidcauthenticationdata_login_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_oidcauthenticationdata(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_oidcauthenticationdata(
        this.pointer,
        callStatus
      )
    );
  }
}

function createOidcAuthenticationData(
  pointer: UnsafeMutableRawPointer
): OidcAuthenticationData {
  const instance = Object.create(OidcAuthenticationData.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeOidcAuthenticationData = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = OidcAuthenticationData;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createOidcAuthenticationData(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: SessionVerificationData
export enum SessionVerificationDataKind {
  EMOJIS = 'Emojis',
  DECIMALS = 'Decimals',
}
export type SessionVerificationData =
  | {
      kind: SessionVerificationDataKind.EMOJIS;
      value: { emojis: SessionVerificationEmoji[]; indices: ArrayBuffer };
    }
  | {
      kind: SessionVerificationDataKind.DECIMALS;
      value: { values: /*u16*/ number[] };
    };

// FfiConverter for enum SessionVerificationData
const FfiConverterTypeSessionVerificationData = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SessionVerificationData;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: SessionVerificationDataKind.EMOJIS,
            value: {
              emojis: FfiConverterArrayTypeSessionVerificationEmoji.read(from),
              indices: FfiConverterArrayBuffer.read(from),
            },
          };
        case 2:
          return {
            kind: SessionVerificationDataKind.DECIMALS,
            value: {
              values: FfiConverterArrayUInt16.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case SessionVerificationDataKind.EMOJIS: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterArrayTypeSessionVerificationEmoji.write(
            inner.emojis,
            into
          );
          FfiConverterArrayBuffer.write(inner.indices, into);
          return;
        }
        case SessionVerificationDataKind.DECIMALS: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterArrayUInt16.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that SessionVerificationDataKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case SessionVerificationDataKind.EMOJIS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeSessionVerificationEmoji.allocationSize(
            inner.emojis
          );
          size += FfiConverterArrayBuffer.allocationSize(inner.indices);
          return size;
        }
        case SessionVerificationDataKind.DECIMALS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayUInt16.allocationSize(inner.values);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListEntry
export enum RoomListEntryKind {
  EMPTY = 'Empty',
  INVALIDATED = 'Invalidated',
  FILLED = 'Filled',
}
export type RoomListEntry =
  | { kind: RoomListEntryKind.EMPTY }
  | { kind: RoomListEntryKind.INVALIDATED; value: { roomId: string } }
  | { kind: RoomListEntryKind.FILLED; value: { roomId: string } };

// FfiConverter for enum RoomListEntry
const FfiConverterTypeRoomListEntry = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntry;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: RoomListEntryKind.EMPTY };
        case 2:
          return {
            kind: RoomListEntryKind.INVALIDATED,
            value: {
              roomId: FfiConverterString.read(from),
            },
          };
        case 3:
          return {
            kind: RoomListEntryKind.FILLED,
            value: {
              roomId: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomListEntryKind.EMPTY: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomListEntryKind.INVALIDATED: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        case RoomListEntryKind.FILLED: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntryKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomListEntryKind.EMPTY: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomListEntryKind.INVALIDATED: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        case RoomListEntryKind.FILLED: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomListServiceSyncIndicator {
  SHOW,
  HIDE,
}

const FfiConverterTypeRoomListServiceSyncIndicator = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceSyncIndicator;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceSyncIndicator.SHOW;
        case 2:
          return RoomListServiceSyncIndicator.HIDE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceSyncIndicator.SHOW:
          return ordinalConverter.write(1, into);
        case RoomListServiceSyncIndicator.HIDE:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for MatrixEntity | undefined
const FfiConverterOptionalTypeMatrixEntity = new FfiConverterOptional(
  FfiConverterTypeMatrixEntity
);

export interface TimelineItemInterface {
  asEvent(): EventTimelineItem | undefined;
  asVirtual(): VirtualTimelineItem | undefined;
  fmtDebug(): string;
  uniqueId(): string;
}

export class TimelineItem
  implements TimelineItemInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public asEvent(): EventTimelineItem | undefined {
    return FfiConverterOptionalTypeEventTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public asVirtual(): VirtualTimelineItem | undefined {
    return FfiConverterOptionalTypeVirtualTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public fmtDebug(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public uniqueId(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timelineitem(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timelineitem(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimelineItem(pointer: UnsafeMutableRawPointer): TimelineItem {
  const instance = Object.create(TimelineItem.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimelineItem = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TimelineItem;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimelineItem(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export class RoomListException extends Error {
  private constructor(message: string) {
    super(message);
  }
  // non-flat errors aren't implemented yet.
}

const FfiConverterTypeRoomListError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = RoomListException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        // non-flat errors aren't implement yet.

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      throw new Error('Method not implemented.');
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export enum RoomListFilterCategory {
  GROUP,
  PEOPLE,
}

const FfiConverterTypeRoomListFilterCategory = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListFilterCategory;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListFilterCategory.GROUP;
        case 2:
          return RoomListFilterCategory.PEOPLE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListFilterCategory.GROUP:
          return ordinalConverter.write(1, into);
        case RoomListFilterCategory.PEOPLE:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export interface ClientInterface {
  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  accountData(eventType: string) /*throws*/ : Promise<string | undefined>;
  accountUrl(
    action: AccountManagementAction | undefined
  ) /*throws*/ : Promise<string | undefined>;
  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  avatarUrl() /*throws*/ : Promise<string | undefined>;
  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  cachedAvatarUrl() /*throws*/ : string | undefined;
  createRoom(request: CreateRoomParameters) /*throws*/ : Promise<string>;
  /**
   * Deletes a pusher of given pusher ids
   */
  deletePusher(identifiers: PusherIdentifiers) /*throws*/ : Promise<void>;
  deviceId() /*throws*/ : string;
  displayName() /*throws*/ : Promise<string>;
  encryption(): Encryption;
  getDmRoom(userId: string) /*throws*/ : Room | undefined;
  getMediaContent(mediaSource: MediaSource) /*throws*/ : Promise<ArrayBuffer>;
  getMediaFile(
    mediaSource: MediaSource,
    body: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined
  ) /*throws*/ : Promise<MediaFileHandle>;
  getMediaThumbnail(
    mediaSource: MediaSource,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint
  ) /*throws*/ : Promise<ArrayBuffer>;
  getNotificationSettings(): NotificationSettings;
  getProfile(userId: string) /*throws*/ : Promise<UserProfile>;
  getRecentlyVisitedRooms() /*throws*/ : Promise<string[]>;
  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  getRoomPreviewFromRoomAlias(
    roomAlias: string
  ) /*throws*/ : Promise<RoomPreview>;
  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: string[]
  ) /*throws*/ : Promise<RoomPreview>;
  getSessionVerificationController() /*throws*/ : Promise<SessionVerificationController>;
  /**
   * The homeserver this client is configured to use.
   */
  homeserver(): string;
  ignoreUser(userId: string) /*throws*/ : Promise<void>;
  ignoredUsers() /*throws*/ : Promise<string[]>;
  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  joinRoomById(roomId: string) /*throws*/ : Promise<Room>;
  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: string[]
  ) /*throws*/ : Promise<Room>;
  /**
   * Login using a username and password.
   */
  login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined
  ) /*throws*/ : Promise<void>;
  /**
   * Log out the current user. This method returns an optional URL that
   * should be presented to the user to complete logout (in the case of
   * Session having been authenticated using OIDC).
   */
  logout() /*throws*/ : Promise<string | undefined>;
  notificationClient(
    processSetup: NotificationProcessSetup
  ) /*throws*/ : Promise<NotificationClient>;
  removeAvatar() /*throws*/ : Promise<void>;
  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  resolveRoomAlias(roomAlias: string) /*throws*/ : Promise<ResolvedRoomAlias>;
  /**
   * Restores the client from a `Session`.
   */
  restoreSession(session: Session) /*throws*/ : Promise<void>;
  roomDirectorySearch(): RoomDirectorySearch;
  rooms(): Room[];
  searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint
  ) /*throws*/ : Promise<SearchUsersResults>;
  session() /*throws*/ : Promise<Session>;
  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  setAccountData(eventType: string, content: string) /*throws*/ : Promise<void>;
  setDelegate(delegate: ClientDelegate | undefined): TaskHandle | undefined;
  setDisplayName(name: string) /*throws*/ : Promise<void>;
  /**
   * Registers a pusher with given parameters
   */
  setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string
  ) /*throws*/ : Promise<void>;
  subscribeToIgnoredUsers(listener: IgnoredUsersListener): TaskHandle;
  syncService(): SyncServiceBuilder;
  trackRecentlyVisitedRoom(room: string) /*throws*/ : Promise<void>;
  unignoreUser(userId: string) /*throws*/ : Promise<void>;
  uploadAvatar(mimeType: string, data: ArrayBuffer) /*throws*/ : Promise<void>;
  uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : Promise<string>;
  userId() /*throws*/ : string;
}

export class Client implements ClientInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  public async accountData(
    eventType: string
  ): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_account_data(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventType)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async accountUrl(
    action: AccountManagementAction | undefined
  ): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_account_url(
          this.uniffiClonePointer(),
          FfiConverterOptionalTypeAccountManagementAction.lower(action)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  public async avatarUrl(): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  public cachedAvatarUrl(): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async createRoom(
    request: CreateRoomParameters
  ): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_create_room(
          this.uniffiClonePointer(),
          FfiConverterTypeCreateRoomParameters.lower(request)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Deletes a pusher of given pusher ids
   */
  public async deletePusher(
    identifiers: PusherIdentifiers
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
          this.uniffiClonePointer(),
          FfiConverterTypePusherIdentifiers.lower(identifiers)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public deviceId(): string /*throws*/ {
    return FfiConverterString.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_device_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async displayName(): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_display_name(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public encryption(): Encryption {
    return FfiConverterTypeEncryption.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_encryption(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public getDmRoom(userId: string): Room | undefined /*throws*/ {
    return FfiConverterOptionalTypeRoom.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId),
          callStatus
        );
      })
    );
  }

  public async getMediaContent(
    mediaSource: MediaSource
  ): Promise<ArrayBuffer> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
          this.uniffiClonePointer(),
          FfiConverterTypeMediaSource.lower(mediaSource)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterArrayBuffer.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getMediaFile(
    mediaSource: MediaSource,
    body: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined
  ): Promise<MediaFileHandle> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
          this.uniffiClonePointer(),
          FfiConverterTypeMediaSource.lower(mediaSource),
          FfiConverterOptionalString.lower(body),
          FfiConverterString.lower(mimeType),
          FfiConverterBool.lower(useCache),
          FfiConverterOptionalString.lower(tempDir)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeMediaFileHandle.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getMediaThumbnail(
    mediaSource: MediaSource,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint
  ): Promise<ArrayBuffer> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
          this.uniffiClonePointer(),
          FfiConverterTypeMediaSource.lower(mediaSource),
          FfiConverterUInt64.lower(width),
          FfiConverterUInt64.lower(height)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterArrayBuffer.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public getNotificationSettings(): NotificationSettings {
    return FfiConverterTypeNotificationSettings.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async getProfile(userId: string): Promise<UserProfile> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeUserProfile.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getRecentlyVisitedRooms(): Promise<string[]> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterArrayString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  public async getRoomPreviewFromRoomAlias(
    roomAlias: string
  ): Promise<RoomPreview> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomAlias)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomPreview.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  public async getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: string[]
  ): Promise<RoomPreview> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId),
          FfiConverterArrayString.lower(viaServers)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomPreview.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getSessionVerificationController(): Promise<SessionVerificationController> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeSessionVerificationController.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * The homeserver this client is configured to use.
   */
  public homeserver(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async ignoreUser(userId: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async ignoredUsers(): Promise<string[]> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterArrayString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  public async joinRoomById(roomId: string): Promise<Room> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoom.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  public async joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: string[]
  ): Promise<Room> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomIdOrAlias),
          FfiConverterArrayString.lower(serverNames)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoom.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Login using a username and password.
   */
  public async login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_login(
          this.uniffiClonePointer(),
          FfiConverterString.lower(username),
          FfiConverterString.lower(password),
          FfiConverterOptionalString.lower(initialDeviceName),
          FfiConverterOptionalString.lower(deviceId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Log out the current user. This method returns an optional URL that
   * should be presented to the user to complete logout (in the case of
   * Session having been authenticated using OIDC).
   */
  public async logout(): Promise<string | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_logout(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async notificationClient(
    processSetup: NotificationProcessSetup
  ): Promise<NotificationClient> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
          this.uniffiClonePointer(),
          FfiConverterTypeNotificationProcessSetup.lower(processSetup)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeNotificationClient.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async removeAvatar(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  public async resolveRoomAlias(
    roomAlias: string
  ): Promise<ResolvedRoomAlias> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomAlias)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeResolvedRoomAlias.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Restores the client from a `Session`.
   */
  public async restoreSession(session: Session): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
          this.uniffiClonePointer(),
          FfiConverterTypeSession.lower(session)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public roomDirectorySearch(): RoomDirectorySearch {
    return FfiConverterTypeRoomDirectorySearch.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public rooms(): Room[] {
    return FfiConverterArrayTypeRoom.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_rooms(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint
  ): Promise<SearchUsersResults> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_search_users(
          this.uniffiClonePointer(),
          FfiConverterString.lower(searchTerm),
          FfiConverterUInt64.lower(limit)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeSearchUsersResults.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async session(): Promise<Session> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_session(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeSession.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  public async setAccountData(
    eventType: string,
    content: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventType),
          FfiConverterString.lower(content)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public setDelegate(
    delegate: ClientDelegate | undefined
  ): TaskHandle | undefined {
    return FfiConverterOptionalTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
          this.uniffiClonePointer(),
          FfiConverterOptionalTypeClientDelegate.lower(delegate),
          callStatus
        );
      })
    );
  }

  public async setDisplayName(name: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
          this.uniffiClonePointer(),
          FfiConverterString.lower(name)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Registers a pusher with given parameters
   */
  public async setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
          this.uniffiClonePointer(),
          FfiConverterTypePusherIdentifiers.lower(identifiers),
          FfiConverterTypePusherKind.lower(kind),
          FfiConverterString.lower(appDisplayName),
          FfiConverterString.lower(deviceDisplayName),
          FfiConverterOptionalString.lower(profileTag),
          FfiConverterString.lower(lang)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public subscribeToIgnoredUsers(listener: IgnoredUsersListener): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
          this.uniffiClonePointer(),
          FfiConverterTypeIgnoredUsersListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public syncService(): SyncServiceBuilder {
    return FfiConverterTypeSyncServiceBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async trackRecentlyVisitedRoom(
    room: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
          this.uniffiClonePointer(),
          FfiConverterString.lower(room)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async unignoreUser(userId: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
          this.uniffiClonePointer(),
          FfiConverterString.lower(userId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
          this.uniffiClonePointer(),
          FfiConverterString.lower(mimeType),
          FfiConverterArrayBuffer.lower(data)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined
  ): Promise<string> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
          this.uniffiClonePointer(),
          FfiConverterString.lower(mimeType),
          FfiConverterArrayBuffer.lower(data),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterString.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public userId(): string /*throws*/ {
    return FfiConverterString.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_client_user_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_client(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_client(
        this.pointer,
        callStatus
      )
    );
  }
}

function createClient(pointer: UnsafeMutableRawPointer): Client {
  const instance = Object.create(Client.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeClient = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Client;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createClient(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: EnableRecoveryProgress
export enum EnableRecoveryProgressKind {
  STARTING = 'Starting',
  CREATING_BACKUP = 'CreatingBackup',
  CREATING_RECOVERY_KEY = 'CreatingRecoveryKey',
  BACKING_UP = 'BackingUp',
  ROOM_KEY_UPLOAD_ERROR = 'RoomKeyUploadError',
  DONE = 'Done',
}
export type EnableRecoveryProgress =
  | { kind: EnableRecoveryProgressKind.STARTING }
  | { kind: EnableRecoveryProgressKind.CREATING_BACKUP }
  | { kind: EnableRecoveryProgressKind.CREATING_RECOVERY_KEY }
  | {
      kind: EnableRecoveryProgressKind.BACKING_UP;
      value: { backedUpCount: /*u32*/ number; totalCount: /*u32*/ number };
    }
  | { kind: EnableRecoveryProgressKind.ROOM_KEY_UPLOAD_ERROR }
  | { kind: EnableRecoveryProgressKind.DONE; value: { recoveryKey: string } };

// FfiConverter for enum EnableRecoveryProgress
const FfiConverterTypeEnableRecoveryProgress = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EnableRecoveryProgress;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: EnableRecoveryProgressKind.STARTING };
        case 2:
          return { kind: EnableRecoveryProgressKind.CREATING_BACKUP };
        case 3:
          return { kind: EnableRecoveryProgressKind.CREATING_RECOVERY_KEY };
        case 4:
          return {
            kind: EnableRecoveryProgressKind.BACKING_UP,
            value: {
              backedUpCount: FfiConverterUInt32.read(from),
              totalCount: FfiConverterUInt32.read(from),
            },
          };
        case 5:
          return { kind: EnableRecoveryProgressKind.ROOM_KEY_UPLOAD_ERROR };
        case 6:
          return {
            kind: EnableRecoveryProgressKind.DONE,
            value: {
              recoveryKey: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case EnableRecoveryProgressKind.STARTING: {
          ordinalConverter.write(1, into);
          return;
        }
        case EnableRecoveryProgressKind.CREATING_BACKUP: {
          ordinalConverter.write(2, into);
          return;
        }
        case EnableRecoveryProgressKind.CREATING_RECOVERY_KEY: {
          ordinalConverter.write(3, into);
          return;
        }
        case EnableRecoveryProgressKind.BACKING_UP: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case EnableRecoveryProgressKind.ROOM_KEY_UPLOAD_ERROR: {
          ordinalConverter.write(5, into);
          return;
        }
        case EnableRecoveryProgressKind.DONE: {
          ordinalConverter.write(6, into);
          const inner = value.value;
          FfiConverterString.write(inner.recoveryKey, into);
          return;
        }
        default:
          // Throwing from here means that EnableRecoveryProgressKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case EnableRecoveryProgressKind.STARTING: {
          return ordinalConverter.allocationSize(1);
        }
        case EnableRecoveryProgressKind.CREATING_BACKUP: {
          return ordinalConverter.allocationSize(2);
        }
        case EnableRecoveryProgressKind.CREATING_RECOVERY_KEY: {
          return ordinalConverter.allocationSize(3);
        }
        case EnableRecoveryProgressKind.BACKING_UP: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case EnableRecoveryProgressKind.ROOM_KEY_UPLOAD_ERROR: {
          return ordinalConverter.allocationSize(5);
        }
        case EnableRecoveryProgressKind.DONE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.recoveryKey);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RepliedToEventDetails
export enum RepliedToEventDetailsKind {
  UNAVAILABLE = 'Unavailable',
  PENDING = 'Pending',
  READY = 'Ready',
  ERROR = 'Error',
}
export type RepliedToEventDetails =
  | { kind: RepliedToEventDetailsKind.UNAVAILABLE }
  | { kind: RepliedToEventDetailsKind.PENDING }
  | {
      kind: RepliedToEventDetailsKind.READY;
      value: {
        content: TimelineItemContent;
        sender: string;
        senderProfile: ProfileDetails;
      };
    }
  | { kind: RepliedToEventDetailsKind.ERROR; value: { message: string } };

// FfiConverter for enum RepliedToEventDetails
const FfiConverterTypeRepliedToEventDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RepliedToEventDetails;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: RepliedToEventDetailsKind.UNAVAILABLE };
        case 2:
          return { kind: RepliedToEventDetailsKind.PENDING };
        case 3:
          return {
            kind: RepliedToEventDetailsKind.READY,
            value: {
              content: FfiConverterTypeTimelineItemContent.read(from),
              sender: FfiConverterString.read(from),
              senderProfile: FfiConverterTypeProfileDetails.read(from),
            },
          };
        case 4:
          return {
            kind: RepliedToEventDetailsKind.ERROR,
            value: {
              message: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RepliedToEventDetailsKind.UNAVAILABLE: {
          ordinalConverter.write(1, into);
          return;
        }
        case RepliedToEventDetailsKind.PENDING: {
          ordinalConverter.write(2, into);
          return;
        }
        case RepliedToEventDetailsKind.READY: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterTypeTimelineItemContent.write(inner.content, into);
          FfiConverterString.write(inner.sender, into);
          FfiConverterTypeProfileDetails.write(inner.senderProfile, into);
          return;
        }
        case RepliedToEventDetailsKind.ERROR: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that RepliedToEventDetailsKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RepliedToEventDetailsKind.UNAVAILABLE: {
          return ordinalConverter.allocationSize(1);
        }
        case RepliedToEventDetailsKind.PENDING: {
          return ordinalConverter.allocationSize(2);
        }
        case RepliedToEventDetailsKind.READY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTimelineItemContent.allocationSize(
            inner.content
          );
          size += FfiConverterString.allocationSize(inner.sender);
          size += FfiConverterTypeProfileDetails.allocationSize(
            inner.senderProfile
          );
          return size;
        }
        case RepliedToEventDetailsKind.ERROR: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RecoveryState {
  UNKNOWN,
  ENABLED,
  DISABLED,
  INCOMPLETE,
}

const FfiConverterTypeRecoveryState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RecoveryState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RecoveryState.UNKNOWN;
        case 2:
          return RecoveryState.ENABLED;
        case 3:
          return RecoveryState.DISABLED;
        case 4:
          return RecoveryState.INCOMPLETE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RecoveryState.UNKNOWN:
          return ordinalConverter.write(1, into);
        case RecoveryState.ENABLED:
          return ordinalConverter.write(2, into);
        case RecoveryState.DISABLED:
          return ordinalConverter.write(3, into);
        case RecoveryState.INCOMPLETE:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for RoomSubscription | undefined
const FfiConverterOptionalTypeRoomSubscription = new FfiConverterOptional(
  FfiConverterTypeRoomSubscription
);

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export interface TaskHandleInterface {
  cancel(): void;
  /**
   * Check whether the handle is finished.
   */
  isFinished(): boolean;
}

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export class TaskHandle implements TaskHandleInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public cancel(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  /**
   * Check whether the handle is finished.
   */
  public isFinished(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_taskhandle(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_taskhandle(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTaskHandle(pointer: UnsafeMutableRawPointer): TaskHandle {
  const instance = Object.create(TaskHandle.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTaskHandle = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TaskHandle;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTaskHandle(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface TimelineInterface {
  addListener(listener: TimelineListener): Promise<RoomTimelineListenerResult>;
  cancelSend(txnId: string): void;
  createPoll(
    question: string,
    answers: string[],
    maxSelections: /*u8*/ number,
    pollKind: PollKind
  ) /*throws*/ : void;
  edit(
    newContent: RoomMessageEventContentWithoutRelation,
    editItem: EventTimelineItem
  ) /*throws*/ : Promise<void>;
  editPoll(
    question: string,
    answers: string[],
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    editItem: EventTimelineItem
  ) /*throws*/ : Promise<void>;
  endPoll(pollStartId: string, text: string) /*throws*/ : void;
  fetchDetailsForEvent(eventId: string) /*throws*/ : Promise<void>;
  fetchMembers(): Promise<void>;
  /**
   * Paginate forwards, when in focused mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  focusedPaginateForwards(
    numEvents: /*u16*/ number
  ) /*throws*/ : Promise<boolean>;
  getEventTimelineItemByEventId(
    eventId: string
  ) /*throws*/ : Promise<EventTimelineItem>;
  getTimelineEventContentByEventId(
    eventId: string
  ) /*throws*/ : Promise<RoomMessageEventContentWithoutRelation>;
  latestEvent(): Promise<EventTimelineItem | undefined>;
  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  markAsRead(receiptType: ReceiptType) /*throws*/ : Promise<void>;
  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  paginateBackwards(numEvents: /*u16*/ number) /*throws*/ : Promise<boolean>;
  retryDecryption(sessionIds: string[]): void;
  retrySend(txnId: string): void;
  send(msg: RoomMessageEventContentWithoutRelation): void;
  sendAudio(
    url: string,
    audioInfo: AudioInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle;
  sendFile(
    url: string,
    fileInfo: FileInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle;
  sendImage(
    url: string,
    thumbnailUrl: string | undefined,
    imageInfo: ImageInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle;
  sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined
  ): void;
  sendPollResponse(pollStartId: string, answers: string[]) /*throws*/ : void;
  sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string
  ) /*throws*/ : Promise<void>;
  sendReply(
    msg: RoomMessageEventContentWithoutRelation,
    replyItem: EventTimelineItem
  ) /*throws*/ : Promise<void>;
  sendVideo(
    url: string,
    thumbnailUrl: string | undefined,
    videoInfo: VideoInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle;
  sendVoiceMessage(
    url: string,
    audioInfo: AudioInfo,
    waveform: /*u16*/ number[],
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle;
  subscribeToBackPaginationStatus(
    listener: PaginationStatusListener
  ) /*throws*/ : Promise<TaskHandle>;
  toggleReaction(eventId: string, key: string) /*throws*/ : Promise<void>;
}

export class Timeline implements TimelineInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async addListener(
    listener: TimelineListener
  ): Promise<RoomTimelineListenerResult> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
          this.uniffiClonePointer(),
          FfiConverterTypeTimelineListener.lower(listener)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomTimelineListenerResult.lift,
      errorHandler: undefined,
    });
  }

  public cancelSend(txnId: string): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_cancel_send(
        this.uniffiClonePointer(),
        FfiConverterString.lower(txnId),
        callStatus
      );
    });
  }

  public createPoll(
    question: string,
    answers: string[],
    maxSelections: /*u8*/ number,
    pollKind: PollKind
  ): void /*throws*/ {
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
        this.uniffiClonePointer(),
        FfiConverterString.lower(question),
        FfiConverterArrayString.lower(answers),
        FfiConverterUInt8.lower(maxSelections),
        FfiConverterTypePollKind.lower(pollKind),
        callStatus
      );
    });
  }

  public async edit(
    newContent: RoomMessageEventContentWithoutRelation,
    editItem: EventTimelineItem
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(
            newContent
          ),
          FfiConverterTypeEventTimelineItem.lower(editItem)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async editPoll(
    question: string,
    answers: string[],
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    editItem: EventTimelineItem
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_edit_poll(
          this.uniffiClonePointer(),
          FfiConverterString.lower(question),
          FfiConverterArrayString.lower(answers),
          FfiConverterUInt8.lower(maxSelections),
          FfiConverterTypePollKind.lower(pollKind),
          FfiConverterTypeEventTimelineItem.lower(editItem)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public endPoll(pollStartId: string, text: string): void /*throws*/ {
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
        this.uniffiClonePointer(),
        FfiConverterString.lower(pollStartId),
        FfiConverterString.lower(text),
        callStatus
      );
    });
  }

  public async fetchDetailsForEvent(eventId: string): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async fetchMembers(): Promise<void> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: undefined,
    });
  }

  /**
   * Paginate forwards, when in focused mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  public async focusedPaginateForwards(
    numEvents: /*u16*/ number
  ): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_focused_paginate_forwards(
          this.uniffiClonePointer(),
          FfiConverterUInt16.lower(numEvents)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getEventTimelineItemByEventId(
    eventId: string
  ): Promise<EventTimelineItem> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeEventTimelineItem.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async getTimelineEventContentByEventId(
    eventId: string
  ): Promise<RoomMessageEventContentWithoutRelation> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_get_timeline_event_content_by_event_id(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomMessageEventContentWithoutRelation.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async latestEvent(): Promise<EventTimelineItem | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_latest_event(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalTypeEventTimelineItem.lift,
      errorHandler: undefined,
    });
  }

  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  public async markAsRead(receiptType: ReceiptType): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
          this.uniffiClonePointer(),
          FfiConverterTypeReceiptType.lower(receiptType)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  public async paginateBackwards(
    numEvents: /*u16*/ number
  ): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
          this.uniffiClonePointer(),
          FfiConverterUInt16.lower(numEvents)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public retryDecryption(sessionIds: string[]): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
        this.uniffiClonePointer(),
        FfiConverterArrayString.lower(sessionIds),
        callStatus
      );
    });
  }

  public retrySend(txnId: string): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_retry_send(
        this.uniffiClonePointer(),
        FfiConverterString.lower(txnId),
        callStatus
      );
    });
  }

  public send(msg: RoomMessageEventContentWithoutRelation): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send(
        this.uniffiClonePointer(),
        FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
        callStatus
      );
    });
  }

  public sendAudio(
    url: string,
    audioInfo: AudioInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          FfiConverterTypeAudioInfo.lower(audioInfo),
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
          callStatus
        );
      })
    );
  }

  public sendFile(
    url: string,
    fileInfo: FileInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          FfiConverterTypeFileInfo.lower(fileInfo),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
          callStatus
        );
      })
    );
  }

  public sendImage(
    url: string,
    thumbnailUrl: string | undefined,
    imageInfo: ImageInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          FfiConverterOptionalString.lower(thumbnailUrl),
          FfiConverterTypeImageInfo.lower(imageInfo),
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
          callStatus
        );
      })
    );
  }

  public sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined
  ): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
        this.uniffiClonePointer(),
        FfiConverterString.lower(body),
        FfiConverterString.lower(geoUri),
        FfiConverterOptionalString.lower(description),
        FfiConverterOptionalUInt8.lower(zoomLevel),
        FfiConverterOptionalTypeAssetType.lower(assetType),
        callStatus
      );
    });
  }

  public sendPollResponse(
    pollStartId: string,
    answers: string[]
  ): void /*throws*/ {
    rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
        this.uniffiClonePointer(),
        FfiConverterString.lower(pollStartId),
        FfiConverterArrayString.lower(answers),
        callStatus
      );
    });
  }

  public async sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
          this.uniffiClonePointer(),
          FfiConverterTypeReceiptType.lower(receiptType),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async sendReply(
    msg: RoomMessageEventContentWithoutRelation,
    replyItem: EventTimelineItem
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
          FfiConverterTypeEventTimelineItem.lower(replyItem)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public sendVideo(
    url: string,
    thumbnailUrl: string | undefined,
    videoInfo: VideoInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          FfiConverterOptionalString.lower(thumbnailUrl),
          FfiConverterTypeVideoInfo.lower(videoInfo),
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
          callStatus
        );
      })
    );
  }

  public sendVoiceMessage(
    url: string,
    audioInfo: AudioInfo,
    waveform: /*u16*/ number[],
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandle {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
          this.uniffiClonePointer(),
          FfiConverterString.lower(url),
          FfiConverterTypeAudioInfo.lower(audioInfo),
          FfiConverterArrayUInt16.lower(waveform),
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
          callStatus
        );
      })
    );
  }

  public async subscribeToBackPaginationStatus(
    listener: PaginationStatusListener
  ): Promise<TaskHandle> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
          this.uniffiClonePointer(),
          FfiConverterTypePaginationStatusListener.lower(listener)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeTaskHandle.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async toggleReaction(
    eventId: string,
    key: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
          this.uniffiClonePointer(),
          FfiConverterString.lower(eventId),
          FfiConverterString.lower(key)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timeline(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timeline(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimeline(pointer: UnsafeMutableRawPointer): Timeline {
  const instance = Object.create(Timeline.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimeline = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Timeline;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimeline(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface TimelineEventInterface {
  eventId(): string;
  eventType() /*throws*/ : TimelineEventType;
  senderId(): string;
  timestamp(): /*u64*/ bigint;
}

export class TimelineEvent
  implements TimelineEventInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public eventId(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public eventType(): TimelineEventType /*throws*/ {
    return FfiConverterTypeTimelineEventType.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public senderId(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public timestamp(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timelineevent(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timelineevent(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimelineEvent(pointer: UnsafeMutableRawPointer): TimelineEvent {
  const instance = Object.create(TimelineEvent.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimelineEvent = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TimelineEvent;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimelineEvent(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListEntriesUpdate
export enum RoomListEntriesUpdateKind {
  APPEND = 'Append',
  CLEAR = 'Clear',
  PUSH_FRONT = 'PushFront',
  PUSH_BACK = 'PushBack',
  POP_FRONT = 'PopFront',
  POP_BACK = 'PopBack',
  INSERT = 'Insert',
  SET = 'Set',
  REMOVE = 'Remove',
  TRUNCATE = 'Truncate',
  RESET = 'Reset',
}
export type RoomListEntriesUpdate =
  | {
      kind: RoomListEntriesUpdateKind.APPEND;
      value: { values: RoomListEntry[] };
    }
  | { kind: RoomListEntriesUpdateKind.CLEAR }
  | {
      kind: RoomListEntriesUpdateKind.PUSH_FRONT;
      value: { value: RoomListEntry };
    }
  | {
      kind: RoomListEntriesUpdateKind.PUSH_BACK;
      value: { value: RoomListEntry };
    }
  | { kind: RoomListEntriesUpdateKind.POP_FRONT }
  | { kind: RoomListEntriesUpdateKind.POP_BACK }
  | {
      kind: RoomListEntriesUpdateKind.INSERT;
      value: { index: /*u32*/ number; value: RoomListEntry };
    }
  | {
      kind: RoomListEntriesUpdateKind.SET;
      value: { index: /*u32*/ number; value: RoomListEntry };
    }
  | { kind: RoomListEntriesUpdateKind.REMOVE; value: { index: /*u32*/ number } }
  | {
      kind: RoomListEntriesUpdateKind.TRUNCATE;
      value: { length: /*u32*/ number };
    }
  | {
      kind: RoomListEntriesUpdateKind.RESET;
      value: { values: RoomListEntry[] };
    };

// FfiConverter for enum RoomListEntriesUpdate
const FfiConverterTypeRoomListEntriesUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesUpdate;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: RoomListEntriesUpdateKind.APPEND,
            value: {
              values: FfiConverterArrayTypeRoomListEntry.read(from),
            },
          };
        case 2:
          return { kind: RoomListEntriesUpdateKind.CLEAR };
        case 3:
          return {
            kind: RoomListEntriesUpdateKind.PUSH_FRONT,
            value: {
              value: FfiConverterTypeRoomListEntry.read(from),
            },
          };
        case 4:
          return {
            kind: RoomListEntriesUpdateKind.PUSH_BACK,
            value: {
              value: FfiConverterTypeRoomListEntry.read(from),
            },
          };
        case 5:
          return { kind: RoomListEntriesUpdateKind.POP_FRONT };
        case 6:
          return { kind: RoomListEntriesUpdateKind.POP_BACK };
        case 7:
          return {
            kind: RoomListEntriesUpdateKind.INSERT,
            value: {
              index: FfiConverterUInt32.read(from),
              value: FfiConverterTypeRoomListEntry.read(from),
            },
          };
        case 8:
          return {
            kind: RoomListEntriesUpdateKind.SET,
            value: {
              index: FfiConverterUInt32.read(from),
              value: FfiConverterTypeRoomListEntry.read(from),
            },
          };
        case 9:
          return {
            kind: RoomListEntriesUpdateKind.REMOVE,
            value: {
              index: FfiConverterUInt32.read(from),
            },
          };
        case 10:
          return {
            kind: RoomListEntriesUpdateKind.TRUNCATE,
            value: {
              length: FfiConverterUInt32.read(from),
            },
          };
        case 11:
          return {
            kind: RoomListEntriesUpdateKind.RESET,
            value: {
              values: FfiConverterArrayTypeRoomListEntry.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomListEntriesUpdateKind.APPEND: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomListEntry.write(inner.values, into);
          return;
        }
        case RoomListEntriesUpdateKind.CLEAR: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomListEntriesUpdateKind.PUSH_FRONT: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterTypeRoomListEntry.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdateKind.PUSH_BACK: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterTypeRoomListEntry.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdateKind.POP_FRONT: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesUpdateKind.POP_BACK: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesUpdateKind.INSERT: {
          ordinalConverter.write(7, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomListEntry.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdateKind.SET: {
          ordinalConverter.write(8, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomListEntry.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdateKind.REMOVE: {
          ordinalConverter.write(9, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomListEntriesUpdateKind.TRUNCATE: {
          ordinalConverter.write(10, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomListEntriesUpdateKind.RESET: {
          ordinalConverter.write(11, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomListEntry.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesUpdateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomListEntriesUpdateKind.APPEND: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomListEntry.allocationSize(
            inner.values
          );
          return size;
        }
        case RoomListEntriesUpdateKind.CLEAR: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomListEntriesUpdateKind.PUSH_FRONT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoomListEntry.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdateKind.PUSH_BACK: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoomListEntry.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdateKind.POP_FRONT: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesUpdateKind.POP_BACK: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesUpdateKind.INSERT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomListEntry.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdateKind.SET: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomListEntry.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdateKind.REMOVE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomListEntriesUpdateKind.TRUNCATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomListEntriesUpdateKind.RESET: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoomListEntry.allocationSize(
            inner.values
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomDirectorySearchEntryUpdate
export enum RoomDirectorySearchEntryUpdateKind {
  APPEND = 'Append',
  CLEAR = 'Clear',
  PUSH_FRONT = 'PushFront',
  PUSH_BACK = 'PushBack',
  POP_FRONT = 'PopFront',
  POP_BACK = 'PopBack',
  INSERT = 'Insert',
  SET = 'Set',
  REMOVE = 'Remove',
  TRUNCATE = 'Truncate',
  RESET = 'Reset',
}
export type RoomDirectorySearchEntryUpdate =
  | {
      kind: RoomDirectorySearchEntryUpdateKind.APPEND;
      value: { values: RoomDescription[] };
    }
  | { kind: RoomDirectorySearchEntryUpdateKind.CLEAR }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.PUSH_FRONT;
      value: { value: RoomDescription };
    }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.PUSH_BACK;
      value: { value: RoomDescription };
    }
  | { kind: RoomDirectorySearchEntryUpdateKind.POP_FRONT }
  | { kind: RoomDirectorySearchEntryUpdateKind.POP_BACK }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.INSERT;
      value: { index: /*u32*/ number; value: RoomDescription };
    }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.SET;
      value: { index: /*u32*/ number; value: RoomDescription };
    }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.REMOVE;
      value: { index: /*u32*/ number };
    }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.TRUNCATE;
      value: { length: /*u32*/ number };
    }
  | {
      kind: RoomDirectorySearchEntryUpdateKind.RESET;
      value: { values: RoomDescription[] };
    };

// FfiConverter for enum RoomDirectorySearchEntryUpdate
const FfiConverterTypeRoomDirectorySearchEntryUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomDirectorySearchEntryUpdate;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.APPEND,
            value: {
              values: FfiConverterArrayTypeRoomDescription.read(from),
            },
          };
        case 2:
          return { kind: RoomDirectorySearchEntryUpdateKind.CLEAR };
        case 3:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.PUSH_FRONT,
            value: {
              value: FfiConverterTypeRoomDescription.read(from),
            },
          };
        case 4:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.PUSH_BACK,
            value: {
              value: FfiConverterTypeRoomDescription.read(from),
            },
          };
        case 5:
          return { kind: RoomDirectorySearchEntryUpdateKind.POP_FRONT };
        case 6:
          return { kind: RoomDirectorySearchEntryUpdateKind.POP_BACK };
        case 7:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.INSERT,
            value: {
              index: FfiConverterUInt32.read(from),
              value: FfiConverterTypeRoomDescription.read(from),
            },
          };
        case 8:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.SET,
            value: {
              index: FfiConverterUInt32.read(from),
              value: FfiConverterTypeRoomDescription.read(from),
            },
          };
        case 9:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.REMOVE,
            value: {
              index: FfiConverterUInt32.read(from),
            },
          };
        case 10:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.TRUNCATE,
            value: {
              length: FfiConverterUInt32.read(from),
            },
          };
        case 11:
          return {
            kind: RoomDirectorySearchEntryUpdateKind.RESET,
            value: {
              values: FfiConverterArrayTypeRoomDescription.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomDirectorySearchEntryUpdateKind.APPEND: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.CLEAR: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.PUSH_FRONT: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.PUSH_BACK: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.POP_FRONT: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.POP_BACK: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.INSERT: {
          ordinalConverter.write(7, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.SET: {
          ordinalConverter.write(8, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.REMOVE: {
          ordinalConverter.write(9, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.TRUNCATE: {
          ordinalConverter.write(10, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomDirectorySearchEntryUpdateKind.RESET: {
          ordinalConverter.write(11, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomDirectorySearchEntryUpdateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomDirectorySearchEntryUpdateKind.APPEND: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.CLEAR: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomDirectorySearchEntryUpdateKind.PUSH_FRONT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.PUSH_BACK: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.POP_FRONT: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomDirectorySearchEntryUpdateKind.POP_BACK: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomDirectorySearchEntryUpdateKind.INSERT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.SET: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.REMOVE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.TRUNCATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomDirectorySearchEntryUpdateKind.RESET: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for ClientSessionDelegate | undefined
const FfiConverterOptionalTypeClientSessionDelegate = new FfiConverterOptional(
  FfiConverterTypeClientSessionDelegate
);

export class SteadyStateException extends Error {
  private constructor(message: string) {
    super(message);
  }
  static BackupDisabled = class BackupDisabled extends SteadyStateException {
    constructor(message: string) {
      super(message);
    }
  };

  static Connection = class Connection extends SteadyStateException {
    constructor(message: string) {
      super(message);
    }
  };

  static Lagged = class Lagged extends SteadyStateException {
    constructor(message: string) {
      super(message);
    }
  };
}

const FfiConverterTypeSteadyStateError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = SteadyStateException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SteadyStateException.BackupDisabled(
            stringConverter.read(from)
          );

        case 2:
          return new SteadyStateException.Connection(
            stringConverter.read(from)
          );

        case 3:
          return new SteadyStateException.Lagged(stringConverter.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      if (value instanceof SteadyStateException.BackupDisabled) {
        intConverter.write(0, into);
      } else if (value instanceof SteadyStateException.Connection) {
        intConverter.write(1, into);
      } else if (value instanceof SteadyStateException.Lagged) {
        intConverter.write(2, into);
      } else {
        throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export class NotificationSettingsException extends Error {
  private constructor(message: string) {
    super(message);
  }
  // non-flat errors aren't implemented yet.
}

const FfiConverterTypeNotificationSettingsError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = NotificationSettingsException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        // non-flat errors aren't implement yet.

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      throw new Error('Method not implemented.');
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

// Enum: ProfileDetails
export enum ProfileDetailsKind {
  UNAVAILABLE = 'Unavailable',
  PENDING = 'Pending',
  READY = 'Ready',
  ERROR = 'Error',
}
export type ProfileDetails =
  | { kind: ProfileDetailsKind.UNAVAILABLE }
  | { kind: ProfileDetailsKind.PENDING }
  | {
      kind: ProfileDetailsKind.READY;
      value: {
        displayName: string | undefined;
        displayNameAmbiguous: boolean;
        avatarUrl: string | undefined;
      };
    }
  | { kind: ProfileDetailsKind.ERROR; value: { message: string } };

// FfiConverter for enum ProfileDetails
const FfiConverterTypeProfileDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProfileDetails;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: ProfileDetailsKind.UNAVAILABLE };
        case 2:
          return { kind: ProfileDetailsKind.PENDING };
        case 3:
          return {
            kind: ProfileDetailsKind.READY,
            value: {
              displayName: FfiConverterOptionalString.read(from),
              displayNameAmbiguous: FfiConverterBool.read(from),
              avatarUrl: FfiConverterOptionalString.read(from),
            },
          };
        case 4:
          return {
            kind: ProfileDetailsKind.ERROR,
            value: {
              message: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case ProfileDetailsKind.UNAVAILABLE: {
          ordinalConverter.write(1, into);
          return;
        }
        case ProfileDetailsKind.PENDING: {
          ordinalConverter.write(2, into);
          return;
        }
        case ProfileDetailsKind.READY: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterBool.write(inner.displayNameAmbiguous, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          return;
        }
        case ProfileDetailsKind.ERROR: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that ProfileDetailsKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case ProfileDetailsKind.UNAVAILABLE: {
          return ordinalConverter.allocationSize(1);
        }
        case ProfileDetailsKind.PENDING: {
          return ordinalConverter.allocationSize(2);
        }
        case ProfileDetailsKind.READY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterBool.allocationSize(inner.displayNameAmbiguous);
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          return size;
        }
        case ProfileDetailsKind.ERROR: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface RoomListItemInterface {
  avatarUrl(): string | undefined;
  canonicalAlias(): string | undefined;
  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  displayName(): string | undefined;
  /**
   * Building a `Room`. If its internal timeline hasn't been initialized
   * it'll fail.
   */
  fullRoom() /*throws*/ : Promise<Room>;
  id(): string;
  /**
   * Initializes the timeline for this room using the provided parameters.
   *
   * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
   * used to filter timeline events besides the default timeline filter. If
   * `None` is passed, only the default timeline filter will be used.
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   */
  initTimeline(
    eventTypeFilter: TimelineEventTypeFilter | undefined,
    internalIdPrefix: string | undefined
  ) /*throws*/ : Promise<void>;
  isDirect(): boolean;
  /**
   * Checks whether the Room's timeline has been initialized before.
   */
  isTimelineInitialized(): boolean;
  latestEvent(): Promise<EventTimelineItem | undefined>;
  roomInfo() /*throws*/ : Promise<RoomInfo>;
  subscribe(settings: RoomSubscription | undefined): void;
  unsubscribe(): void;
}

export class RoomListItem
  implements RoomListItemInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public avatarUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public canonicalAlias(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  public displayName(): string | undefined {
    return FfiConverterOptionalString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_display_name(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Building a `Room`. If its internal timeline hasn't been initialized
   * it'll fail.
   */
  public async fullRoom(): Promise<Room> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoom.lift,
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  public id(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Initializes the timeline for this room using the provided parameters.
   *
   * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
   * used to filter timeline events besides the default timeline filter. If
   * `None` is passed, only the default timeline filter will be used.
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   */
  public async initTimeline(
    eventTypeFilter: TimelineEventTypeFilter | undefined,
    internalIdPrefix: string | undefined
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_init_timeline(
          this.uniffiClonePointer(),
          FfiConverterOptionalTypeTimelineEventTypeFilter.lower(
            eventTypeFilter
          ),
          FfiConverterOptionalString.lower(internalIdPrefix)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  public isDirect(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Checks whether the Room's timeline has been initialized before.
   */
  public isTimelineInitialized(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_timeline_initialized(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async latestEvent(): Promise<EventTimelineItem | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalTypeEventTimelineItem.lift,
      errorHandler: undefined,
    });
  }

  public async roomInfo(): Promise<RoomInfo> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeRoomInfo.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public subscribe(settings: RoomSubscription | undefined): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_subscribe(
        this.uniffiClonePointer(),
        FfiConverterOptionalTypeRoomSubscription.lower(settings),
        callStatus
      );
    });
  }

  public unsubscribe(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistitem_unsubscribe(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roomlistitem(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roomlistitem(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomListItem(pointer: UnsafeMutableRawPointer): RoomListItem {
  const instance = Object.create(RoomListItem.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomListItem = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomListItem;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomListItem(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export class RecoveryException extends Error {
  private constructor(message: string) {
    super(message);
  }
  // non-flat errors aren't implemented yet.
}

const FfiConverterTypeRecoveryError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = RecoveryException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        // non-flat errors aren't implement yet.

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      throw new Error('Method not implemented.');
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export enum AssetType {
  SENDER,
  PIN,
}

const FfiConverterTypeAssetType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AssetType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return AssetType.SENDER;
        case 2:
          return AssetType.PIN;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case AssetType.SENDER:
          return ordinalConverter.write(1, into);
        case AssetType.PIN:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export class ClientException extends Error {
  private constructor(message: string) {
    super(message);
  }
  // non-flat errors aren't implemented yet.
}

const FfiConverterTypeClientError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = ClientException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        // non-flat errors aren't implement yet.

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      throw new Error('Method not implemented.');
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

// FfiConverter for RoomMember | undefined
const FfiConverterOptionalTypeRoomMember = new FfiConverterOptional(
  FfiConverterTypeRoomMember
);

// FfiConverter for RoomDescription[]
const FfiConverterArrayTypeRoomDescription = new FfiConverterArray(
  FfiConverterTypeRoomDescription
);

// FfiConverter for InReplyToDetails | undefined
const FfiConverterOptionalTypeInReplyToDetails = new FfiConverterOptional(
  FfiConverterTypeInReplyToDetails
);

// FfiConverter for UserProfile[]
const FfiConverterArrayTypeUserProfile = new FfiConverterArray(
  FfiConverterTypeUserProfile
);

// FfiConverter for VideoInfo | undefined
const FfiConverterOptionalTypeVideoInfo = new FfiConverterOptional(
  FfiConverterTypeVideoInfo
);

export class ParseException extends Error {
  private constructor(message: string) {
    super(message);
  }
  static EmptyHost = class EmptyHost extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static IdnaError = class IdnaError extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidPort = class InvalidPort extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidIpv4Address = class InvalidIpv4Address extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidIpv6Address = class InvalidIpv6Address extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidDomainCharacter = class InvalidDomainCharacter extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static RelativeUrlWithoutBase = class RelativeUrlWithoutBase extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static RelativeUrlWithCannotBeABaseBase = class RelativeUrlWithCannotBeABaseBase extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static SetHostOnCannotBeABaseUrl = class SetHostOnCannotBeABaseUrl extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static Overflow = class Overflow extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };

  static Other = class Other extends ParseException {
    constructor(message: string) {
      super(message);
    }
  };
}

const FfiConverterTypeParseError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = ParseException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ParseException.EmptyHost(stringConverter.read(from));

        case 2:
          return new ParseException.IdnaError(stringConverter.read(from));

        case 3:
          return new ParseException.InvalidPort(stringConverter.read(from));

        case 4:
          return new ParseException.InvalidIpv4Address(
            stringConverter.read(from)
          );

        case 5:
          return new ParseException.InvalidIpv6Address(
            stringConverter.read(from)
          );

        case 6:
          return new ParseException.InvalidDomainCharacter(
            stringConverter.read(from)
          );

        case 7:
          return new ParseException.RelativeUrlWithoutBase(
            stringConverter.read(from)
          );

        case 8:
          return new ParseException.RelativeUrlWithCannotBeABaseBase(
            stringConverter.read(from)
          );

        case 9:
          return new ParseException.SetHostOnCannotBeABaseUrl(
            stringConverter.read(from)
          );

        case 10:
          return new ParseException.Overflow(stringConverter.read(from));

        case 11:
          return new ParseException.Other(stringConverter.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      if (value instanceof ParseException.EmptyHost) {
        intConverter.write(0, into);
      } else if (value instanceof ParseException.IdnaError) {
        intConverter.write(1, into);
      } else if (value instanceof ParseException.InvalidPort) {
        intConverter.write(2, into);
      } else if (value instanceof ParseException.InvalidIpv4Address) {
        intConverter.write(3, into);
      } else if (value instanceof ParseException.InvalidIpv6Address) {
        intConverter.write(4, into);
      } else if (value instanceof ParseException.InvalidDomainCharacter) {
        intConverter.write(5, into);
      } else if (value instanceof ParseException.RelativeUrlWithoutBase) {
        intConverter.write(6, into);
      } else if (
        value instanceof ParseException.RelativeUrlWithCannotBeABaseBase
      ) {
        intConverter.write(7, into);
      } else if (value instanceof ParseException.SetHostOnCannotBeABaseUrl) {
        intConverter.write(8, into);
      } else if (value instanceof ParseException.Overflow) {
        intConverter.write(9, into);
      } else if (value instanceof ParseException.Other) {
        intConverter.write(10, into);
      } else {
        throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export class AuthenticationException extends Error {
  private constructor(message: string) {
    super(message);
  }
  static ClientMissing = class ClientMissing extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidServerName = class InvalidServerName extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static ServerUnreachable = class ServerUnreachable extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static WellKnownLookupFailed = class WellKnownLookupFailed extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static WellKnownDeserializationError = class WellKnownDeserializationError extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static SlidingSyncNotAvailable = class SlidingSyncNotAvailable extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static SessionMissing = class SessionMissing extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static InvalidBasePath = class InvalidBasePath extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcNotSupported = class OidcNotSupported extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcMetadataMissing = class OidcMetadataMissing extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcMetadataInvalid = class OidcMetadataInvalid extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcCallbackUrlInvalid = class OidcCallbackUrlInvalid extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcCancelled = class OidcCancelled extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static OidcError = class OidcError extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };

  static Generic = class Generic extends AuthenticationException {
    constructor(message: string) {
      super(message);
    }
  };
}

const FfiConverterTypeAuthenticationError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = AuthenticationException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new AuthenticationException.ClientMissing(
            stringConverter.read(from)
          );

        case 2:
          return new AuthenticationException.InvalidServerName(
            stringConverter.read(from)
          );

        case 3:
          return new AuthenticationException.ServerUnreachable(
            stringConverter.read(from)
          );

        case 4:
          return new AuthenticationException.WellKnownLookupFailed(
            stringConverter.read(from)
          );

        case 5:
          return new AuthenticationException.WellKnownDeserializationError(
            stringConverter.read(from)
          );

        case 6:
          return new AuthenticationException.SlidingSyncNotAvailable(
            stringConverter.read(from)
          );

        case 7:
          return new AuthenticationException.SessionMissing(
            stringConverter.read(from)
          );

        case 8:
          return new AuthenticationException.InvalidBasePath(
            stringConverter.read(from)
          );

        case 9:
          return new AuthenticationException.OidcNotSupported(
            stringConverter.read(from)
          );

        case 10:
          return new AuthenticationException.OidcMetadataMissing(
            stringConverter.read(from)
          );

        case 11:
          return new AuthenticationException.OidcMetadataInvalid(
            stringConverter.read(from)
          );

        case 12:
          return new AuthenticationException.OidcCallbackUrlInvalid(
            stringConverter.read(from)
          );

        case 13:
          return new AuthenticationException.OidcCancelled(
            stringConverter.read(from)
          );

        case 14:
          return new AuthenticationException.OidcError(
            stringConverter.read(from)
          );

        case 15:
          return new AuthenticationException.Generic(
            stringConverter.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      if (value instanceof AuthenticationException.ClientMissing) {
        intConverter.write(0, into);
      } else if (value instanceof AuthenticationException.InvalidServerName) {
        intConverter.write(1, into);
      } else if (value instanceof AuthenticationException.ServerUnreachable) {
        intConverter.write(2, into);
      } else if (
        value instanceof AuthenticationException.WellKnownLookupFailed
      ) {
        intConverter.write(3, into);
      } else if (
        value instanceof AuthenticationException.WellKnownDeserializationError
      ) {
        intConverter.write(4, into);
      } else if (
        value instanceof AuthenticationException.SlidingSyncNotAvailable
      ) {
        intConverter.write(5, into);
      } else if (value instanceof AuthenticationException.SessionMissing) {
        intConverter.write(6, into);
      } else if (value instanceof AuthenticationException.InvalidBasePath) {
        intConverter.write(7, into);
      } else if (value instanceof AuthenticationException.OidcNotSupported) {
        intConverter.write(8, into);
      } else if (value instanceof AuthenticationException.OidcMetadataMissing) {
        intConverter.write(9, into);
      } else if (value instanceof AuthenticationException.OidcMetadataInvalid) {
        intConverter.write(10, into);
      } else if (
        value instanceof AuthenticationException.OidcCallbackUrlInvalid
      ) {
        intConverter.write(11, into);
      } else if (value instanceof AuthenticationException.OidcCancelled) {
        intConverter.write(12, into);
      } else if (value instanceof AuthenticationException.OidcError) {
        intConverter.write(13, into);
      } else if (value instanceof AuthenticationException.Generic) {
        intConverter.write(14, into);
      } else {
        throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

// Enum: MessageFormat
export enum MessageFormatKind {
  HTML = 'Html',
  UNKNOWN = 'Unknown',
}
export type MessageFormat =
  | { kind: MessageFormatKind.HTML }
  | { kind: MessageFormatKind.UNKNOWN; value: { format: string } };

// FfiConverter for enum MessageFormat
const FfiConverterTypeMessageFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageFormat;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: MessageFormatKind.HTML };
        case 2:
          return {
            kind: MessageFormatKind.UNKNOWN,
            value: {
              format: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case MessageFormatKind.HTML: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageFormatKind.UNKNOWN: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.format, into);
          return;
        }
        default:
          // Throwing from here means that MessageFormatKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case MessageFormatKind.HTML: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageFormatKind.UNKNOWN: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.format);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineEventType
export enum TimelineEventTypeKind {
  MESSAGE_LIKE = 'MessageLike',
  STATE = 'State',
}
export type TimelineEventType =
  | {
      kind: TimelineEventTypeKind.MESSAGE_LIKE;
      value: { content: MessageLikeEventContent };
    }
  | {
      kind: TimelineEventTypeKind.STATE;
      value: { content: StateEventContent };
    };

// FfiConverter for enum TimelineEventType
const FfiConverterTypeTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineEventType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: TimelineEventTypeKind.MESSAGE_LIKE,
            value: {
              content: FfiConverterTypeMessageLikeEventContent.read(from),
            },
          };
        case 2:
          return {
            kind: TimelineEventTypeKind.STATE,
            value: {
              content: FfiConverterTypeStateEventContent.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case TimelineEventTypeKind.MESSAGE_LIKE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterTypeMessageLikeEventContent.write(inner.content, into);
          return;
        }
        case TimelineEventTypeKind.STATE: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterTypeStateEventContent.write(inner.content, into);
          return;
        }
        default:
          // Throwing from here means that TimelineEventTypeKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case TimelineEventTypeKind.MESSAGE_LIKE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        case TimelineEventTypeKind.STATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export interface WidgetDriverInterface {
  run(
    room: Room,
    capabilitiesProvider: WidgetCapabilitiesProvider
  ): Promise<void>;
}

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export class WidgetDriver
  implements WidgetDriverInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async run(
    room: Room,
    capabilitiesProvider: WidgetCapabilitiesProvider
  ): Promise<void> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
          this.uniffiClonePointer(),
          FfiConverterTypeRoom.lower(room),
          FfiConverterTypeWidgetCapabilitiesProvider.lower(capabilitiesProvider)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: undefined,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_widgetdriver(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(
        this.pointer,
        callStatus
      )
    );
  }
}

function createWidgetDriver(pointer: UnsafeMutableRawPointer): WidgetDriver {
  const instance = Object.create(WidgetDriver.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeWidgetDriver = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = WidgetDriver;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createWidgetDriver(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface MediaSourceInterface {
  toJson(): string;
  url(): string;
}

export class MediaSource
  implements MediaSourceInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public static fromJson(json: string): MediaSource /*throws*/ {
    return FfiConverterTypeMediaSource.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
          FfiConverterString.lower(json),
          callStatus
        );
      })
    );
  }

  public toJson(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public url(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_mediasource(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_mediasource(
        this.pointer,
        callStatus
      )
    );
  }
}

function createMediaSource(pointer: UnsafeMutableRawPointer): MediaSource {
  const instance = Object.create(MediaSource.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeMediaSource = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = MediaSource;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createMediaSource(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum RoomPreset {
  /**
   * `join_rules` is set to `invite` and `history_visibility` is set to
   * `shared`.
   */
  PRIVATE_CHAT,
  /**
   * `join_rules` is set to `public` and `history_visibility` is set to
   * `shared`.
   */
  PUBLIC_CHAT,
  /**
   * Same as `PrivateChat`, but all initial invitees get the same power level
   * as the creator.
   */
  TRUSTED_PRIVATE_CHAT,
}

const FfiConverterTypeRoomPreset = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPreset;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomPreset.PRIVATE_CHAT;
        case 2:
          return RoomPreset.PUBLIC_CHAT;
        case 3:
          return RoomPreset.TRUSTED_PRIVATE_CHAT;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomPreset.PRIVATE_CHAT:
          return ordinalConverter.write(1, into);
        case RoomPreset.PUBLIC_CHAT:
          return ordinalConverter.write(2, into);
        case RoomPreset.TRUSTED_PRIVATE_CHAT:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for FileInfo | undefined
const FfiConverterOptionalTypeFileInfo = new FfiConverterOptional(
  FfiConverterTypeFileInfo
);

// FfiConverter for Reaction[]
const FfiConverterArrayTypeReaction = new FfiConverterArray(
  FfiConverterTypeReaction
);

export interface SpanInterface {
  enter(): void;
  exit(): void;
  isNone(): boolean;
}

export class Span implements SpanInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  /**
   * Create a span originating at the given callsite (file, line and column).
   *
   * The target should be something like a module path, and can be referenced
   * in the filter string given to `setup_tracing`. `level` and `target`
   * for a callsite are fixed at the first creation of a span for that
   * callsite and can not be changed afterwards, i.e. the level and
   * target passed for second and following creation of a span with the same
   * callsite will be ignored.
   *
   * This function leaks a little bit of memory for each unique (file + line
   * + level + target + name) it is called with. Please make sure that the
   * number of different combinations of those parameters this can be called
   * with is constant in the final executable.
   *
   * For a span to have an effect, you must `.enter()` it at the start of a
   * logical unit of work and `.exit()` it at the end of the same (including
   * on failure). Entering registers the span in thread-local storage, so
   * future calls to `log_event` on the same thread are able to attach the
   * events they create to the span, exiting unregisters it. For this to
   * work, exiting a span must be done on the same thread where it was
   * entered. It is possible to enter a span on multiple threads, in which
   * case it should also be exited on all of them individually; that is,
   * unless you *want* the span to be attached to all further events created
   * on that thread.
   */
  constructor(
    file: string,
    line: /*u32*/ number | undefined,
    level: LogLevel,
    target: string,
    name: string
  ) {
    this.pointer = rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(file),
        FfiConverterOptionalUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(name),
        callStatus
      );
    });
  }

  public static current(): Span {
    return FfiConverterTypeSpan.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_span_current(
          callStatus
        );
      })
    );
  }

  public enter(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_span_enter(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  public exit(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_span_exit(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  public isNone(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_span_is_none(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_span(this.pointer, callStatus);
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_span(this.pointer, callStatus)
    );
  }
}

function createSpan(pointer: UnsafeMutableRawPointer): Span {
  const instance = Object.create(Span.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSpan = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Span;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSpan(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for PowerLevels | undefined
const FfiConverterOptionalTypePowerLevels = new FfiConverterOptional(
  FfiConverterTypePowerLevels
);

export interface RoomListInterface {
  entries(listener: RoomListEntriesListener): RoomListEntriesResult;
  entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResult;
  loadingState(
    listener: RoomListLoadingStateListener
  ) /*throws*/ : RoomListLoadingStateResult;
  room(roomId: string) /*throws*/ : Promise<RoomListItem>;
}

export class RoomList implements RoomListInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public entries(listener: RoomListEntriesListener): RoomListEntriesResult {
    return FfiConverterTypeRoomListEntriesResult.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomListEntriesListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResult {
    return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
          this.uniffiClonePointer(),
          FfiConverterUInt32.lower(pageSize),
          FfiConverterTypeRoomListEntriesListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public loadingState(
    listener: RoomListLoadingStateListener
  ): RoomListLoadingStateResult /*throws*/ {
    return FfiConverterTypeRoomListLoadingStateResult.lift(
      rustCallWithError(FfiConverterTypeRoomListError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomListLoadingStateListener.lower(listener),
          callStatus
        );
      })
    );
  }

  public async room(roomId: string): Promise<RoomListItem> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeRoomListItem.lift,
      errorHandler: FfiConverterTypeRoomListError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roomlist(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roomlist(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomList(pointer: UnsafeMutableRawPointer): RoomList {
  const instance = Object.create(RoomList.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomList = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomList;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomList(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptionSystem
export enum EncryptionSystemKind {
  UNENCRYPTED = 'Unencrypted',
  PER_PARTICIPANT_KEYS = 'PerParticipantKeys',
  SHARED_SECRET = 'SharedSecret',
}
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */
export type EncryptionSystem =
  /**
   * Equivalent to the element call url parameter: `enableE2EE=false`
   */
  | { kind: EncryptionSystemKind.UNENCRYPTED }
  /**
   * Equivalent to the element call url parameter:
   * `perParticipantE2EE=true`
   */
  | { kind: EncryptionSystemKind.PER_PARTICIPANT_KEYS }
  /**
   * Equivalent to the element call url parameter:
   * `password={secret}`
   */
  | { kind: EncryptionSystemKind.SHARED_SECRET; value: { secret: string } };

// FfiConverter for enum EncryptionSystem
const FfiConverterTypeEncryptionSystem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptionSystem;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: EncryptionSystemKind.UNENCRYPTED };
        case 2:
          return { kind: EncryptionSystemKind.PER_PARTICIPANT_KEYS };
        case 3:
          return {
            kind: EncryptionSystemKind.SHARED_SECRET,
            value: {
              secret: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case EncryptionSystemKind.UNENCRYPTED: {
          ordinalConverter.write(1, into);
          return;
        }
        case EncryptionSystemKind.PER_PARTICIPANT_KEYS: {
          ordinalConverter.write(2, into);
          return;
        }
        case EncryptionSystemKind.SHARED_SECRET: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.secret, into);
          return;
        }
        default:
          // Throwing from here means that EncryptionSystemKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case EncryptionSystemKind.UNENCRYPTED: {
          return ordinalConverter.allocationSize(1);
        }
        case EncryptionSystemKind.PER_PARTICIPANT_KEYS: {
          return ordinalConverter.allocationSize(2);
        }
        case EncryptionSystemKind.SHARED_SECRET: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.secret);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for UserPowerLevelUpdate[]
const FfiConverterArrayTypeUserPowerLevelUpdate = new FfiConverterArray(
  FfiConverterTypeUserPowerLevelUpdate
);

// FfiConverter for Map<string, Receipt>
const FfiConverterMapStringTypeReceipt = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeReceipt
);

export interface RoomMembersIteratorInterface {
  len(): /*u32*/ number;
  nextChunk(chunkSize: /*u32*/ number): RoomMember[] | undefined;
}

export class RoomMembersIterator
  implements RoomMembersIteratorInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public nextChunk(chunkSize: /*u32*/ number): RoomMember[] | undefined {
    return FfiConverterOptionalArrayTypeRoomMember.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
          this.uniffiClonePointer(),
          FfiConverterUInt32.lower(chunkSize),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomMembersIterator(
  pointer: UnsafeMutableRawPointer
): RoomMembersIterator {
  const instance = Object.create(RoomMembersIterator.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomMembersIterator = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomMembersIterator;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomMembersIterator(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineItemContentKind
export enum TimelineItemContentKindKind {
  MESSAGE = 'Message',
  REDACTED_MESSAGE = 'RedactedMessage',
  STICKER = 'Sticker',
  POLL = 'Poll',
  CALL_INVITE = 'CallInvite',
  UNABLE_TO_DECRYPT = 'UnableToDecrypt',
  ROOM_MEMBERSHIP = 'RoomMembership',
  PROFILE_CHANGE = 'ProfileChange',
  STATE = 'State',
  FAILED_TO_PARSE_MESSAGE_LIKE = 'FailedToParseMessageLike',
  FAILED_TO_PARSE_STATE = 'FailedToParseState',
}
export type TimelineItemContentKind =
  | { kind: TimelineItemContentKindKind.MESSAGE }
  | { kind: TimelineItemContentKindKind.REDACTED_MESSAGE }
  | {
      kind: TimelineItemContentKindKind.STICKER;
      value: { body: string; info: ImageInfo; url: string };
    }
  | {
      kind: TimelineItemContentKindKind.POLL;
      value: {
        question: string;
        kind: PollKind;
        maxSelections: /*u64*/ bigint;
        answers: PollAnswer[];
        votes: Map<string, string[]>;
        endTime: /*u64*/ bigint | undefined;
        hasBeenEdited: boolean;
      };
    }
  | { kind: TimelineItemContentKindKind.CALL_INVITE }
  | {
      kind: TimelineItemContentKindKind.UNABLE_TO_DECRYPT;
      value: { msg: EncryptedMessage };
    }
  | {
      kind: TimelineItemContentKindKind.ROOM_MEMBERSHIP;
      value: {
        userId: string;
        userDisplayName: string | undefined;
        change: MembershipChange | undefined;
      };
    }
  | {
      kind: TimelineItemContentKindKind.PROFILE_CHANGE;
      value: {
        displayName: string | undefined;
        prevDisplayName: string | undefined;
        avatarUrl: string | undefined;
        prevAvatarUrl: string | undefined;
      };
    }
  | {
      kind: TimelineItemContentKindKind.STATE;
      value: { stateKey: string; content: OtherState };
    }
  | {
      kind: TimelineItemContentKindKind.FAILED_TO_PARSE_MESSAGE_LIKE;
      value: { eventType: string; error: string };
    }
  | {
      kind: TimelineItemContentKindKind.FAILED_TO_PARSE_STATE;
      value: { eventType: string; stateKey: string; error: string };
    };

// FfiConverter for enum TimelineItemContentKind
const FfiConverterTypeTimelineItemContentKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineItemContentKind;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: TimelineItemContentKindKind.MESSAGE };
        case 2:
          return { kind: TimelineItemContentKindKind.REDACTED_MESSAGE };
        case 3:
          return {
            kind: TimelineItemContentKindKind.STICKER,
            value: {
              body: FfiConverterString.read(from),
              info: FfiConverterTypeImageInfo.read(from),
              url: FfiConverterString.read(from),
            },
          };
        case 4:
          return {
            kind: TimelineItemContentKindKind.POLL,
            value: {
              question: FfiConverterString.read(from),
              kind: FfiConverterTypePollKind.read(from),
              maxSelections: FfiConverterUInt64.read(from),
              answers: FfiConverterArrayTypePollAnswer.read(from),
              votes: FfiConverterMapStringArrayString.read(from),
              endTime: FfiConverterOptionalUInt64.read(from),
              hasBeenEdited: FfiConverterBool.read(from),
            },
          };
        case 5:
          return { kind: TimelineItemContentKindKind.CALL_INVITE };
        case 6:
          return {
            kind: TimelineItemContentKindKind.UNABLE_TO_DECRYPT,
            value: {
              msg: FfiConverterTypeEncryptedMessage.read(from),
            },
          };
        case 7:
          return {
            kind: TimelineItemContentKindKind.ROOM_MEMBERSHIP,
            value: {
              userId: FfiConverterString.read(from),
              userDisplayName: FfiConverterOptionalString.read(from),
              change: FfiConverterOptionalTypeMembershipChange.read(from),
            },
          };
        case 8:
          return {
            kind: TimelineItemContentKindKind.PROFILE_CHANGE,
            value: {
              displayName: FfiConverterOptionalString.read(from),
              prevDisplayName: FfiConverterOptionalString.read(from),
              avatarUrl: FfiConverterOptionalString.read(from),
              prevAvatarUrl: FfiConverterOptionalString.read(from),
            },
          };
        case 9:
          return {
            kind: TimelineItemContentKindKind.STATE,
            value: {
              stateKey: FfiConverterString.read(from),
              content: FfiConverterTypeOtherState.read(from),
            },
          };
        case 10:
          return {
            kind: TimelineItemContentKindKind.FAILED_TO_PARSE_MESSAGE_LIKE,
            value: {
              eventType: FfiConverterString.read(from),
              error: FfiConverterString.read(from),
            },
          };
        case 11:
          return {
            kind: TimelineItemContentKindKind.FAILED_TO_PARSE_STATE,
            value: {
              eventType: FfiConverterString.read(from),
              stateKey: FfiConverterString.read(from),
              error: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case TimelineItemContentKindKind.MESSAGE: {
          ordinalConverter.write(1, into);
          return;
        }
        case TimelineItemContentKindKind.REDACTED_MESSAGE: {
          ordinalConverter.write(2, into);
          return;
        }
        case TimelineItemContentKindKind.STICKER: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.body, into);
          FfiConverterTypeImageInfo.write(inner.info, into);
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TimelineItemContentKindKind.POLL: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.question, into);
          FfiConverterTypePollKind.write(inner.kind, into);
          FfiConverterUInt64.write(inner.maxSelections, into);
          FfiConverterArrayTypePollAnswer.write(inner.answers, into);
          FfiConverterMapStringArrayString.write(inner.votes, into);
          FfiConverterOptionalUInt64.write(inner.endTime, into);
          FfiConverterBool.write(inner.hasBeenEdited, into);
          return;
        }
        case TimelineItemContentKindKind.CALL_INVITE: {
          ordinalConverter.write(5, into);
          return;
        }
        case TimelineItemContentKindKind.UNABLE_TO_DECRYPT: {
          ordinalConverter.write(6, into);
          const inner = value.value;
          FfiConverterTypeEncryptedMessage.write(inner.msg, into);
          return;
        }
        case TimelineItemContentKindKind.ROOM_MEMBERSHIP: {
          ordinalConverter.write(7, into);
          const inner = value.value;
          FfiConverterString.write(inner.userId, into);
          FfiConverterOptionalString.write(inner.userDisplayName, into);
          FfiConverterOptionalTypeMembershipChange.write(inner.change, into);
          return;
        }
        case TimelineItemContentKindKind.PROFILE_CHANGE: {
          ordinalConverter.write(8, into);
          const inner = value.value;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterOptionalString.write(inner.prevDisplayName, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          FfiConverterOptionalString.write(inner.prevAvatarUrl, into);
          return;
        }
        case TimelineItemContentKindKind.STATE: {
          ordinalConverter.write(9, into);
          const inner = value.value;
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterTypeOtherState.write(inner.content, into);
          return;
        }
        case TimelineItemContentKindKind.FAILED_TO_PARSE_MESSAGE_LIKE: {
          ordinalConverter.write(10, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        case TimelineItemContentKindKind.FAILED_TO_PARSE_STATE: {
          ordinalConverter.write(11, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        default:
          // Throwing from here means that TimelineItemContentKindKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case TimelineItemContentKindKind.MESSAGE: {
          return ordinalConverter.allocationSize(1);
        }
        case TimelineItemContentKindKind.REDACTED_MESSAGE: {
          return ordinalConverter.allocationSize(2);
        }
        case TimelineItemContentKindKind.STICKER: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.body);
          size += FfiConverterTypeImageInfo.allocationSize(inner.info);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TimelineItemContentKindKind.POLL: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.question);
          size += FfiConverterTypePollKind.allocationSize(inner.kind);
          size += FfiConverterUInt64.allocationSize(inner.maxSelections);
          size += FfiConverterArrayTypePollAnswer.allocationSize(inner.answers);
          size += FfiConverterMapStringArrayString.allocationSize(inner.votes);
          size += FfiConverterOptionalUInt64.allocationSize(inner.endTime);
          size += FfiConverterBool.allocationSize(inner.hasBeenEdited);
          return size;
        }
        case TimelineItemContentKindKind.CALL_INVITE: {
          return ordinalConverter.allocationSize(5);
        }
        case TimelineItemContentKindKind.UNABLE_TO_DECRYPT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeEncryptedMessage.allocationSize(inner.msg);
          return size;
        }
        case TimelineItemContentKindKind.ROOM_MEMBERSHIP: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterOptionalString.allocationSize(
            inner.userDisplayName
          );
          size += FfiConverterOptionalTypeMembershipChange.allocationSize(
            inner.change
          );
          return size;
        }
        case TimelineItemContentKindKind.PROFILE_CHANGE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevDisplayName
          );
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevAvatarUrl
          );
          return size;
        }
        case TimelineItemContentKindKind.STATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterTypeOtherState.allocationSize(inner.content);
          return size;
        }
        case TimelineItemContentKindKind.FAILED_TO_PARSE_MESSAGE_LIKE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case TimelineItemContentKindKind.FAILED_TO_PARSE_STATE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for RoomListRange[]
const FfiConverterArrayTypeRoomListRange = new FfiConverterArray(
  FfiConverterTypeRoomListRange
);

export enum PushFormat {
  EVENT_ID_ONLY,
}

const FfiConverterTypePushFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PushFormat;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PushFormat.EVENT_ID_ONLY;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PushFormat.EVENT_ID_ONLY:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for InsertData | undefined
const FfiConverterOptionalTypeInsertData = new FfiConverterOptional(
  FfiConverterTypeInsertData
);

// FfiConverter for ArrayBuffer[]
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

// FfiConverter for NotificationItem | undefined
const FfiConverterOptionalTypeNotificationItem = new FfiConverterOptional(
  FfiConverterTypeNotificationItem
);

// Enum: RoomListInput
export enum RoomListInputKind {
  VIEWPORT = 'Viewport',
}
export type RoomListInput = {
  kind: RoomListInputKind.VIEWPORT;
  value: { ranges: RoomListRange[] };
};

// FfiConverter for enum RoomListInput
const FfiConverterTypeRoomListInput = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListInput;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: RoomListInputKind.VIEWPORT,
            value: {
              ranges: FfiConverterArrayTypeRoomListRange.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomListInputKind.VIEWPORT: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomListRange.write(inner.ranges, into);
          return;
        }
        default:
          // Throwing from here means that RoomListInputKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomListInputKind.VIEWPORT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomListRange.allocationSize(
            inner.ranges
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing the push notification modes for a room.
 */
export enum RoomNotificationMode {
  /**
   * Receive notifications for all messages.
   */
  ALL_MESSAGES,
  /**
   * Receive notifications for mentions and keywords only.
   */
  MENTIONS_AND_KEYWORDS_ONLY,
  /**
   * Do not receive any notifications.
   */
  MUTE,
}

const FfiConverterTypeRoomNotificationMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomNotificationMode;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomNotificationMode.ALL_MESSAGES;
        case 2:
          return RoomNotificationMode.MENTIONS_AND_KEYWORDS_ONLY;
        case 3:
          return RoomNotificationMode.MUTE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomNotificationMode.ALL_MESSAGES:
          return ordinalConverter.write(1, into);
        case RoomNotificationMode.MENTIONS_AND_KEYWORDS_ONLY:
          return ordinalConverter.write(2, into);
        case RoomNotificationMode.MUTE:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

export interface RoomListDynamicEntriesControllerInterface {
  addOnePage(): void;
  resetToOnePage(): void;
  setFilter(kind: RoomListEntriesDynamicFilterKind): boolean;
}

export class RoomListDynamicEntriesController
  implements RoomListDynamicEntriesControllerInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public addOnePage(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  public resetToOnePage(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  public setFilter(kind: RoomListEntriesDynamicFilterKind): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomListDynamicEntriesController(
  pointer: UnsafeMutableRawPointer
): RoomListDynamicEntriesController {
  const instance = Object.create(RoomListDynamicEntriesController.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomListDynamicEntriesController = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomListDynamicEntriesController;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomListDynamicEntriesController(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface SendAttachmentJoinHandleInterface {
  cancel(): void;
  join() /*throws*/ : Promise<void>;
}

export class SendAttachmentJoinHandle
  implements SendAttachmentJoinHandleInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public cancel(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
        this.uniffiClonePointer(),
        callStatus
      );
    });
  }

  public async join(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeRoomError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(
        this.pointer,
        callStatus
      )
    );
  }
}

function createSendAttachmentJoinHandle(
  pointer: UnsafeMutableRawPointer
): SendAttachmentJoinHandle {
  const instance = Object.create(SendAttachmentJoinHandle.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSendAttachmentJoinHandle = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = SendAttachmentJoinHandle;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSendAttachmentJoinHandle(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum MembershipState {
  /**
   * The user is banned.
   */
  BAN,
  /**
   * The user has been invited.
   */
  INVITE,
  /**
   * The user has joined.
   */
  JOIN,
  /**
   * The user has requested to join.
   */
  KNOCK,
  /**
   * The user has left.
   */
  LEAVE,
}

const FfiConverterTypeMembershipState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MembershipState.BAN;
        case 2:
          return MembershipState.INVITE;
        case 3:
          return MembershipState.JOIN;
        case 4:
          return MembershipState.KNOCK;
        case 5:
          return MembershipState.LEAVE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MembershipState.BAN:
          return ordinalConverter.write(1, into);
        case MembershipState.INVITE:
          return ordinalConverter.write(2, into);
        case MembershipState.JOIN:
          return ordinalConverter.write(3, into);
        case MembershipState.KNOCK:
          return ordinalConverter.write(4, into);
        case MembershipState.LEAVE:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListLoadingState
export enum RoomListLoadingStateKind {
  NOT_LOADED = 'NotLoaded',
  LOADED = 'Loaded',
}
export type RoomListLoadingState =
  | { kind: RoomListLoadingStateKind.NOT_LOADED }
  | {
      kind: RoomListLoadingStateKind.LOADED;
      value: { maximumNumberOfRooms: /*u32*/ number | undefined };
    };

// FfiConverter for enum RoomListLoadingState
const FfiConverterTypeRoomListLoadingState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListLoadingState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: RoomListLoadingStateKind.NOT_LOADED };
        case 2:
          return {
            kind: RoomListLoadingStateKind.LOADED,
            value: {
              maximumNumberOfRooms: FfiConverterOptionalUInt32.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomListLoadingStateKind.NOT_LOADED: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomListLoadingStateKind.LOADED: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterOptionalUInt32.write(inner.maximumNumberOfRooms, into);
          return;
        }
        default:
          // Throwing from here means that RoomListLoadingStateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomListLoadingStateKind.NOT_LOADED: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomListLoadingStateKind.LOADED: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.maximumNumberOfRooms
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface AuthenticationServiceInterface {
  /**
   * Updates the service to authenticate with the homeserver for the
   * specified address.
   */
  configureHomeserver(
    serverNameOrHomeserverUrl: string
  ) /*throws*/ : Promise<void>;
  homeserverDetails(): HomeserverLoginDetails | undefined;
  /**
   * Performs a password login using the current homeserver.
   */
  login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined
  ) /*throws*/ : Promise<Client>;
  /**
   * Completes the OIDC login process.
   */
  loginWithOidcCallback(
    authenticationData: OidcAuthenticationData,
    callbackUrl: string
  ) /*throws*/ : Promise<Client>;
  /**
   * Requests the URL needed for login in a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns.
   */
  urlForOidcLogin() /*throws*/ : Promise<OidcAuthenticationData>;
}

export class AuthenticationService
  implements AuthenticationServiceInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  /**
   * Creates a new service to authenticate a user with.
   */
  constructor(
    basePath: string,
    passphrase: string | undefined,
    userAgent: string | undefined,
    additionalRootCertificates: ArrayBuffer[],
    proxy: string | undefined,
    oidcConfiguration: OidcConfiguration | undefined,
    customSlidingSyncProxy: string | undefined,
    sessionDelegate: ClientSessionDelegate | undefined,
    crossProcessRefreshLockId: string | undefined
  ) {
    this.pointer = rustCall((callStatus) => {
      return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_authenticationservice_new(
        FfiConverterString.lower(basePath),
        FfiConverterOptionalString.lower(passphrase),
        FfiConverterOptionalString.lower(userAgent),
        FfiConverterArrayArrayBuffer.lower(additionalRootCertificates),
        FfiConverterOptionalString.lower(proxy),
        FfiConverterOptionalTypeOidcConfiguration.lower(oidcConfiguration),
        FfiConverterOptionalString.lower(customSlidingSyncProxy),
        FfiConverterOptionalTypeClientSessionDelegate.lower(sessionDelegate),
        FfiConverterOptionalString.lower(crossProcessRefreshLockId),
        callStatus
      );
    });
  }

  /**
   * Updates the service to authenticate with the homeserver for the
   * specified address.
   */
  public async configureHomeserver(
    serverNameOrHomeserverUrl: string
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_authenticationservice_configure_homeserver(
          this.uniffiClonePointer(),
          FfiConverterString.lower(serverNameOrHomeserverUrl)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeAuthenticationError.lift,
    });
  }

  public homeserverDetails(): HomeserverLoginDetails | undefined {
    return FfiConverterOptionalTypeHomeserverLoginDetails.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_authenticationservice_homeserver_details(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  /**
   * Performs a password login using the current homeserver.
   */
  public async login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined
  ): Promise<Client> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_authenticationservice_login(
          this.uniffiClonePointer(),
          FfiConverterString.lower(username),
          FfiConverterString.lower(password),
          FfiConverterOptionalString.lower(initialDeviceName),
          FfiConverterOptionalString.lower(deviceId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeClient.lift,
      errorHandler: FfiConverterTypeAuthenticationError.lift,
    });
  }

  /**
   * Completes the OIDC login process.
   */
  public async loginWithOidcCallback(
    authenticationData: OidcAuthenticationData,
    callbackUrl: string
  ): Promise<Client> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_authenticationservice_login_with_oidc_callback(
          this.uniffiClonePointer(),
          FfiConverterTypeOidcAuthenticationData.lower(authenticationData),
          FfiConverterString.lower(callbackUrl)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeClient.lift,
      errorHandler: FfiConverterTypeAuthenticationError.lift,
    });
  }

  /**
   * Requests the URL needed for login in a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns.
   */
  public async urlForOidcLogin(): Promise<OidcAuthenticationData> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_authenticationservice_url_for_oidc_login(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeOidcAuthenticationData.lift,
      errorHandler: FfiConverterTypeAuthenticationError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_authenticationservice(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_authenticationservice(
        this.pointer,
        callStatus
      )
    );
  }
}

function createAuthenticationService(
  pointer: UnsafeMutableRawPointer
): AuthenticationService {
  const instance = Object.create(AuthenticationService.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeAuthenticationService = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = AuthenticationService;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createAuthenticationService(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: MessageLikeEventContent
export enum MessageLikeEventContentKind {
  CALL_ANSWER = 'CallAnswer',
  CALL_INVITE = 'CallInvite',
  CALL_HANGUP = 'CallHangup',
  CALL_CANDIDATES = 'CallCandidates',
  CALL_NOTIFY = 'CallNotify',
  KEY_VERIFICATION_READY = 'KeyVerificationReady',
  KEY_VERIFICATION_START = 'KeyVerificationStart',
  KEY_VERIFICATION_CANCEL = 'KeyVerificationCancel',
  KEY_VERIFICATION_ACCEPT = 'KeyVerificationAccept',
  KEY_VERIFICATION_KEY = 'KeyVerificationKey',
  KEY_VERIFICATION_MAC = 'KeyVerificationMac',
  KEY_VERIFICATION_DONE = 'KeyVerificationDone',
  POLL = 'Poll',
  REACTION_CONTENT = 'ReactionContent',
  ROOM_ENCRYPTED = 'RoomEncrypted',
  ROOM_MESSAGE = 'RoomMessage',
  ROOM_REDACTION = 'RoomRedaction',
  STICKER = 'Sticker',
}
export type MessageLikeEventContent =
  | { kind: MessageLikeEventContentKind.CALL_ANSWER }
  | { kind: MessageLikeEventContentKind.CALL_INVITE }
  | { kind: MessageLikeEventContentKind.CALL_HANGUP }
  | { kind: MessageLikeEventContentKind.CALL_CANDIDATES }
  | {
      kind: MessageLikeEventContentKind.CALL_NOTIFY;
      value: { notifyType: NotifyType };
    }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_READY }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_START }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_CANCEL }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_ACCEPT }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_KEY }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_MAC }
  | { kind: MessageLikeEventContentKind.KEY_VERIFICATION_DONE }
  | { kind: MessageLikeEventContentKind.POLL; value: { question: string } }
  | {
      kind: MessageLikeEventContentKind.REACTION_CONTENT;
      value: { relatedEventId: string };
    }
  | { kind: MessageLikeEventContentKind.ROOM_ENCRYPTED }
  | {
      kind: MessageLikeEventContentKind.ROOM_MESSAGE;
      value: { messageType: MessageType; inReplyToEventId: string | undefined };
    }
  | { kind: MessageLikeEventContentKind.ROOM_REDACTION }
  | { kind: MessageLikeEventContentKind.STICKER };

// FfiConverter for enum MessageLikeEventContent
const FfiConverterTypeMessageLikeEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: MessageLikeEventContentKind.CALL_ANSWER };
        case 2:
          return { kind: MessageLikeEventContentKind.CALL_INVITE };
        case 3:
          return { kind: MessageLikeEventContentKind.CALL_HANGUP };
        case 4:
          return { kind: MessageLikeEventContentKind.CALL_CANDIDATES };
        case 5:
          return {
            kind: MessageLikeEventContentKind.CALL_NOTIFY,
            value: {
              notifyType: FfiConverterTypeNotifyType.read(from),
            },
          };
        case 6:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_READY };
        case 7:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_START };
        case 8:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_CANCEL };
        case 9:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_ACCEPT };
        case 10:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_KEY };
        case 11:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_MAC };
        case 12:
          return { kind: MessageLikeEventContentKind.KEY_VERIFICATION_DONE };
        case 13:
          return {
            kind: MessageLikeEventContentKind.POLL,
            value: {
              question: FfiConverterString.read(from),
            },
          };
        case 14:
          return {
            kind: MessageLikeEventContentKind.REACTION_CONTENT,
            value: {
              relatedEventId: FfiConverterString.read(from),
            },
          };
        case 15:
          return { kind: MessageLikeEventContentKind.ROOM_ENCRYPTED };
        case 16:
          return {
            kind: MessageLikeEventContentKind.ROOM_MESSAGE,
            value: {
              messageType: FfiConverterTypeMessageType.read(from),
              inReplyToEventId: FfiConverterOptionalString.read(from),
            },
          };
        case 17:
          return { kind: MessageLikeEventContentKind.ROOM_REDACTION };
        case 18:
          return { kind: MessageLikeEventContentKind.STICKER };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case MessageLikeEventContentKind.CALL_ANSWER: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageLikeEventContentKind.CALL_INVITE: {
          ordinalConverter.write(2, into);
          return;
        }
        case MessageLikeEventContentKind.CALL_HANGUP: {
          ordinalConverter.write(3, into);
          return;
        }
        case MessageLikeEventContentKind.CALL_CANDIDATES: {
          ordinalConverter.write(4, into);
          return;
        }
        case MessageLikeEventContentKind.CALL_NOTIFY: {
          ordinalConverter.write(5, into);
          const inner = value.value;
          FfiConverterTypeNotifyType.write(inner.notifyType, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_READY: {
          ordinalConverter.write(6, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_START: {
          ordinalConverter.write(7, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_CANCEL: {
          ordinalConverter.write(8, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_ACCEPT: {
          ordinalConverter.write(9, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_KEY: {
          ordinalConverter.write(10, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_MAC: {
          ordinalConverter.write(11, into);
          return;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_DONE: {
          ordinalConverter.write(12, into);
          return;
        }
        case MessageLikeEventContentKind.POLL: {
          ordinalConverter.write(13, into);
          const inner = value.value;
          FfiConverterString.write(inner.question, into);
          return;
        }
        case MessageLikeEventContentKind.REACTION_CONTENT: {
          ordinalConverter.write(14, into);
          const inner = value.value;
          FfiConverterString.write(inner.relatedEventId, into);
          return;
        }
        case MessageLikeEventContentKind.ROOM_ENCRYPTED: {
          ordinalConverter.write(15, into);
          return;
        }
        case MessageLikeEventContentKind.ROOM_MESSAGE: {
          ordinalConverter.write(16, into);
          const inner = value.value;
          FfiConverterTypeMessageType.write(inner.messageType, into);
          FfiConverterOptionalString.write(inner.inReplyToEventId, into);
          return;
        }
        case MessageLikeEventContentKind.ROOM_REDACTION: {
          ordinalConverter.write(17, into);
          return;
        }
        case MessageLikeEventContentKind.STICKER: {
          ordinalConverter.write(18, into);
          return;
        }
        default:
          // Throwing from here means that MessageLikeEventContentKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case MessageLikeEventContentKind.CALL_ANSWER: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageLikeEventContentKind.CALL_INVITE: {
          return ordinalConverter.allocationSize(2);
        }
        case MessageLikeEventContentKind.CALL_HANGUP: {
          return ordinalConverter.allocationSize(3);
        }
        case MessageLikeEventContentKind.CALL_CANDIDATES: {
          return ordinalConverter.allocationSize(4);
        }
        case MessageLikeEventContentKind.CALL_NOTIFY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeNotifyType.allocationSize(inner.notifyType);
          return size;
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_READY: {
          return ordinalConverter.allocationSize(6);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_START: {
          return ordinalConverter.allocationSize(7);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_CANCEL: {
          return ordinalConverter.allocationSize(8);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_ACCEPT: {
          return ordinalConverter.allocationSize(9);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_KEY: {
          return ordinalConverter.allocationSize(10);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_MAC: {
          return ordinalConverter.allocationSize(11);
        }
        case MessageLikeEventContentKind.KEY_VERIFICATION_DONE: {
          return ordinalConverter.allocationSize(12);
        }
        case MessageLikeEventContentKind.POLL: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterString.allocationSize(inner.question);
          return size;
        }
        case MessageLikeEventContentKind.REACTION_CONTENT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterString.allocationSize(inner.relatedEventId);
          return size;
        }
        case MessageLikeEventContentKind.ROOM_ENCRYPTED: {
          return ordinalConverter.allocationSize(15);
        }
        case MessageLikeEventContentKind.ROOM_MESSAGE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterTypeMessageType.allocationSize(inner.messageType);
          size += FfiConverterOptionalString.allocationSize(
            inner.inReplyToEventId
          );
          return size;
        }
        case MessageLikeEventContentKind.ROOM_REDACTION: {
          return ordinalConverter.allocationSize(17);
        }
        case MessageLikeEventContentKind.STICKER: {
          return ordinalConverter.allocationSize(18);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface RoomMessageEventContentWithoutRelationInterface {
  withMentions(mentions: Mentions): RoomMessageEventContentWithoutRelation;
}

export class RoomMessageEventContentWithoutRelation
  implements
    RoomMessageEventContentWithoutRelationInterface,
    UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public withMentions(
    mentions: Mentions
  ): RoomMessageEventContentWithoutRelation {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
          this.uniffiClonePointer(),
          FfiConverterTypeMentions.lower(mentions),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomMessageEventContentWithoutRelation(
  pointer: UnsafeMutableRawPointer
): RoomMessageEventContentWithoutRelation {
  const instance = Object.create(
    RoomMessageEventContentWithoutRelation.prototype
  );
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomMessageEventContentWithoutRelation = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomMessageEventContentWithoutRelation;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomMessageEventContentWithoutRelation(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum MediaInfoError {
  MISSING_FIELD,
  INVALID_FIELD,
}

const FfiConverterTypeMediaInfoError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MediaInfoError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MediaInfoError.MISSING_FIELD;
        case 2:
          return MediaInfoError.INVALID_FIELD;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MediaInfoError.MISSING_FIELD:
          return ordinalConverter.write(1, into);
        case MediaInfoError.INVALID_FIELD:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for TracingFileConfiguration | undefined
const FfiConverterOptionalTypeTracingFileConfiguration =
  new FfiConverterOptional(FfiConverterTypeTracingFileConfiguration);

// Enum: RoomListEntriesDynamicFilterKind
export enum RoomListEntriesDynamicFilterKindKind {
  ALL = 'All',
  ANY = 'Any',
  NON_LEFT = 'NonLeft',
  JOINED = 'Joined',
  UNREAD = 'Unread',
  FAVOURITE = 'Favourite',
  INVITE = 'Invite',
  CATEGORY = 'Category',
  NONE = 'None',
  NORMALIZED_MATCH_ROOM_NAME = 'NormalizedMatchRoomName',
  FUZZY_MATCH_ROOM_NAME = 'FuzzyMatchRoomName',
}
export type RoomListEntriesDynamicFilterKind =
  | {
      kind: RoomListEntriesDynamicFilterKindKind.ALL;
      value: { filters: RoomListEntriesDynamicFilterKind[] };
    }
  | {
      kind: RoomListEntriesDynamicFilterKindKind.ANY;
      value: { filters: RoomListEntriesDynamicFilterKind[] };
    }
  | { kind: RoomListEntriesDynamicFilterKindKind.NON_LEFT }
  | { kind: RoomListEntriesDynamicFilterKindKind.JOINED }
  | { kind: RoomListEntriesDynamicFilterKindKind.UNREAD }
  | { kind: RoomListEntriesDynamicFilterKindKind.FAVOURITE }
  | { kind: RoomListEntriesDynamicFilterKindKind.INVITE }
  | {
      kind: RoomListEntriesDynamicFilterKindKind.CATEGORY;
      value: { expect: RoomListFilterCategory };
    }
  | { kind: RoomListEntriesDynamicFilterKindKind.NONE }
  | {
      kind: RoomListEntriesDynamicFilterKindKind.NORMALIZED_MATCH_ROOM_NAME;
      value: { pattern: string };
    }
  | {
      kind: RoomListEntriesDynamicFilterKindKind.FUZZY_MATCH_ROOM_NAME;
      value: { pattern: string };
    };

// FfiConverter for enum RoomListEntriesDynamicFilterKind
const FfiConverterTypeRoomListEntriesDynamicFilterKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesDynamicFilterKind;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: RoomListEntriesDynamicFilterKindKind.ALL,
            value: {
              filters:
                FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(
                  from
                ),
            },
          };
        case 2:
          return {
            kind: RoomListEntriesDynamicFilterKindKind.ANY,
            value: {
              filters:
                FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(
                  from
                ),
            },
          };
        case 3:
          return { kind: RoomListEntriesDynamicFilterKindKind.NON_LEFT };
        case 4:
          return { kind: RoomListEntriesDynamicFilterKindKind.JOINED };
        case 5:
          return { kind: RoomListEntriesDynamicFilterKindKind.UNREAD };
        case 6:
          return { kind: RoomListEntriesDynamicFilterKindKind.FAVOURITE };
        case 7:
          return { kind: RoomListEntriesDynamicFilterKindKind.INVITE };
        case 8:
          return {
            kind: RoomListEntriesDynamicFilterKindKind.CATEGORY,
            value: {
              expect: FfiConverterTypeRoomListFilterCategory.read(from),
            },
          };
        case 9:
          return { kind: RoomListEntriesDynamicFilterKindKind.NONE };
        case 10:
          return {
            kind: RoomListEntriesDynamicFilterKindKind.NORMALIZED_MATCH_ROOM_NAME,
            value: {
              pattern: FfiConverterString.read(from),
            },
          };
        case 11:
          return {
            kind: RoomListEntriesDynamicFilterKindKind.FUZZY_MATCH_ROOM_NAME,
            value: {
              pattern: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case RoomListEntriesDynamicFilterKindKind.ALL: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.ANY: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.NON_LEFT: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.JOINED: {
          ordinalConverter.write(4, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.UNREAD: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.FAVOURITE: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.INVITE: {
          ordinalConverter.write(7, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.CATEGORY: {
          ordinalConverter.write(8, into);
          const inner = value.value;
          FfiConverterTypeRoomListFilterCategory.write(inner.expect, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.NONE: {
          ordinalConverter.write(9, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.NORMALIZED_MATCH_ROOM_NAME: {
          ordinalConverter.write(10, into);
          const inner = value.value;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        case RoomListEntriesDynamicFilterKindKind.FUZZY_MATCH_ROOM_NAME: {
          ordinalConverter.write(11, into);
          const inner = value.value;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesDynamicFilterKindKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case RoomListEntriesDynamicFilterKindKind.ALL: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKindKind.ANY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKindKind.NON_LEFT: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomListEntriesDynamicFilterKindKind.JOINED: {
          return ordinalConverter.allocationSize(4);
        }
        case RoomListEntriesDynamicFilterKindKind.UNREAD: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesDynamicFilterKindKind.FAVOURITE: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesDynamicFilterKindKind.INVITE: {
          return ordinalConverter.allocationSize(7);
        }
        case RoomListEntriesDynamicFilterKindKind.CATEGORY: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeRoomListFilterCategory.allocationSize(
            inner.expect
          );
          return size;
        }
        case RoomListEntriesDynamicFilterKindKind.NONE: {
          return ordinalConverter.allocationSize(9);
        }
        case RoomListEntriesDynamicFilterKindKind.NORMALIZED_MATCH_ROOM_NAME: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        case RoomListEntriesDynamicFilterKindKind.FUZZY_MATCH_ROOM_NAME: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface SyncServiceBuilderInterface {
  finish() /*throws*/ : Promise<SyncService>;
  withCrossProcessLock(appIdentifier: string | undefined): SyncServiceBuilder;
  withUtdHook(delegate: UnableToDecryptDelegate): SyncServiceBuilder;
}

export class SyncServiceBuilder
  implements SyncServiceBuilderInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async finish(): Promise<SyncService> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeSyncService.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public withCrossProcessLock(
    appIdentifier: string | undefined
  ): SyncServiceBuilder {
    return FfiConverterTypeSyncServiceBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
          this.uniffiClonePointer(),
          FfiConverterOptionalString.lower(appIdentifier),
          callStatus
        );
      })
    );
  }

  public withUtdHook(delegate: UnableToDecryptDelegate): SyncServiceBuilder {
    return FfiConverterTypeSyncServiceBuilder.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_utd_hook(
          this.uniffiClonePointer(),
          FfiConverterTypeUnableToDecryptDelegate.lower(delegate),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(
        this.pointer,
        callStatus
      )
    );
  }
}

function createSyncServiceBuilder(
  pointer: UnsafeMutableRawPointer
): SyncServiceBuilder {
  const instance = Object.create(SyncServiceBuilder.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSyncServiceBuilder = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = SyncServiceBuilder;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSyncServiceBuilder(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationProcessSetup
export enum NotificationProcessSetupKind {
  MULTIPLE_PROCESSES = 'MultipleProcesses',
  SINGLE_PROCESS = 'SingleProcess',
}
export type NotificationProcessSetup =
  | { kind: NotificationProcessSetupKind.MULTIPLE_PROCESSES }
  | {
      kind: NotificationProcessSetupKind.SINGLE_PROCESS;
      value: { syncService: SyncService };
    };

// FfiConverter for enum NotificationProcessSetup
const FfiConverterTypeNotificationProcessSetup = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationProcessSetup;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: NotificationProcessSetupKind.MULTIPLE_PROCESSES };
        case 2:
          return {
            kind: NotificationProcessSetupKind.SINGLE_PROCESS,
            value: {
              syncService: FfiConverterTypeSyncService.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case NotificationProcessSetupKind.MULTIPLE_PROCESSES: {
          ordinalConverter.write(1, into);
          return;
        }
        case NotificationProcessSetupKind.SINGLE_PROCESS: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterTypeSyncService.write(inner.syncService, into);
          return;
        }
        default:
          // Throwing from here means that NotificationProcessSetupKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case NotificationProcessSetupKind.MULTIPLE_PROCESSES: {
          return ordinalConverter.allocationSize(1);
        }
        case NotificationProcessSetupKind.SINGLE_PROCESS: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeSyncService.allocationSize(inner.syncService);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface TimelineDiffInterface {
  append(): TimelineItem[] | undefined;
  change(): TimelineChange;
  insert(): InsertData | undefined;
  pushBack(): TimelineItem | undefined;
  pushFront(): TimelineItem | undefined;
  remove(): /*u32*/ number | undefined;
  reset(): TimelineItem[] | undefined;
  set(): SetData | undefined;
}

export class TimelineDiff
  implements TimelineDiffInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public append(): TimelineItem[] | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public change(): TimelineChange {
    return FfiConverterTypeTimelineChange.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public insert(): InsertData | undefined {
    return FfiConverterOptionalTypeInsertData.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public pushBack(): TimelineItem | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public pushFront(): TimelineItem | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public remove(): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public reset(): TimelineItem[] | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public set(): SetData | undefined {
    return FfiConverterOptionalTypeSetData.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timelinediff(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timelinediff(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimelineDiff(pointer: UnsafeMutableRawPointer): TimelineDiff {
  const instance = Object.create(TimelineDiff.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimelineDiff = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TimelineDiff;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimelineDiff(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export interface WidgetDriverHandleInterface {
  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  recv(): Promise<string | undefined>;
  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  send(msg: string): Promise<boolean>;
}

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export class WidgetDriverHandle
  implements WidgetDriverHandleInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  public async recv(): Promise<string | undefined> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalString.lift,
      errorHandler: undefined,
    });
  }

  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  public async send(msg: string): Promise<boolean> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
          this.uniffiClonePointer(),
          FfiConverterString.lower(msg)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: undefined,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(
        this.pointer,
        callStatus
      )
    );
  }
}

function createWidgetDriverHandle(
  pointer: UnsafeMutableRawPointer
): WidgetDriverHandle {
  const instance = Object.create(WidgetDriverHandle.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeWidgetDriverHandle = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = WidgetDriverHandle;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createWidgetDriverHandle(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum PollKind {
  DISCLOSED,
  UNDISCLOSED,
}

const FfiConverterTypePollKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PollKind;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PollKind.DISCLOSED;
        case 2:
          return PollKind.UNDISCLOSED;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PollKind.DISCLOSED:
          return ordinalConverter.write(1, into);
        case PollKind.UNDISCLOSED:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(
  FfiConverterDuration
);

export enum RoomListServiceState {
  INITIAL,
  SETTING_UP,
  RECOVERING,
  RUNNING,
  ERROR,
  TERMINATED,
}

const FfiConverterTypeRoomListServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceState.INITIAL;
        case 2:
          return RoomListServiceState.SETTING_UP;
        case 3:
          return RoomListServiceState.RECOVERING;
        case 4:
          return RoomListServiceState.RUNNING;
        case 5:
          return RoomListServiceState.ERROR;
        case 6:
          return RoomListServiceState.TERMINATED;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceState.INITIAL:
          return ordinalConverter.write(1, into);
        case RoomListServiceState.SETTING_UP:
          return ordinalConverter.write(2, into);
        case RoomListServiceState.RECOVERING:
          return ordinalConverter.write(3, into);
        case RoomListServiceState.RUNNING:
          return ordinalConverter.write(4, into);
        case RoomListServiceState.ERROR:
          return ordinalConverter.write(5, into);
        case RoomListServiceState.TERMINATED:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum BackupState {
  UNKNOWN,
  CREATING,
  ENABLING,
  RESUMING,
  ENABLED,
  DOWNLOADING,
  DISABLING,
}

const FfiConverterTypeBackupState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupState.UNKNOWN;
        case 2:
          return BackupState.CREATING;
        case 3:
          return BackupState.ENABLING;
        case 4:
          return BackupState.RESUMING;
        case 5:
          return BackupState.ENABLED;
        case 6:
          return BackupState.DOWNLOADING;
        case 7:
          return BackupState.DISABLING;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupState.UNKNOWN:
          return ordinalConverter.write(1, into);
        case BackupState.CREATING:
          return ordinalConverter.write(2, into);
        case BackupState.ENABLING:
          return ordinalConverter.write(3, into);
        case BackupState.RESUMING:
          return ordinalConverter.write(4, into);
        case BackupState.ENABLED:
          return ordinalConverter.write(5, into);
        case BackupState.DOWNLOADING:
          return ordinalConverter.write(6, into);
        case BackupState.DISABLING:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum MessageLikeEventType {
  CALL_ANSWER,
  CALL_CANDIDATES,
  CALL_HANGUP,
  CALL_INVITE,
  KEY_VERIFICATION_ACCEPT,
  KEY_VERIFICATION_CANCEL,
  KEY_VERIFICATION_DONE,
  KEY_VERIFICATION_KEY,
  KEY_VERIFICATION_MAC,
  KEY_VERIFICATION_READY,
  KEY_VERIFICATION_START,
  POLL_END,
  POLL_RESPONSE,
  POLL_START,
  REACTION,
  ROOM_ENCRYPTED,
  ROOM_MESSAGE,
  ROOM_REDACTION,
  STICKER,
  UNSTABLE_POLL_END,
  UNSTABLE_POLL_RESPONSE,
  UNSTABLE_POLL_START,
}

const FfiConverterTypeMessageLikeEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MessageLikeEventType.CALL_ANSWER;
        case 2:
          return MessageLikeEventType.CALL_CANDIDATES;
        case 3:
          return MessageLikeEventType.CALL_HANGUP;
        case 4:
          return MessageLikeEventType.CALL_INVITE;
        case 5:
          return MessageLikeEventType.KEY_VERIFICATION_ACCEPT;
        case 6:
          return MessageLikeEventType.KEY_VERIFICATION_CANCEL;
        case 7:
          return MessageLikeEventType.KEY_VERIFICATION_DONE;
        case 8:
          return MessageLikeEventType.KEY_VERIFICATION_KEY;
        case 9:
          return MessageLikeEventType.KEY_VERIFICATION_MAC;
        case 10:
          return MessageLikeEventType.KEY_VERIFICATION_READY;
        case 11:
          return MessageLikeEventType.KEY_VERIFICATION_START;
        case 12:
          return MessageLikeEventType.POLL_END;
        case 13:
          return MessageLikeEventType.POLL_RESPONSE;
        case 14:
          return MessageLikeEventType.POLL_START;
        case 15:
          return MessageLikeEventType.REACTION;
        case 16:
          return MessageLikeEventType.ROOM_ENCRYPTED;
        case 17:
          return MessageLikeEventType.ROOM_MESSAGE;
        case 18:
          return MessageLikeEventType.ROOM_REDACTION;
        case 19:
          return MessageLikeEventType.STICKER;
        case 20:
          return MessageLikeEventType.UNSTABLE_POLL_END;
        case 21:
          return MessageLikeEventType.UNSTABLE_POLL_RESPONSE;
        case 22:
          return MessageLikeEventType.UNSTABLE_POLL_START;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MessageLikeEventType.CALL_ANSWER:
          return ordinalConverter.write(1, into);
        case MessageLikeEventType.CALL_CANDIDATES:
          return ordinalConverter.write(2, into);
        case MessageLikeEventType.CALL_HANGUP:
          return ordinalConverter.write(3, into);
        case MessageLikeEventType.CALL_INVITE:
          return ordinalConverter.write(4, into);
        case MessageLikeEventType.KEY_VERIFICATION_ACCEPT:
          return ordinalConverter.write(5, into);
        case MessageLikeEventType.KEY_VERIFICATION_CANCEL:
          return ordinalConverter.write(6, into);
        case MessageLikeEventType.KEY_VERIFICATION_DONE:
          return ordinalConverter.write(7, into);
        case MessageLikeEventType.KEY_VERIFICATION_KEY:
          return ordinalConverter.write(8, into);
        case MessageLikeEventType.KEY_VERIFICATION_MAC:
          return ordinalConverter.write(9, into);
        case MessageLikeEventType.KEY_VERIFICATION_READY:
          return ordinalConverter.write(10, into);
        case MessageLikeEventType.KEY_VERIFICATION_START:
          return ordinalConverter.write(11, into);
        case MessageLikeEventType.POLL_END:
          return ordinalConverter.write(12, into);
        case MessageLikeEventType.POLL_RESPONSE:
          return ordinalConverter.write(13, into);
        case MessageLikeEventType.POLL_START:
          return ordinalConverter.write(14, into);
        case MessageLikeEventType.REACTION:
          return ordinalConverter.write(15, into);
        case MessageLikeEventType.ROOM_ENCRYPTED:
          return ordinalConverter.write(16, into);
        case MessageLikeEventType.ROOM_MESSAGE:
          return ordinalConverter.write(17, into);
        case MessageLikeEventType.ROOM_REDACTION:
          return ordinalConverter.write(18, into);
        case MessageLikeEventType.STICKER:
          return ordinalConverter.write(19, into);
        case MessageLikeEventType.UNSTABLE_POLL_END:
          return ordinalConverter.write(20, into);
        case MessageLikeEventType.UNSTABLE_POLL_RESPONSE:
          return ordinalConverter.write(21, into);
        case MessageLikeEventType.UNSTABLE_POLL_START:
          return ordinalConverter.write(22, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for PollAnswer[]
const FfiConverterArrayTypePollAnswer = new FfiConverterArray(
  FfiConverterTypePollAnswer
);

// Enum: EventSendState
export enum EventSendStateKind {
  NOT_SENT_YET = 'NotSentYet',
  SENDING_FAILED = 'SendingFailed',
  CANCELLED = 'Cancelled',
  SENT = 'Sent',
}
/**
 * This type represents the “send state” of a local event timeline item.
 */
export type EventSendState =
  /**
   * The local event has not been sent yet.
   */
  | { kind: EventSendStateKind.NOT_SENT_YET }
  /**
   * The local event has been sent to the server, but unsuccessfully: The
   * sending has failed.
   */
  | { kind: EventSendStateKind.SENDING_FAILED; value: { error: string } }
  /**
   * Sending has been cancelled because an earlier event in the
   * message-sending queue failed.
   */
  | { kind: EventSendStateKind.CANCELLED }
  /**
   * The local event has been sent successfully to the server.
   */
  | { kind: EventSendStateKind.SENT; value: { eventId: string } };

// FfiConverter for enum EventSendState
const FfiConverterTypeEventSendState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventSendState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: EventSendStateKind.NOT_SENT_YET };
        case 2:
          return {
            kind: EventSendStateKind.SENDING_FAILED,
            value: {
              error: FfiConverterString.read(from),
            },
          };
        case 3:
          return { kind: EventSendStateKind.CANCELLED };
        case 4:
          return {
            kind: EventSendStateKind.SENT,
            value: {
              eventId: FfiConverterString.read(from),
            },
          };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case EventSendStateKind.NOT_SENT_YET: {
          ordinalConverter.write(1, into);
          return;
        }
        case EventSendStateKind.SENDING_FAILED: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case EventSendStateKind.CANCELLED: {
          ordinalConverter.write(3, into);
          return;
        }
        case EventSendStateKind.SENT: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that EventSendStateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case EventSendStateKind.NOT_SENT_YET: {
          return ordinalConverter.allocationSize(1);
        }
        case EventSendStateKind.SENDING_FAILED: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case EventSendStateKind.CANCELLED: {
          return ordinalConverter.allocationSize(3);
        }
        case EventSendStateKind.SENT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: StateEventContent
export enum StateEventContentKind {
  POLICY_RULE_ROOM = 'PolicyRuleRoom',
  POLICY_RULE_SERVER = 'PolicyRuleServer',
  POLICY_RULE_USER = 'PolicyRuleUser',
  ROOM_ALIASES = 'RoomAliases',
  ROOM_AVATAR = 'RoomAvatar',
  ROOM_CANONICAL_ALIAS = 'RoomCanonicalAlias',
  ROOM_CREATE = 'RoomCreate',
  ROOM_ENCRYPTION = 'RoomEncryption',
  ROOM_GUEST_ACCESS = 'RoomGuestAccess',
  ROOM_HISTORY_VISIBILITY = 'RoomHistoryVisibility',
  ROOM_JOIN_RULES = 'RoomJoinRules',
  ROOM_MEMBER_CONTENT = 'RoomMemberContent',
  ROOM_NAME = 'RoomName',
  ROOM_PINNED_EVENTS = 'RoomPinnedEvents',
  ROOM_POWER_LEVELS = 'RoomPowerLevels',
  ROOM_SERVER_ACL = 'RoomServerAcl',
  ROOM_THIRD_PARTY_INVITE = 'RoomThirdPartyInvite',
  ROOM_TOMBSTONE = 'RoomTombstone',
  ROOM_TOPIC = 'RoomTopic',
  SPACE_CHILD = 'SpaceChild',
  SPACE_PARENT = 'SpaceParent',
}
export type StateEventContent =
  | { kind: StateEventContentKind.POLICY_RULE_ROOM }
  | { kind: StateEventContentKind.POLICY_RULE_SERVER }
  | { kind: StateEventContentKind.POLICY_RULE_USER }
  | { kind: StateEventContentKind.ROOM_ALIASES }
  | { kind: StateEventContentKind.ROOM_AVATAR }
  | { kind: StateEventContentKind.ROOM_CANONICAL_ALIAS }
  | { kind: StateEventContentKind.ROOM_CREATE }
  | { kind: StateEventContentKind.ROOM_ENCRYPTION }
  | { kind: StateEventContentKind.ROOM_GUEST_ACCESS }
  | { kind: StateEventContentKind.ROOM_HISTORY_VISIBILITY }
  | { kind: StateEventContentKind.ROOM_JOIN_RULES }
  | {
      kind: StateEventContentKind.ROOM_MEMBER_CONTENT;
      value: { userId: string; membershipState: MembershipState };
    }
  | { kind: StateEventContentKind.ROOM_NAME }
  | { kind: StateEventContentKind.ROOM_PINNED_EVENTS }
  | { kind: StateEventContentKind.ROOM_POWER_LEVELS }
  | { kind: StateEventContentKind.ROOM_SERVER_ACL }
  | { kind: StateEventContentKind.ROOM_THIRD_PARTY_INVITE }
  | { kind: StateEventContentKind.ROOM_TOMBSTONE }
  | { kind: StateEventContentKind.ROOM_TOPIC }
  | { kind: StateEventContentKind.SPACE_CHILD }
  | { kind: StateEventContentKind.SPACE_PARENT };

// FfiConverter for enum StateEventContent
const FfiConverterTypeStateEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: StateEventContentKind.POLICY_RULE_ROOM };
        case 2:
          return { kind: StateEventContentKind.POLICY_RULE_SERVER };
        case 3:
          return { kind: StateEventContentKind.POLICY_RULE_USER };
        case 4:
          return { kind: StateEventContentKind.ROOM_ALIASES };
        case 5:
          return { kind: StateEventContentKind.ROOM_AVATAR };
        case 6:
          return { kind: StateEventContentKind.ROOM_CANONICAL_ALIAS };
        case 7:
          return { kind: StateEventContentKind.ROOM_CREATE };
        case 8:
          return { kind: StateEventContentKind.ROOM_ENCRYPTION };
        case 9:
          return { kind: StateEventContentKind.ROOM_GUEST_ACCESS };
        case 10:
          return { kind: StateEventContentKind.ROOM_HISTORY_VISIBILITY };
        case 11:
          return { kind: StateEventContentKind.ROOM_JOIN_RULES };
        case 12:
          return {
            kind: StateEventContentKind.ROOM_MEMBER_CONTENT,
            value: {
              userId: FfiConverterString.read(from),
              membershipState: FfiConverterTypeMembershipState.read(from),
            },
          };
        case 13:
          return { kind: StateEventContentKind.ROOM_NAME };
        case 14:
          return { kind: StateEventContentKind.ROOM_PINNED_EVENTS };
        case 15:
          return { kind: StateEventContentKind.ROOM_POWER_LEVELS };
        case 16:
          return { kind: StateEventContentKind.ROOM_SERVER_ACL };
        case 17:
          return { kind: StateEventContentKind.ROOM_THIRD_PARTY_INVITE };
        case 18:
          return { kind: StateEventContentKind.ROOM_TOMBSTONE };
        case 19:
          return { kind: StateEventContentKind.ROOM_TOPIC };
        case 20:
          return { kind: StateEventContentKind.SPACE_CHILD };
        case 21:
          return { kind: StateEventContentKind.SPACE_PARENT };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case StateEventContentKind.POLICY_RULE_ROOM: {
          ordinalConverter.write(1, into);
          return;
        }
        case StateEventContentKind.POLICY_RULE_SERVER: {
          ordinalConverter.write(2, into);
          return;
        }
        case StateEventContentKind.POLICY_RULE_USER: {
          ordinalConverter.write(3, into);
          return;
        }
        case StateEventContentKind.ROOM_ALIASES: {
          ordinalConverter.write(4, into);
          return;
        }
        case StateEventContentKind.ROOM_AVATAR: {
          ordinalConverter.write(5, into);
          return;
        }
        case StateEventContentKind.ROOM_CANONICAL_ALIAS: {
          ordinalConverter.write(6, into);
          return;
        }
        case StateEventContentKind.ROOM_CREATE: {
          ordinalConverter.write(7, into);
          return;
        }
        case StateEventContentKind.ROOM_ENCRYPTION: {
          ordinalConverter.write(8, into);
          return;
        }
        case StateEventContentKind.ROOM_GUEST_ACCESS: {
          ordinalConverter.write(9, into);
          return;
        }
        case StateEventContentKind.ROOM_HISTORY_VISIBILITY: {
          ordinalConverter.write(10, into);
          return;
        }
        case StateEventContentKind.ROOM_JOIN_RULES: {
          ordinalConverter.write(11, into);
          return;
        }
        case StateEventContentKind.ROOM_MEMBER_CONTENT: {
          ordinalConverter.write(12, into);
          const inner = value.value;
          FfiConverterString.write(inner.userId, into);
          FfiConverterTypeMembershipState.write(inner.membershipState, into);
          return;
        }
        case StateEventContentKind.ROOM_NAME: {
          ordinalConverter.write(13, into);
          return;
        }
        case StateEventContentKind.ROOM_PINNED_EVENTS: {
          ordinalConverter.write(14, into);
          return;
        }
        case StateEventContentKind.ROOM_POWER_LEVELS: {
          ordinalConverter.write(15, into);
          return;
        }
        case StateEventContentKind.ROOM_SERVER_ACL: {
          ordinalConverter.write(16, into);
          return;
        }
        case StateEventContentKind.ROOM_THIRD_PARTY_INVITE: {
          ordinalConverter.write(17, into);
          return;
        }
        case StateEventContentKind.ROOM_TOMBSTONE: {
          ordinalConverter.write(18, into);
          return;
        }
        case StateEventContentKind.ROOM_TOPIC: {
          ordinalConverter.write(19, into);
          return;
        }
        case StateEventContentKind.SPACE_CHILD: {
          ordinalConverter.write(20, into);
          return;
        }
        case StateEventContentKind.SPACE_PARENT: {
          ordinalConverter.write(21, into);
          return;
        }
        default:
          // Throwing from here means that StateEventContentKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case StateEventContentKind.POLICY_RULE_ROOM: {
          return ordinalConverter.allocationSize(1);
        }
        case StateEventContentKind.POLICY_RULE_SERVER: {
          return ordinalConverter.allocationSize(2);
        }
        case StateEventContentKind.POLICY_RULE_USER: {
          return ordinalConverter.allocationSize(3);
        }
        case StateEventContentKind.ROOM_ALIASES: {
          return ordinalConverter.allocationSize(4);
        }
        case StateEventContentKind.ROOM_AVATAR: {
          return ordinalConverter.allocationSize(5);
        }
        case StateEventContentKind.ROOM_CANONICAL_ALIAS: {
          return ordinalConverter.allocationSize(6);
        }
        case StateEventContentKind.ROOM_CREATE: {
          return ordinalConverter.allocationSize(7);
        }
        case StateEventContentKind.ROOM_ENCRYPTION: {
          return ordinalConverter.allocationSize(8);
        }
        case StateEventContentKind.ROOM_GUEST_ACCESS: {
          return ordinalConverter.allocationSize(9);
        }
        case StateEventContentKind.ROOM_HISTORY_VISIBILITY: {
          return ordinalConverter.allocationSize(10);
        }
        case StateEventContentKind.ROOM_JOIN_RULES: {
          return ordinalConverter.allocationSize(11);
        }
        case StateEventContentKind.ROOM_MEMBER_CONTENT: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterTypeMembershipState.allocationSize(
            inner.membershipState
          );
          return size;
        }
        case StateEventContentKind.ROOM_NAME: {
          return ordinalConverter.allocationSize(13);
        }
        case StateEventContentKind.ROOM_PINNED_EVENTS: {
          return ordinalConverter.allocationSize(14);
        }
        case StateEventContentKind.ROOM_POWER_LEVELS: {
          return ordinalConverter.allocationSize(15);
        }
        case StateEventContentKind.ROOM_SERVER_ACL: {
          return ordinalConverter.allocationSize(16);
        }
        case StateEventContentKind.ROOM_THIRD_PARTY_INVITE: {
          return ordinalConverter.allocationSize(17);
        }
        case StateEventContentKind.ROOM_TOMBSTONE: {
          return ordinalConverter.allocationSize(18);
        }
        case StateEventContentKind.ROOM_TOPIC: {
          return ordinalConverter.allocationSize(19);
        }
        case StateEventContentKind.SPACE_CHILD: {
          return ordinalConverter.allocationSize(20);
        }
        case StateEventContentKind.SPACE_PARENT: {
          return ordinalConverter.allocationSize(21);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomVisibility {
  /**
   * Indicates that the room will be shown in the published room list.
   */
  PUBLIC,
  /**
   * Indicates that the room will not be shown in the published room list.
   */
  PRIVATE,
}

const FfiConverterTypeRoomVisibility = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomVisibility;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomVisibility.PUBLIC;
        case 2:
          return RoomVisibility.PRIVATE;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomVisibility.PUBLIC:
          return ordinalConverter.write(1, into);
        case RoomVisibility.PRIVATE:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for OidcConfiguration | undefined
const FfiConverterOptionalTypeOidcConfiguration = new FfiConverterOptional(
  FfiConverterTypeOidcConfiguration
);

export enum StateEventType {
  CALL_MEMBER,
  POLICY_RULE_ROOM,
  POLICY_RULE_SERVER,
  POLICY_RULE_USER,
  ROOM_ALIASES,
  ROOM_AVATAR,
  ROOM_CANONICAL_ALIAS,
  ROOM_CREATE,
  ROOM_ENCRYPTION,
  ROOM_GUEST_ACCESS,
  ROOM_HISTORY_VISIBILITY,
  ROOM_JOIN_RULES,
  ROOM_MEMBER_EVENT,
  ROOM_NAME,
  ROOM_PINNED_EVENTS,
  ROOM_POWER_LEVELS,
  ROOM_SERVER_ACL,
  ROOM_THIRD_PARTY_INVITE,
  ROOM_TOMBSTONE,
  ROOM_TOPIC,
  SPACE_CHILD,
  SPACE_PARENT,
}

const FfiConverterTypeStateEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return StateEventType.CALL_MEMBER;
        case 2:
          return StateEventType.POLICY_RULE_ROOM;
        case 3:
          return StateEventType.POLICY_RULE_SERVER;
        case 4:
          return StateEventType.POLICY_RULE_USER;
        case 5:
          return StateEventType.ROOM_ALIASES;
        case 6:
          return StateEventType.ROOM_AVATAR;
        case 7:
          return StateEventType.ROOM_CANONICAL_ALIAS;
        case 8:
          return StateEventType.ROOM_CREATE;
        case 9:
          return StateEventType.ROOM_ENCRYPTION;
        case 10:
          return StateEventType.ROOM_GUEST_ACCESS;
        case 11:
          return StateEventType.ROOM_HISTORY_VISIBILITY;
        case 12:
          return StateEventType.ROOM_JOIN_RULES;
        case 13:
          return StateEventType.ROOM_MEMBER_EVENT;
        case 14:
          return StateEventType.ROOM_NAME;
        case 15:
          return StateEventType.ROOM_PINNED_EVENTS;
        case 16:
          return StateEventType.ROOM_POWER_LEVELS;
        case 17:
          return StateEventType.ROOM_SERVER_ACL;
        case 18:
          return StateEventType.ROOM_THIRD_PARTY_INVITE;
        case 19:
          return StateEventType.ROOM_TOMBSTONE;
        case 20:
          return StateEventType.ROOM_TOPIC;
        case 21:
          return StateEventType.SPACE_CHILD;
        case 22:
          return StateEventType.SPACE_PARENT;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case StateEventType.CALL_MEMBER:
          return ordinalConverter.write(1, into);
        case StateEventType.POLICY_RULE_ROOM:
          return ordinalConverter.write(2, into);
        case StateEventType.POLICY_RULE_SERVER:
          return ordinalConverter.write(3, into);
        case StateEventType.POLICY_RULE_USER:
          return ordinalConverter.write(4, into);
        case StateEventType.ROOM_ALIASES:
          return ordinalConverter.write(5, into);
        case StateEventType.ROOM_AVATAR:
          return ordinalConverter.write(6, into);
        case StateEventType.ROOM_CANONICAL_ALIAS:
          return ordinalConverter.write(7, into);
        case StateEventType.ROOM_CREATE:
          return ordinalConverter.write(8, into);
        case StateEventType.ROOM_ENCRYPTION:
          return ordinalConverter.write(9, into);
        case StateEventType.ROOM_GUEST_ACCESS:
          return ordinalConverter.write(10, into);
        case StateEventType.ROOM_HISTORY_VISIBILITY:
          return ordinalConverter.write(11, into);
        case StateEventType.ROOM_JOIN_RULES:
          return ordinalConverter.write(12, into);
        case StateEventType.ROOM_MEMBER_EVENT:
          return ordinalConverter.write(13, into);
        case StateEventType.ROOM_NAME:
          return ordinalConverter.write(14, into);
        case StateEventType.ROOM_PINNED_EVENTS:
          return ordinalConverter.write(15, into);
        case StateEventType.ROOM_POWER_LEVELS:
          return ordinalConverter.write(16, into);
        case StateEventType.ROOM_SERVER_ACL:
          return ordinalConverter.write(17, into);
        case StateEventType.ROOM_THIRD_PARTY_INVITE:
          return ordinalConverter.write(18, into);
        case StateEventType.ROOM_TOMBSTONE:
          return ordinalConverter.write(19, into);
        case StateEventType.ROOM_TOPIC:
          return ordinalConverter.write(20, into);
        case StateEventType.SPACE_CHILD:
          return ordinalConverter.write(21, into);
        case StateEventType.SPACE_PARENT:
          return ordinalConverter.write(22, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export interface MediaFileHandleInterface {
  /**
   * Get the media file's path.
   */
  path() /*throws*/ : string;
  persist(path: string) /*throws*/ : boolean;
}

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export class MediaFileHandle
  implements MediaFileHandleInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * Get the media file's path.
   */
  public path(): string /*throws*/ {
    return FfiConverterString.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public persist(path: string): boolean /*throws*/ {
    return FfiConverterBool.lift(
      rustCallWithError(FfiConverterTypeClientError.lift, (callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
          this.uniffiClonePointer(),
          FfiConverterString.lower(path),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(
        this.pointer,
        callStatus
      )
    );
  }
}

function createMediaFileHandle(
  pointer: UnsafeMutableRawPointer
): MediaFileHandle {
  const instance = Object.create(MediaFileHandle.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeMediaFileHandle = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = MediaFileHandle;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createMediaFileHandle(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);

// Enum: VirtualTimelineItem
export enum VirtualTimelineItemKind {
  DAY_DIVIDER = 'DayDivider',
  READ_MARKER = 'ReadMarker',
}
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export type VirtualTimelineItem =
  /**
   * A divider between messages of two days.
   */
  | { kind: VirtualTimelineItemKind.DAY_DIVIDER; value: { ts: /*u64*/ bigint } }
  /**
   * The user's own read marker.
   */
  | { kind: VirtualTimelineItemKind.READ_MARKER };

// FfiConverter for enum VirtualTimelineItem
const FfiConverterTypeVirtualTimelineItem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VirtualTimelineItem;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: VirtualTimelineItemKind.DAY_DIVIDER,
            value: {
              ts: FfiConverterUInt64.read(from),
            },
          };
        case 2:
          return { kind: VirtualTimelineItemKind.READ_MARKER };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case VirtualTimelineItemKind.DAY_DIVIDER: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterUInt64.write(inner.ts, into);
          return;
        }
        case VirtualTimelineItemKind.READ_MARKER: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that VirtualTimelineItemKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case VirtualTimelineItemKind.DAY_DIVIDER: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.ts);
          return size;
        }
        case VirtualTimelineItemKind.READ_MARKER: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: BackupUploadState
export enum BackupUploadStateKind {
  WAITING = 'Waiting',
  UPLOADING = 'Uploading',
  ERROR = 'Error',
  DONE = 'Done',
}
export type BackupUploadState =
  | { kind: BackupUploadStateKind.WAITING }
  | {
      kind: BackupUploadStateKind.UPLOADING;
      value: { backedUpCount: /*u32*/ number; totalCount: /*u32*/ number };
    }
  | { kind: BackupUploadStateKind.ERROR }
  | { kind: BackupUploadStateKind.DONE };

// FfiConverter for enum BackupUploadState
const FfiConverterTypeBackupUploadState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupUploadState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: BackupUploadStateKind.WAITING };
        case 2:
          return {
            kind: BackupUploadStateKind.UPLOADING,
            value: {
              backedUpCount: FfiConverterUInt32.read(from),
              totalCount: FfiConverterUInt32.read(from),
            },
          };
        case 3:
          return { kind: BackupUploadStateKind.ERROR };
        case 4:
          return { kind: BackupUploadStateKind.DONE };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case BackupUploadStateKind.WAITING: {
          ordinalConverter.write(1, into);
          return;
        }
        case BackupUploadStateKind.UPLOADING: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case BackupUploadStateKind.ERROR: {
          ordinalConverter.write(3, into);
          return;
        }
        case BackupUploadStateKind.DONE: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that BackupUploadStateKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case BackupUploadStateKind.WAITING: {
          return ordinalConverter.allocationSize(1);
        }
        case BackupUploadStateKind.UPLOADING: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case BackupUploadStateKind.ERROR: {
          return ordinalConverter.allocationSize(3);
        }
        case BackupUploadStateKind.DONE: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptedMessage
export enum EncryptedMessageKind {
  OLM_V1_CURVE25519_AES_SHA2 = 'OlmV1Curve25519AesSha2',
  MEGOLM_V1_AES_SHA2 = 'MegolmV1AesSha2',
  UNKNOWN = 'Unknown',
}
export type EncryptedMessage =
  | {
      kind: EncryptedMessageKind.OLM_V1_CURVE25519_AES_SHA2;
      value: { senderKey: string };
    }
  | {
      kind: EncryptedMessageKind.MEGOLM_V1_AES_SHA2;
      value: { sessionId: string; cause: UtdCause };
    }
  | { kind: EncryptedMessageKind.UNKNOWN };

// FfiConverter for enum EncryptedMessage
const FfiConverterTypeEncryptedMessage = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptedMessage;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: EncryptedMessageKind.OLM_V1_CURVE25519_AES_SHA2,
            value: {
              senderKey: FfiConverterString.read(from),
            },
          };
        case 2:
          return {
            kind: EncryptedMessageKind.MEGOLM_V1_AES_SHA2,
            value: {
              sessionId: FfiConverterString.read(from),
              cause: FfiConverterTypeUtdCause.read(from),
            },
          };
        case 3:
          return { kind: EncryptedMessageKind.UNKNOWN };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case EncryptedMessageKind.OLM_V1_CURVE25519_AES_SHA2: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterString.write(inner.senderKey, into);
          return;
        }
        case EncryptedMessageKind.MEGOLM_V1_AES_SHA2: {
          ordinalConverter.write(2, into);
          const inner = value.value;
          FfiConverterString.write(inner.sessionId, into);
          FfiConverterTypeUtdCause.write(inner.cause, into);
          return;
        }
        case EncryptedMessageKind.UNKNOWN: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that EncryptedMessageKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case EncryptedMessageKind.OLM_V1_CURVE25519_AES_SHA2: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.senderKey);
          return size;
        }
        case EncryptedMessageKind.MEGOLM_V1_AES_SHA2: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sessionId);
          size += FfiConverterTypeUtdCause.allocationSize(inner.cause);
          return size;
        }
        case EncryptedMessageKind.UNKNOWN: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export enum ReceiptType {
  READ,
  READ_PRIVATE,
  FULLY_READ,
}

const FfiConverterTypeReceiptType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceiptType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ReceiptType.READ;
        case 2:
          return ReceiptType.READ_PRIVATE;
        case 3:
          return ReceiptType.FULLY_READ;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ReceiptType.READ:
          return ordinalConverter.write(1, into);
        case ReceiptType.READ_PRIVATE:
          return ordinalConverter.write(2, into);
        case ReceiptType.FULLY_READ:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum VerificationState {
  UNKNOWN,
  VERIFIED,
  UNVERIFIED,
}

const FfiConverterTypeVerificationState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VerificationState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return VerificationState.UNKNOWN;
        case 2:
          return VerificationState.VERIFIED;
        case 3:
          return VerificationState.UNVERIFIED;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case VerificationState.UNKNOWN:
          return ordinalConverter.write(1, into);
        case VerificationState.VERIFIED:
          return ordinalConverter.write(2, into);
        case VerificationState.UNVERIFIED:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for ReactionSenderData[]
const FfiConverterArrayTypeReactionSenderData = new FfiConverterArray(
  FfiConverterTypeReactionSenderData
);

export enum SyncServiceState {
  IDLE,
  RUNNING,
  TERMINATED,
  ERROR,
}

const FfiConverterTypeSyncServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SyncServiceState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SyncServiceState.IDLE;
        case 2:
          return SyncServiceState.RUNNING;
        case 3:
          return SyncServiceState.TERMINATED;
        case 4:
          return SyncServiceState.ERROR;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SyncServiceState.IDLE:
          return ordinalConverter.write(1, into);
        case SyncServiceState.RUNNING:
          return ordinalConverter.write(2, into);
        case SyncServiceState.TERMINATED:
          return ordinalConverter.write(3, into);
        case SyncServiceState.ERROR:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export interface MessageInterface {
  body(): string;
  inReplyTo(): InReplyToDetails | undefined;
  isEdited(): boolean;
  isThreaded(): boolean;
  msgtype(): MessageType;
}

export class Message implements MessageInterface, UniffiObjectInterface {
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public body(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_message_body(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public inReplyTo(): InReplyToDetails | undefined {
    return FfiConverterOptionalTypeInReplyToDetails.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_message_in_reply_to(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isEdited(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_message_is_edited(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public isThreaded(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_message_is_threaded(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public msgtype(): MessageType {
    return FfiConverterTypeMessageType.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_message_msgtype(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_message(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_message(
        this.pointer,
        callStatus
      )
    );
  }
}

function createMessage(pointer: UnsafeMutableRawPointer): Message {
  const instance = Object.create(Message.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeMessage = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = Message;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createMessage(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface SyncServiceInterface {
  roomListService(): RoomListService;
  start(): Promise<void>;
  state(listener: SyncServiceStateObserver): TaskHandle;
  stop() /*throws*/ : Promise<void>;
}

export class SyncService
  implements SyncServiceInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public roomListService(): RoomListService {
    return FfiConverterTypeRoomListService.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public async start(): Promise<void> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: undefined,
    });
  }

  public state(listener: SyncServiceStateObserver): TaskHandle {
    return FfiConverterTypeTaskHandle.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
          this.uniffiClonePointer(),
          FfiConverterTypeSyncServiceStateObserver.lower(listener),
          callStatus
        );
      })
    );
  }

  public async stop(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_syncservice(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_syncservice(
        this.pointer,
        callStatus
      )
    );
  }
}

function createSyncService(pointer: UnsafeMutableRawPointer): SyncService {
  const instance = Object.create(SyncService.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSyncService = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = SyncService;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSyncService(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface TimelineEventTypeFilterInterface {}

export class TimelineEventTypeFilter
  implements TimelineEventTypeFilterInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public static exclude(
    eventTypes: FilterTimelineEventType[]
  ): TimelineEventTypeFilter {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
          FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
          callStatus
        );
      })
    );
  }

  public static include(
    eventTypes: FilterTimelineEventType[]
  ): TimelineEventTypeFilter {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
          FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(
        this.pointer,
        callStatus
      )
    );
  }
}

function createTimelineEventTypeFilter(
  pointer: UnsafeMutableRawPointer
): TimelineEventTypeFilter {
  const instance = Object.create(TimelineEventTypeFilter.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeTimelineEventTypeFilter = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = TimelineEventTypeFilter;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createTimelineEventTypeFilter(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for RequiredState[]
const FfiConverterArrayTypeRequiredState = new FfiConverterArray(
  FfiConverterTypeRequiredState
);

export interface SessionVerificationControllerInterface {
  approveVerification() /*throws*/ : Promise<void>;
  cancelVerification() /*throws*/ : Promise<void>;
  declineVerification() /*throws*/ : Promise<void>;
  isVerified() /*throws*/ : Promise<boolean>;
  requestVerification() /*throws*/ : Promise<void>;
  setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void;
  startSasVerification() /*throws*/ : Promise<void>;
}

export class SessionVerificationController
  implements SessionVerificationControllerInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async approveVerification(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async cancelVerification(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async declineVerification(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async isVerified(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_is_verified(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async requestVerification(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_verification(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
        this.uniffiClonePointer(),
        FfiConverterOptionalTypeSessionVerificationControllerDelegate.lower(
          delegate
        ),
        callStatus
      );
    });
  }

  public async startSasVerification(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(
        this.pointer,
        callStatus
      )
    );
  }
}

function createSessionVerificationController(
  pointer: UnsafeMutableRawPointer
): SessionVerificationController {
  const instance = Object.create(SessionVerificationController.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSessionVerificationController = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = SessionVerificationController;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSessionVerificationController(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export enum RtcApplicationType {
  CALL,
}

const FfiConverterTypeRtcApplicationType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RtcApplicationType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RtcApplicationType.CALL;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RtcApplicationType.CALL:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for UnstableAudioDetailsContent | undefined
const FfiConverterOptionalTypeUnstableAudioDetailsContent =
  new FfiConverterOptional(FfiConverterTypeUnstableAudioDetailsContent);

// FfiConverter for Map<string, /*i32*/number>
const FfiConverterMapStringInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt32
);

export interface NotificationClientInterface {
  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  getNotification(
    roomId: string,
    eventId: string
  ) /*throws*/ : Promise<NotificationItem | undefined>;
}

export class NotificationClient
  implements NotificationClientInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  public async getNotification(
    roomId: string,
    eventId: string
  ): Promise<NotificationItem | undefined> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
          this.uniffiClonePointer(),
          FfiConverterString.lower(roomId),
          FfiConverterString.lower(eventId)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      liftFunc: FfiConverterOptionalTypeNotificationItem.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_notificationclient(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_notificationclient(
        this.pointer,
        callStatus
      )
    );
  }
}

function createNotificationClient(
  pointer: UnsafeMutableRawPointer
): NotificationClient {
  const instance = Object.create(NotificationClient.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeNotificationClient = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = NotificationClient;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createNotificationClient(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export interface RoomDirectorySearchInterface {
  isAtLastPage() /*throws*/ : Promise<boolean>;
  loadedPages() /*throws*/ : Promise</*u32*/ number>;
  nextPage() /*throws*/ : Promise<void>;
  results(listener: RoomDirectorySearchEntriesListener): Promise<TaskHandle>;
  search(
    filter: string | undefined,
    batchSize: /*u32*/ number
  ) /*throws*/ : Promise<void>;
}

export class RoomDirectorySearch
  implements RoomDirectorySearchInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public async isAtLastPage(): Promise<boolean> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_i8,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_i8,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_i8,
      liftFunc: FfiConverterBool.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async loadedPages(): Promise</*u32*/ number> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_u32,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_u32,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_u32,
      liftFunc: FfiConverterUInt32.lift,
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async nextPage(): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
          this.uniffiClonePointer()
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  public async results(
    listener: RoomDirectorySearchEntriesListener
  ): Promise<TaskHandle> {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
          this.uniffiClonePointer(),
          FfiConverterTypeRoomDirectorySearchEntriesListener.lower(listener)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_pointer,
      completeFunc:
        NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_pointer,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_pointer,
      liftFunc: FfiConverterTypeTaskHandle.lift,
      errorHandler: undefined,
    });
  }

  public async search(
    filter: string | undefined,
    batchSize: /*u32*/ number
  ): Promise<void> /*throws*/ {
    return await uniffiRustCallAsync({
      rustFutureFunc: () => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
          this.uniffiClonePointer(),
          FfiConverterOptionalString.lower(filter),
          FfiConverterUInt32.lower(batchSize)
        );
      },
      pollFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_poll_void,
      completeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_complete_void,
      freeFunc: NativeModule.ffi_matrix_sdk_ffi_rust_future_free_void,
      liftFunc: (_v) => {},
      errorHandler: FfiConverterTypeClientError.lift,
    });
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(
        this.pointer,
        callStatus
      )
    );
  }
}

function createRoomDirectorySearch(
  pointer: UnsafeMutableRawPointer
): RoomDirectorySearch {
  const instance = Object.create(RoomDirectorySearch.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeRoomDirectorySearch = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = RoomDirectorySearch;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createRoomDirectorySearch(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for ClientDelegate | undefined
const FfiConverterOptionalTypeClientDelegate = new FfiConverterOptional(
  FfiConverterTypeClientDelegate
);

// FfiConverter for Map<string, /*i64*/bigint>
const FfiConverterMapStringInt64 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt64
);

// Enum: AccountManagementAction
export enum AccountManagementActionKind {
  PROFILE = 'Profile',
  SESSIONS_LIST = 'SessionsList',
  SESSION_VIEW = 'SessionView',
  SESSION_END = 'SessionEnd',
  ACCOUNT_DEACTIVATE = 'AccountDeactivate',
  CROSS_SIGNING_RESET = 'CrossSigningReset',
}
export type AccountManagementAction =
  | { kind: AccountManagementActionKind.PROFILE }
  | { kind: AccountManagementActionKind.SESSIONS_LIST }
  | {
      kind: AccountManagementActionKind.SESSION_VIEW;
      value: { deviceId: string };
    }
  | {
      kind: AccountManagementActionKind.SESSION_END;
      value: { deviceId: string };
    }
  | { kind: AccountManagementActionKind.ACCOUNT_DEACTIVATE }
  | { kind: AccountManagementActionKind.CROSS_SIGNING_RESET };

// FfiConverter for enum AccountManagementAction
const FfiConverterTypeAccountManagementAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AccountManagementAction;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return { kind: AccountManagementActionKind.PROFILE };
        case 2:
          return { kind: AccountManagementActionKind.SESSIONS_LIST };
        case 3:
          return {
            kind: AccountManagementActionKind.SESSION_VIEW,
            value: {
              deviceId: FfiConverterString.read(from),
            },
          };
        case 4:
          return {
            kind: AccountManagementActionKind.SESSION_END,
            value: {
              deviceId: FfiConverterString.read(from),
            },
          };
        case 5:
          return { kind: AccountManagementActionKind.ACCOUNT_DEACTIVATE };
        case 6:
          return { kind: AccountManagementActionKind.CROSS_SIGNING_RESET };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case AccountManagementActionKind.PROFILE: {
          ordinalConverter.write(1, into);
          return;
        }
        case AccountManagementActionKind.SESSIONS_LIST: {
          ordinalConverter.write(2, into);
          return;
        }
        case AccountManagementActionKind.SESSION_VIEW: {
          ordinalConverter.write(3, into);
          const inner = value.value;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementActionKind.SESSION_END: {
          ordinalConverter.write(4, into);
          const inner = value.value;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementActionKind.ACCOUNT_DEACTIVATE: {
          ordinalConverter.write(5, into);
          return;
        }
        case AccountManagementActionKind.CROSS_SIGNING_RESET: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that AccountManagementActionKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case AccountManagementActionKind.PROFILE: {
          return ordinalConverter.allocationSize(1);
        }
        case AccountManagementActionKind.SESSIONS_LIST: {
          return ordinalConverter.allocationSize(2);
        }
        case AccountManagementActionKind.SESSION_VIEW: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementActionKind.SESSION_END: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementActionKind.ACCOUNT_DEACTIVATE: {
          return ordinalConverter.allocationSize(5);
        }
        case AccountManagementActionKind.CROSS_SIGNING_RESET: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for SessionVerificationControllerDelegate | undefined
const FfiConverterOptionalTypeSessionVerificationControllerDelegate =
  new FfiConverterOptional(
    FfiConverterTypeSessionVerificationControllerDelegate
  );

export interface SessionVerificationEmojiInterface {
  description(): string;
  symbol(): string;
}

export class SessionVerificationEmoji
  implements SessionVerificationEmojiInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public description(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public symbol(): string {
    return FfiConverterString.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(
        this.pointer,
        callStatus
      )
    );
  }
}

function createSessionVerificationEmoji(
  pointer: UnsafeMutableRawPointer
): SessionVerificationEmoji {
  const instance = Object.create(SessionVerificationEmoji.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeSessionVerificationEmoji = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = SessionVerificationEmoji;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createSessionVerificationEmoji(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

export class ClientBuildException extends Error {
  private constructor(message: string) {
    super(message);
  }
  static Sdk = class Sdk extends ClientBuildException {
    constructor(message: string) {
      super(message);
    }
  };

  static Generic = class Generic extends ClientBuildException {
    constructor(message: string) {
      super(message);
    }
  };
}

const FfiConverterTypeClientBuildError = (() => {
  const intConverter = FfiConverterInt32;
  const stringConverter = FfiConverterString;

  type TypeName = ClientBuildException;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ClientBuildException.Sdk(stringConverter.read(from));

        case 2:
          return new ClientBuildException.Generic(stringConverter.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      if (value instanceof ClientBuildException.Sdk) {
        intConverter.write(0, into);
      } else if (value instanceof ClientBuildException.Generic) {
        intConverter.write(1, into);
      } else {
        throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      throw new Error('Method not implemented.');
    }
  }
  return new FfiConverter();
})();

export interface UnreadNotificationsCountInterface {
  hasNotifications(): boolean;
  highlightCount(): /*u32*/ number;
  notificationCount(): /*u32*/ number;
}

export class UnreadNotificationsCount
  implements UnreadNotificationsCountInterface, UniffiObjectInterface
{
  private pointer: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    this.pointer = pointer;
  }

  public hasNotifications(): boolean {
    return FfiConverterBool.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public highlightCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  public notificationCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      rustCall((callStatus) => {
        return NativeModule.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
          this.uniffiClonePointer(),
          callStatus
        );
      })
    );
  }

  // UniffiObjectInterface
  destroy(): void {
    rustCall((callStatus) => {
      NativeModule.uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(
        this.pointer,
        callStatus
      );
    });
  }

  uniffiClonePointer(): UnsafeMutableRawPointer {
    return rustCall((callStatus) =>
      NativeModule.uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(
        this.pointer,
        callStatus
      )
    );
  }
}

function createUnreadNotificationsCount(
  pointer: UnsafeMutableRawPointer
): UnreadNotificationsCount {
  const instance = Object.create(UnreadNotificationsCount.prototype);
  instance.pointer = pointer;
  return instance;
}

const FfiConverterTypeUnreadNotificationsCount = (() => {
  const pointerConverter = FfiConverterUInt64;
  type TypeName = UnreadNotificationsCount;
  class FFIConverter
    implements FfiConverter<UnsafeMutableRawPointer, TypeName>
  {
    lift(value: UnsafeMutableRawPointer): TypeName {
      return createUnreadNotificationsCount(value);
    }
    lower(value: TypeName): UnsafeMutableRawPointer {
      return value.uniffiClonePointer();
    }
    read(from: RustBuffer): TypeName {
      return this.lift(pointerConverter.read(from));
    }
    write(value: TypeName, into: RustBuffer): void {
      pointerConverter.write(this.lower(value), into);
    }
    allocationSize(value: TypeName): number {
      return pointerConverter.allocationSize(BigInt(0));
    }
  }
  return new FFIConverter();
})();

// FfiConverter for ProgressWatcher | undefined
const FfiConverterOptionalTypeProgressWatcher = new FfiConverterOptional(
  FfiConverterTypeProgressWatcher
);

// FfiConverter for RoomListEntriesUpdate[]
const FfiConverterArrayTypeRoomListEntriesUpdate = new FfiConverterArray(
  FfiConverterTypeRoomListEntriesUpdate
);

// FfiConverter for RoomListEntry[]
const FfiConverterArrayTypeRoomListEntry = new FfiConverterArray(
  FfiConverterTypeRoomListEntry
);

// FfiConverter for TimelineEventTypeFilter | undefined
const FfiConverterOptionalTypeTimelineEventTypeFilter =
  new FfiConverterOptional(FfiConverterTypeTimelineEventTypeFilter);

// FfiConverter for Room[]
const FfiConverterArrayTypeRoom = new FfiConverterArray(FfiConverterTypeRoom);

// FfiConverter for TimelineItem[]
const FfiConverterArrayTypeTimelineItem = new FfiConverterArray(
  FfiConverterTypeTimelineItem
);

// FfiConverter for MembershipChange | undefined
const FfiConverterOptionalTypeMembershipChange = new FfiConverterOptional(
  FfiConverterTypeMembershipChange
);

// FfiConverter for Room | undefined
const FfiConverterOptionalTypeRoom = new FfiConverterOptional(
  FfiConverterTypeRoom
);

// FfiConverter for PushFormat | undefined
const FfiConverterOptionalTypePushFormat = new FfiConverterOptional(
  FfiConverterTypePushFormat
);

// FfiConverter for string[] | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for FilterTimelineEventType[]
const FfiConverterArrayTypeFilterTimelineEventType = new FfiConverterArray(
  FfiConverterTypeFilterTimelineEventType
);

// FfiConverter for RoomNotificationMode | undefined
const FfiConverterOptionalTypeRoomNotificationMode = new FfiConverterOptional(
  FfiConverterTypeRoomNotificationMode
);

// FfiConverter for MediaSource | undefined
const FfiConverterOptionalTypeMediaSource = new FfiConverterOptional(
  FfiConverterTypeMediaSource
);

// FfiConverter for RequiredState[] | undefined
const FfiConverterOptionalArrayTypeRequiredState = new FfiConverterOptional(
  FfiConverterArrayTypeRequiredState
);

// FfiConverter for WidgetEventFilter[]
const FfiConverterArrayTypeWidgetEventFilter = new FfiConverterArray(
  FfiConverterTypeWidgetEventFilter
);

// FfiConverter for AssetType | undefined
const FfiConverterOptionalTypeAssetType = new FfiConverterOptional(
  FfiConverterTypeAssetType
);

// FfiConverter for Map<string, /*i64*/bigint> | undefined
const FfiConverterOptionalMapStringInt64 = new FfiConverterOptional(
  FfiConverterMapStringInt64
);

// FfiConverter for Map<string, string[]>
const FfiConverterMapStringArrayString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterArrayString
);

// FfiConverter for TimelineDiff[]
const FfiConverterArrayTypeTimelineDiff = new FfiConverterArray(
  FfiConverterTypeTimelineDiff
);

// FfiConverter for HomeserverLoginDetails | undefined
const FfiConverterOptionalTypeHomeserverLoginDetails = new FfiConverterOptional(
  FfiConverterTypeHomeserverLoginDetails
);

// FfiConverter for TimelineItem | undefined
const FfiConverterOptionalTypeTimelineItem = new FfiConverterOptional(
  FfiConverterTypeTimelineItem
);

// FfiConverter for Message | undefined
const FfiConverterOptionalTypeMessage = new FfiConverterOptional(
  FfiConverterTypeMessage
);

// FfiConverter for RoomListEntriesDynamicFilterKind[]
const FfiConverterArrayTypeRoomListEntriesDynamicFilterKind =
  new FfiConverterArray(FfiConverterTypeRoomListEntriesDynamicFilterKind);

// FfiConverter for VirtualTimelineItem | undefined
const FfiConverterOptionalTypeVirtualTimelineItem = new FfiConverterOptional(
  FfiConverterTypeVirtualTimelineItem
);

// FfiConverter for EventSendState | undefined
const FfiConverterOptionalTypeEventSendState = new FfiConverterOptional(
  FfiConverterTypeEventSendState
);

// FfiConverter for RoomMember[] | undefined
const FfiConverterOptionalArrayTypeRoomMember = new FfiConverterOptional(
  FfiConverterArrayTypeRoomMember
);

// FfiConverter for RoomDirectorySearchEntryUpdate[]
const FfiConverterArrayTypeRoomDirectorySearchEntryUpdate =
  new FfiConverterArray(FfiConverterTypeRoomDirectorySearchEntryUpdate);

// FfiConverter for EventTimelineItem | undefined
const FfiConverterOptionalTypeEventTimelineItem = new FfiConverterOptional(
  FfiConverterTypeEventTimelineItem
);

// FfiConverter for SessionVerificationEmoji[]
const FfiConverterArrayTypeSessionVerificationEmoji = new FfiConverterArray(
  FfiConverterTypeSessionVerificationEmoji
);

// FfiConverter for TaskHandle | undefined
const FfiConverterOptionalTypeTaskHandle = new FfiConverterOptional(
  FfiConverterTypeTaskHandle
);

// FfiConverter for PublicRoomJoinRule | undefined
const FfiConverterOptionalTypePublicRoomJoinRule = new FfiConverterOptional(
  FfiConverterTypePublicRoomJoinRule
);

// FfiConverter for AccountManagementAction | undefined
const FfiConverterOptionalTypeAccountManagementAction =
  new FfiConverterOptional(FfiConverterTypeAccountManagementAction);

// FfiConverter for TimelineItem[] | undefined
const FfiConverterOptionalArrayTypeTimelineItem = new FfiConverterOptional(
  FfiConverterArrayTypeTimelineItem
);

export default Object.freeze({
  FfiConverterTypeAccountManagementAction,
  FfiConverterTypeAssetType,
  FfiConverterTypeAudioInfo,
  FfiConverterTypeAudioMessageContent,
  FfiConverterTypeAuthenticationService,
  FfiConverterTypeBackupState,
  FfiConverterTypeBackupUploadState,
  FfiConverterTypeClient,
  FfiConverterTypeClientBuilder,
  FfiConverterTypeClientProperties,
  FfiConverterTypeCreateRoomParameters,
  FfiConverterTypeEmoteMessageContent,
  FfiConverterTypeEnableRecoveryProgress,
  FfiConverterTypeEncryptedMessage,
  FfiConverterTypeEncryption,
  FfiConverterTypeEncryptionSystem,
  FfiConverterTypeEventSendState,
  FfiConverterTypeEventTimelineItem,
  FfiConverterTypeEventTimelineItemDebugInfo,
  FfiConverterTypeFileInfo,
  FfiConverterTypeFileMessageContent,
  FfiConverterTypeFilterTimelineEventType,
  FfiConverterTypeFormattedBody,
  FfiConverterTypeHomeserverLoginDetails,
  FfiConverterTypeHttpPusherData,
  FfiConverterTypeImageInfo,
  FfiConverterTypeImageMessageContent,
  FfiConverterTypeInReplyToDetails,
  FfiConverterTypeInsertData,
  FfiConverterTypeLocationContent,
  FfiConverterTypeLogLevel,
  FfiConverterTypeMatrixEntity,
  FfiConverterTypeMatrixId,
  FfiConverterTypeMediaFileHandle,
  FfiConverterTypeMediaInfoError,
  FfiConverterTypeMediaSource,
  FfiConverterTypeMembership,
  FfiConverterTypeMembershipChange,
  FfiConverterTypeMembershipState,
  FfiConverterTypeMentions,
  FfiConverterTypeMessage,
  FfiConverterTypeMessageFormat,
  FfiConverterTypeMessageLikeEventContent,
  FfiConverterTypeMessageLikeEventType,
  FfiConverterTypeMessageType,
  FfiConverterTypeNoticeMessageContent,
  FfiConverterTypeNotificationClient,
  FfiConverterTypeNotificationEvent,
  FfiConverterTypeNotificationItem,
  FfiConverterTypeNotificationPowerLevels,
  FfiConverterTypeNotificationProcessSetup,
  FfiConverterTypeNotificationRoomInfo,
  FfiConverterTypeNotificationSenderInfo,
  FfiConverterTypeNotificationSettings,
  FfiConverterTypeNotifyType,
  FfiConverterTypeOidcAuthenticationData,
  FfiConverterTypeOidcConfiguration,
  FfiConverterTypeOtherState,
  FfiConverterTypePollAnswer,
  FfiConverterTypePollKind,
  FfiConverterTypePowerLevels,
  FfiConverterTypeProfileDetails,
  FfiConverterTypePublicRoomJoinRule,
  FfiConverterTypePushFormat,
  FfiConverterTypePusherIdentifiers,
  FfiConverterTypePusherKind,
  FfiConverterTypeReaction,
  FfiConverterTypeReactionSenderData,
  FfiConverterTypeReceipt,
  FfiConverterTypeReceiptType,
  FfiConverterTypeRecoveryState,
  FfiConverterTypeRepliedToEventDetails,
  FfiConverterTypeRequiredState,
  FfiConverterTypeResolvedRoomAlias,
  FfiConverterTypeRoom,
  FfiConverterTypeRoomDescription,
  FfiConverterTypeRoomDirectorySearch,
  FfiConverterTypeRoomDirectorySearchEntriesResult,
  FfiConverterTypeRoomDirectorySearchEntryUpdate,
  FfiConverterTypeRoomInfo,
  FfiConverterTypeRoomList,
  FfiConverterTypeRoomListDynamicEntriesController,
  FfiConverterTypeRoomListEntriesDynamicFilterKind,
  FfiConverterTypeRoomListEntriesResult,
  FfiConverterTypeRoomListEntriesUpdate,
  FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult,
  FfiConverterTypeRoomListEntry,
  FfiConverterTypeRoomListFilterCategory,
  FfiConverterTypeRoomListInput,
  FfiConverterTypeRoomListItem,
  FfiConverterTypeRoomListLoadingState,
  FfiConverterTypeRoomListLoadingStateResult,
  FfiConverterTypeRoomListRange,
  FfiConverterTypeRoomListService,
  FfiConverterTypeRoomListServiceState,
  FfiConverterTypeRoomListServiceSyncIndicator,
  FfiConverterTypeRoomMember,
  FfiConverterTypeRoomMembersIterator,
  FfiConverterTypeRoomMessageEventContentWithoutRelation,
  FfiConverterTypeRoomNotificationMode,
  FfiConverterTypeRoomNotificationSettings,
  FfiConverterTypeRoomPowerLevels,
  FfiConverterTypeRoomPreset,
  FfiConverterTypeRoomPreview,
  FfiConverterTypeRoomSubscription,
  FfiConverterTypeRoomTimelineListenerResult,
  FfiConverterTypeRoomVisibility,
  FfiConverterTypeRtcApplicationType,
  FfiConverterTypeSearchUsersResults,
  FfiConverterTypeSendAttachmentJoinHandle,
  FfiConverterTypeSession,
  FfiConverterTypeSessionVerificationController,
  FfiConverterTypeSessionVerificationData,
  FfiConverterTypeSessionVerificationEmoji,
  FfiConverterTypeSetData,
  FfiConverterTypeSpan,
  FfiConverterTypeStateEventContent,
  FfiConverterTypeStateEventType,
  FfiConverterTypeSyncService,
  FfiConverterTypeSyncServiceBuilder,
  FfiConverterTypeSyncServiceState,
  FfiConverterTypeTaskHandle,
  FfiConverterTypeTextMessageContent,
  FfiConverterTypeThumbnailInfo,
  FfiConverterTypeTimeline,
  FfiConverterTypeTimelineChange,
  FfiConverterTypeTimelineDiff,
  FfiConverterTypeTimelineEvent,
  FfiConverterTypeTimelineEventType,
  FfiConverterTypeTimelineEventTypeFilter,
  FfiConverterTypeTimelineItem,
  FfiConverterTypeTimelineItemContent,
  FfiConverterTypeTimelineItemContentKind,
  FfiConverterTypeTracingConfiguration,
  FfiConverterTypeTracingFileConfiguration,
  FfiConverterTypeTransmissionProgress,
  FfiConverterTypeUnableToDecryptInfo,
  FfiConverterTypeUnreadNotificationsCount,
  FfiConverterTypeUnstableAudioDetailsContent,
  FfiConverterTypeUnstableVoiceContent,
  FfiConverterTypeUserPowerLevelUpdate,
  FfiConverterTypeUserProfile,
  FfiConverterTypeVerificationState,
  FfiConverterTypeVideoInfo,
  FfiConverterTypeVideoMessageContent,
  FfiConverterTypeVirtualElementCallWidgetOptions,
  FfiConverterTypeVirtualTimelineItem,
  FfiConverterTypeWidgetCapabilities,
  FfiConverterTypeWidgetDriver,
  FfiConverterTypeWidgetDriverAndHandle,
  FfiConverterTypeWidgetDriverHandle,
  FfiConverterTypeWidgetEventFilter,
  FfiConverterTypeWidgetSettings,
});
