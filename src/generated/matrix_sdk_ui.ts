// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import NativeModule from './matrix_sdk_ui-ffi';
import { UniffiInternalError } from 'uniffi-bindgen-react-native/errors';
import {
  type FfiConverter,
  AbstractFfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
} from 'uniffi-bindgen-react-native/ffi-converters';
import { RustBuffer } from 'uniffi-bindgen-react-native/ffi-types';
import {
  initializeWithStringLifter,
  rustCall,
} from 'uniffi-bindgen-react-native/rust-call';

// Get converters from the other files, if any.

// Public interface members begin here.

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      return from.read(length, arrayBufferToString);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.write(numBytes, () => stringToArrayBuffer(value));
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();
initializeWithStringLifter(FfiConverterString.lift);

// Enum: LiveBackPaginationStatus
export enum LiveBackPaginationStatusKind {
  IDLE = 'Idle',
  PAGINATING = 'Paginating',
}
/**
 * Status for the back-pagination on a live timeline.
 */
export type LiveBackPaginationStatus =
  /**
   * No back-pagination is happening right now.
   */
  | {
      kind: LiveBackPaginationStatusKind.IDLE;
      value: { hitStartOfTimeline: boolean };
    }
  /**
   * Back-pagination is already running in the background.
   */
  | { kind: LiveBackPaginationStatusKind.PAGINATING };

// FfiConverter for enum LiveBackPaginationStatus
const FfiConverterTypeLiveBackPaginationStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LiveBackPaginationStatus;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return {
            kind: LiveBackPaginationStatusKind.IDLE,
            value: {
              hitStartOfTimeline: FfiConverterBool.read(from),
            },
          };
        case 2:
          return { kind: LiveBackPaginationStatusKind.PAGINATING };
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.kind) {
        case LiveBackPaginationStatusKind.IDLE: {
          ordinalConverter.write(1, into);
          const inner = value.value;
          FfiConverterBool.write(inner.hitStartOfTimeline, into);
          return;
        }
        case LiveBackPaginationStatusKind.PAGINATING: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that LiveBackPaginationStatusKind hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.kind) {
        case LiveBackPaginationStatusKind.IDLE: {
          const inner = value.value;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.hitStartOfTimeline);
          return size;
        }
        case LiveBackPaginationStatusKind.PAGINATING: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Where this event came.
 */
export enum EventItemOrigin {
  /**
   * The event was created locally.
   */
  LOCAL,
  /**
   * The event came from a sync response.
   */
  SYNC,
  /**
   * The event came from pagination.
   */
  PAGINATION,
}

const FfiConverterTypeEventItemOrigin = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventItemOrigin;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return EventItemOrigin.LOCAL;
        case 2:
          return EventItemOrigin.SYNC;
        case 3:
          return EventItemOrigin.PAGINATION;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case EventItemOrigin.LOCAL:
          return ordinalConverter.write(1, into);
        case EventItemOrigin.SYNC:
          return ordinalConverter.write(2, into);
        case EventItemOrigin.PAGINATION:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export default Object.freeze({
  FfiConverterTypeEventItemOrigin,
  FfiConverterTypeLiveBackPaginationStatus,
});
