// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import NativeModule from './matrix_sdk-ffi';
import { UniffiInternalError } from 'uniffi-bindgen-react-native/errors';
import {
  type FfiConverter,
  AbstractFfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterOptional,
} from 'uniffi-bindgen-react-native/ffi-converters';
import { RustBuffer } from 'uniffi-bindgen-react-native/ffi-types';
import { uniffiCreateRecord } from 'uniffi-bindgen-react-native/records';
import {
  initializeWithStringLifter,
  rustCall,
} from 'uniffi-bindgen-react-native/rust-call';

// Get converters from the other files, if any.

// Public interface members begin here.

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    NativeModule.uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      return from.read(length, arrayBufferToString);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.write(numBytes, () => stringToArrayBuffer(value));
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();
initializeWithStringLifter(FfiConverterString.lift);

/**
 * A set of common power levels required for various operations within a room,
 * that can be applied as a single operation. When updating these
 * settings, any levels that are `None` will remain unchanged.
 */
export type RoomPowerLevelChanges = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint | undefined;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint | undefined;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint | undefined;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint | undefined;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint | undefined;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint | undefined;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RoomPowerLevelChanges} record objects.
 */
export const RoomPowerLevelChangesFactory = (() => {
  const defaults = () => ({
    ban: undefined,
    invite: undefined,
    kick: undefined,
    redact: undefined,
    eventsDefault: undefined,
    stateDefault: undefined,
    usersDefault: undefined,
    roomName: undefined,
    roomAvatar: undefined,
    roomTopic: undefined,
  });
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create: (() => {
      return uniffiCreateRecord<
        RoomPowerLevelChanges,
        ReturnType<typeof defaults>
      >(defaults);
    })(),

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevelChanges>,
  });
})();

const FfiConverterTypeRoomPowerLevelChanges = (() => {
  type TypeName = RoomPowerLevelChanges;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterOptionalInt64.read(from),
        invite: FfiConverterOptionalInt64.read(from),
        kick: FfiConverterOptionalInt64.read(from),
        redact: FfiConverterOptionalInt64.read(from),
        eventsDefault: FfiConverterOptionalInt64.read(from),
        stateDefault: FfiConverterOptionalInt64.read(from),
        usersDefault: FfiConverterOptionalInt64.read(from),
        roomName: FfiConverterOptionalInt64.read(from),
        roomAvatar: FfiConverterOptionalInt64.read(from),
        roomTopic: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.ban, into);
      FfiConverterOptionalInt64.write(value.invite, into);
      FfiConverterOptionalInt64.write(value.kick, into);
      FfiConverterOptionalInt64.write(value.redact, into);
      FfiConverterOptionalInt64.write(value.eventsDefault, into);
      FfiConverterOptionalInt64.write(value.stateDefault, into);
      FfiConverterOptionalInt64.write(value.usersDefault, into);
      FfiConverterOptionalInt64.write(value.roomName, into);
      FfiConverterOptionalInt64.write(value.roomAvatar, into);
      FfiConverterOptionalInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.ban) +
        FfiConverterOptionalInt64.allocationSize(value.invite) +
        FfiConverterOptionalInt64.allocationSize(value.kick) +
        FfiConverterOptionalInt64.allocationSize(value.redact) +
        FfiConverterOptionalInt64.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt64.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt64.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt64.allocationSize(value.roomName) +
        FfiConverterOptionalInt64.allocationSize(value.roomAvatar) +
        FfiConverterOptionalInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Settings for end-to-end encryption features.
 */
export enum BackupDownloadStrategy {
  /**
   * Automatically download all room keys from the backup when the backup
   * recovery key has been received. The backup recovery key can be received
   * in two ways:
   *
   * 1. Received as a `m.secret.send` to-device event, after a successful
   * interactive verification.
   * 2. Imported from secret storage (4S) using the
   * [`SecretStore::import_secrets()`] method.
   *
   * [`SecretStore::import_secrets()`]: crate::encryption::secret_storage::SecretStore::import_secrets
   */
  ONE_SHOT,
  /**
   * Attempt to download a single room key if an event fails to be decrypted.
   */
  AFTER_DECRYPTION_FAILURE,
  /**
   * Don't download any room keys automatically. The user can manually
   * download room keys using the [`Backups::download_room_key()`] methods.
   *
   * This is the default option.
   */
  MANUAL,
}

const FfiConverterTypeBackupDownloadStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupDownloadStrategy;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupDownloadStrategy.ONE_SHOT;
        case 2:
          return BackupDownloadStrategy.AFTER_DECRYPTION_FAILURE;
        case 3:
          return BackupDownloadStrategy.MANUAL;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupDownloadStrategy.ONE_SHOT:
          return ordinalConverter.write(1, into);
        case BackupDownloadStrategy.AFTER_DECRYPTION_FAILURE:
          return ordinalConverter.write(2, into);
        case BackupDownloadStrategy.MANUAL:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Current state of a [`Paginator`].
 */
export enum PaginatorState {
  /**
   * The initial state of the paginator.
   */
  INITIAL,
  /**
   * The paginator is fetching the target initial event.
   */
  FETCHING_TARGET_EVENT,
  /**
   * The target initial event could be found, zero or more paginations have
   * happened since then, and the paginator is at rest now.
   */
  IDLE,
  /**
   * The paginator isâ€¦ paginating one direction or another.
   */
  PAGINATING,
}

const FfiConverterTypePaginatorState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaginatorState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaginatorState.INITIAL;
        case 2:
          return PaginatorState.FETCHING_TARGET_EVENT;
        case 3:
          return PaginatorState.IDLE;
        case 4:
          return PaginatorState.PAGINATING;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaginatorState.INITIAL:
          return ordinalConverter.write(1, into);
        case PaginatorState.FETCHING_TARGET_EVENT:
          return ordinalConverter.write(2, into);
        case PaginatorState.IDLE:
          return ordinalConverter.write(3, into);
        case PaginatorState.PAGINATING:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The role of a member in a room.
 */
export enum RoomMemberRole {
  /**
   * The member is an administrator.
   */
  ADMINISTRATOR,
  /**
   * The member is a moderator.
   */
  MODERATOR,
  /**
   * The member is a regular user.
   */
  USER,
}

const FfiConverterTypeRoomMemberRole = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMemberRole;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMemberRole.ADMINISTRATOR;
        case 2:
          return RoomMemberRole.MODERATOR;
        case 3:
          return RoomMemberRole.USER;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMemberRole.ADMINISTRATOR:
          return ordinalConverter.write(1, into);
        case RoomMemberRole.MODERATOR:
          return ordinalConverter.write(2, into);
        case RoomMemberRole.USER:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

export default Object.freeze({
  FfiConverterTypeBackupDownloadStrategy,
  FfiConverterTypePaginatorState,
  FfiConverterTypeRoomMemberRole,
  FfiConverterTypeRoomPowerLevelChanges,
});
